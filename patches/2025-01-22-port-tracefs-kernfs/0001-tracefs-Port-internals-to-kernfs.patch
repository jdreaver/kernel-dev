From 94643f94a540cad0deb6664e656e7fb2971fbf2b Mon Sep 17 00:00:00 2001
From: David Reaver <me@davidreaver.com>
Date: Wed, 22 Jan 2025 14:05:39 -0800
Subject: [PATCH 1/2] tracefs: Port internals to kernfs
To: Steven Rostedt <rostedt@goodmis.org>,
    Masami Hiramatsu <mhiramat@kernel.org>,
    Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>,
    Tejun Heo <tj@kernel.org>,
    Christian Brauner <brauner@kernel.org>,
    linux-trace-kernel@vger.kernel.org,
    linux-fsdevel@vger.kernel.org,
    linux-kernel@vger.kernel.org

Signed-off-by: David Reaver <me@davidreaver.com>
Suggested-by: Christian Brauner <brauner@kernel.org>
---
 fs/kernfs/inode.c       |  10 +
 fs/tracefs/inode.c      | 569 ++++++++++++----------------------------
 fs/tracefs/internal.h   |   3 +
 include/linux/kernfs.h  |   3 +
 include/linux/tracefs.h |  17 +-
 5 files changed, 197 insertions(+), 405 deletions(-)

diff --git a/fs/kernfs/inode.c b/fs/kernfs/inode.c
index b83054da68b3..9a2833f58cb5 100644
--- a/fs/kernfs/inode.c
+++ b/fs/kernfs/inode.c
@@ -196,6 +196,16 @@ int kernfs_iop_getattr(struct mnt_idmap *idmap,
 	return 0;
 }
 
+kuid_t kernfs_node_owner(struct kernfs_node *kn)
+{
+	return kernfs_iattrs(kn)->ia_uid;
+}
+
+kgid_t kernfs_node_group(struct kernfs_node *kn)
+{
+	return kernfs_iattrs(kn)->ia_gid;
+}
+
 static void kernfs_init_inode(struct kernfs_node *kn, struct inode *inode)
 {
 	kernfs_get(kn);
diff --git a/fs/tracefs/inode.c b/fs/tracefs/inode.c
index cfc614c638da..74c5cd78a279 100644
--- a/fs/tracefs/inode.c
+++ b/fs/tracefs/inode.c
@@ -24,7 +24,8 @@
 #include "internal.h"
 
 #define TRACEFS_DEFAULT_MODE	0700
-static struct kmem_cache *tracefs_inode_cachep __ro_after_init;
+static struct kernfs_root *tracefs_root;
+static struct kernfs_node *tracefs_kfs_root_node;
 
 static struct vfsmount *tracefs_mount;
 static int tracefs_mount_count;
@@ -37,56 +38,34 @@ static bool tracefs_registered;
 static DEFINE_SPINLOCK(tracefs_inode_lock);
 static LIST_HEAD(tracefs_inodes);
 
-static struct inode *tracefs_alloc_inode(struct super_block *sb)
+static ssize_t tracefs_kf_default_read(struct kernfs_open_file *of, char *buf,
+				       size_t count, loff_t pos)
 {
-	struct tracefs_inode *ti;
-	unsigned long flags;
-
-	ti = alloc_inode_sb(sb, tracefs_inode_cachep, GFP_KERNEL);
-	if (!ti)
-		return NULL;
-
-	spin_lock_irqsave(&tracefs_inode_lock, flags);
-	list_add_rcu(&ti->list, &tracefs_inodes);
-	spin_unlock_irqrestore(&tracefs_inode_lock, flags);
-
-	return &ti->vfs_inode;
+	return 0;
 }
 
-static void tracefs_free_inode(struct inode *inode)
+static ssize_t tracefs_kf_default_write(struct kernfs_open_file *of, char *buf,
+					size_t count, loff_t pos)
 {
-	struct tracefs_inode *ti = get_tracefs(inode);
-
-	kmem_cache_free(tracefs_inode_cachep, ti);
+	return 0;
 }
 
-static void tracefs_destroy_inode(struct inode *inode)
+static loff_t tracefs_kf_default_llseek(struct kernfs_open_file *of,
+					loff_t offset, int whence)
 {
-	struct tracefs_inode *ti = get_tracefs(inode);
-	unsigned long flags;
-
-	spin_lock_irqsave(&tracefs_inode_lock, flags);
-	list_del_rcu(&ti->list);
-	spin_unlock_irqrestore(&tracefs_inode_lock, flags);
+	return noop_llseek(of->file, offset, whence);
 }
 
-static ssize_t default_read_file(struct file *file, char __user *buf,
-				 size_t count, loff_t *ppos)
+static int tracefs_kf_default_open(struct kernfs_open_file *of)
 {
 	return 0;
 }
 
-static ssize_t default_write_file(struct file *file, const char __user *buf,
-				   size_t count, loff_t *ppos)
-{
-	return count;
-}
-
-static const struct file_operations tracefs_file_operations = {
-	.read =		default_read_file,
-	.write =	default_write_file,
-	.open =		simple_open,
-	.llseek =	noop_llseek,
+static const struct kernfs_ops tracefs_default_file_kfops = {
+	.read		= tracefs_kf_default_read,
+	.write		= tracefs_kf_default_write,
+	.open		= tracefs_kf_default_open,
+	.llseek		= tracefs_kf_default_llseek,
 };
 
 static struct tracefs_dir_ops {
@@ -94,180 +73,6 @@ static struct tracefs_dir_ops {
 	int (*rmdir)(const char *name);
 } tracefs_ops __ro_after_init;
 
-static char *get_dname(struct dentry *dentry)
-{
-	const char *dname;
-	char *name;
-	int len = dentry->d_name.len;
-
-	dname = dentry->d_name.name;
-	name = kmalloc(len + 1, GFP_KERNEL);
-	if (!name)
-		return NULL;
-	memcpy(name, dname, len);
-	name[len] = 0;
-	return name;
-}
-
-static int tracefs_syscall_mkdir(struct mnt_idmap *idmap,
-				 struct inode *inode, struct dentry *dentry,
-				 umode_t mode)
-{
-	struct tracefs_inode *ti;
-	char *name;
-	int ret;
-
-	name = get_dname(dentry);
-	if (!name)
-		return -ENOMEM;
-
-	/*
-	 * This is a new directory that does not take the default of
-	 * the rootfs. It becomes the default permissions for all the
-	 * files and directories underneath it.
-	 */
-	ti = get_tracefs(inode);
-	ti->flags |= TRACEFS_INSTANCE_INODE;
-	ti->private = inode;
-
-	/*
-	 * The mkdir call can call the generic functions that create
-	 * the files within the tracefs system. It is up to the individual
-	 * mkdir routine to handle races.
-	 */
-	inode_unlock(inode);
-	ret = tracefs_ops.mkdir(name);
-	inode_lock(inode);
-
-	kfree(name);
-
-	return ret;
-}
-
-static int tracefs_syscall_rmdir(struct inode *inode, struct dentry *dentry)
-{
-	char *name;
-	int ret;
-
-	name = get_dname(dentry);
-	if (!name)
-		return -ENOMEM;
-
-	/*
-	 * The rmdir call can call the generic functions that create
-	 * the files within the tracefs system. It is up to the individual
-	 * rmdir routine to handle races.
-	 * This time we need to unlock not only the parent (inode) but
-	 * also the directory that is being deleted.
-	 */
-	inode_unlock(inode);
-	inode_unlock(d_inode(dentry));
-
-	ret = tracefs_ops.rmdir(name);
-
-	inode_lock_nested(inode, I_MUTEX_PARENT);
-	inode_lock(d_inode(dentry));
-
-	kfree(name);
-
-	return ret;
-}
-
-static void set_tracefs_inode_owner(struct inode *inode)
-{
-	struct tracefs_inode *ti = get_tracefs(inode);
-	struct inode *root_inode = ti->private;
-	kuid_t uid;
-	kgid_t gid;
-
-	uid = root_inode->i_uid;
-	gid = root_inode->i_gid;
-
-	/*
-	 * If the root is not the mount point, then check the root's
-	 * permissions. If it was never set, then default to the
-	 * mount point.
-	 */
-	if (root_inode != d_inode(root_inode->i_sb->s_root)) {
-		struct tracefs_inode *rti;
-
-		rti = get_tracefs(root_inode);
-		root_inode = d_inode(root_inode->i_sb->s_root);
-
-		if (!(rti->flags & TRACEFS_UID_PERM_SET))
-			uid = root_inode->i_uid;
-
-		if (!(rti->flags & TRACEFS_GID_PERM_SET))
-			gid = root_inode->i_gid;
-	}
-
-	/*
-	 * If this inode has never been referenced, then update
-	 * the permissions to the superblock.
-	 */
-	if (!(ti->flags & TRACEFS_UID_PERM_SET))
-		inode->i_uid = uid;
-
-	if (!(ti->flags & TRACEFS_GID_PERM_SET))
-		inode->i_gid = gid;
-}
-
-static int tracefs_permission(struct mnt_idmap *idmap,
-			      struct inode *inode, int mask)
-{
-	set_tracefs_inode_owner(inode);
-	return generic_permission(idmap, inode, mask);
-}
-
-static int tracefs_getattr(struct mnt_idmap *idmap,
-			   const struct path *path, struct kstat *stat,
-			   u32 request_mask, unsigned int flags)
-{
-	struct inode *inode = d_backing_inode(path->dentry);
-
-	set_tracefs_inode_owner(inode);
-	generic_fillattr(idmap, request_mask, inode, stat);
-	return 0;
-}
-
-static int tracefs_setattr(struct mnt_idmap *idmap, struct dentry *dentry,
-			   struct iattr *attr)
-{
-	unsigned int ia_valid = attr->ia_valid;
-	struct inode *inode = d_inode(dentry);
-	struct tracefs_inode *ti = get_tracefs(inode);
-
-	if (ia_valid & ATTR_UID)
-		ti->flags |= TRACEFS_UID_PERM_SET;
-
-	if (ia_valid & ATTR_GID)
-		ti->flags |= TRACEFS_GID_PERM_SET;
-
-	return simple_setattr(idmap, dentry, attr);
-}
-
-static const struct inode_operations tracefs_instance_dir_inode_operations = {
-	.lookup		= simple_lookup,
-	.mkdir		= tracefs_syscall_mkdir,
-	.rmdir		= tracefs_syscall_rmdir,
-	.permission	= tracefs_permission,
-	.getattr	= tracefs_getattr,
-	.setattr	= tracefs_setattr,
-};
-
-static const struct inode_operations tracefs_dir_inode_operations = {
-	.lookup		= simple_lookup,
-	.permission	= tracefs_permission,
-	.getattr	= tracefs_getattr,
-	.setattr	= tracefs_setattr,
-};
-
-static const struct inode_operations tracefs_file_inode_operations = {
-	.permission	= tracefs_permission,
-	.getattr	= tracefs_getattr,
-	.setattr	= tracefs_setattr,
-};
-
 struct inode *tracefs_get_inode(struct super_block *sb)
 {
 	struct inode *inode = new_inode(sb);
@@ -286,6 +91,14 @@ struct tracefs_fs_info {
 	unsigned int opts;
 };
 
+/* Why do we have global _and_ stuffed into tracefs_context? */
+static struct tracefs_fs_info global_info = {
+	.mode	= TRACEFS_DEFAULT_MODE,
+	.uid	= GLOBAL_ROOT_UID,
+	.gid	= GLOBAL_ROOT_GID,
+	.opts	= 0,
+};
+
 enum {
 	Opt_uid,
 	Opt_gid,
@@ -299,10 +112,24 @@ static const struct fs_parameter_spec tracefs_param_specs[] = {
 	{}
 };
 
+struct tracefs_context {
+	struct kernfs_fs_context kfc;
+ 	struct tracefs_fs_info fs_info;
+};
+
+static inline struct tracefs_context *trace_fc2context(struct fs_context *fc)
+{
+	struct kernfs_fs_context *kfc = fc->fs_private;
+
+	return container_of(kfc, struct tracefs_context, kfc);
+}
+
 static int tracefs_parse_param(struct fs_context *fc, struct fs_parameter *param)
 {
-	struct tracefs_fs_info *opts = fc->s_fs_info;
+	struct tracefs_context *ctx = trace_fc2context(fc);
+	struct tracefs_fs_info *info = &ctx->fs_info;
 	struct fs_parse_result result;
+
 	int opt;
 
 	opt = fs_parse(fc, tracefs_param_specs, param, &result);
@@ -311,13 +138,13 @@ static int tracefs_parse_param(struct fs_context *fc, struct fs_parameter *param
 
 	switch (opt) {
 	case Opt_uid:
-		opts->uid = result.uid;
+		info->uid = result.uid;
 		break;
 	case Opt_gid:
-		opts->gid = result.gid;
+		info->gid = result.gid;
 		break;
 	case Opt_mode:
-		opts->mode = result.uint_32 & S_IALLUGO;
+		info->mode = result.uint_32 & S_IALLUGO;
 		break;
 	/*
 	 * We might like to report bad mount options here;
@@ -325,51 +152,55 @@ static int tracefs_parse_param(struct fs_context *fc, struct fs_parameter *param
 	 */
 	}
 
-	opts->opts |= BIT(opt);
+	info->opts |= BIT(opt);
 
 	return 0;
 }
 
 static int tracefs_apply_options(struct super_block *sb, bool remount)
 {
-	struct tracefs_fs_info *fsi = sb->s_fs_info;
 	struct inode *inode = d_inode(sb->s_root);
 	struct tracefs_inode *ti;
 	bool update_uid, update_gid;
 	umode_t tmp_mode;
 
+	kuid_t kuid = global_info.uid;
+	kgid_t kgid = global_info.gid;
+	umode_t mode = global_info.mode;
+	unsigned int opts = global_info.opts;
+
 	/*
 	 * On remount, only reset mode/uid/gid if they were provided as mount
 	 * options.
 	 */
 
-	if (!remount || fsi->opts & BIT(Opt_mode)) {
+	if (!remount || opts & BIT(Opt_mode)) {
 		tmp_mode = READ_ONCE(inode->i_mode) & ~S_IALLUGO;
-		tmp_mode |= fsi->mode;
+		tmp_mode |= mode;
 		WRITE_ONCE(inode->i_mode, tmp_mode);
 	}
 
-	if (!remount || fsi->opts & BIT(Opt_uid))
-		inode->i_uid = fsi->uid;
+	if (!remount || opts & BIT(Opt_uid))
+		inode->i_uid = kuid;
 
-	if (!remount || fsi->opts & BIT(Opt_gid))
-		inode->i_gid = fsi->gid;
+	if (!remount || opts & BIT(Opt_gid))
+		inode->i_gid = kgid;
 
-	if (remount && (fsi->opts & BIT(Opt_uid) || fsi->opts & BIT(Opt_gid))) {
+	if (remount && (opts & BIT(Opt_uid) || opts & BIT(Opt_gid))) {
 
-		update_uid = fsi->opts & BIT(Opt_uid);
-		update_gid = fsi->opts & BIT(Opt_gid);
+		update_uid = opts & BIT(Opt_uid);
+		update_gid = opts & BIT(Opt_gid);
 
 		rcu_read_lock();
 		list_for_each_entry_rcu(ti, &tracefs_inodes, list) {
 			if (update_uid) {
 				ti->flags &= ~TRACEFS_UID_PERM_SET;
-				ti->vfs_inode.i_uid = fsi->uid;
+				ti->vfs_inode.i_uid = kuid;
 			}
 
 			if (update_gid) {
 				ti->flags &= ~TRACEFS_GID_PERM_SET;
-				ti->vfs_inode.i_gid = fsi->gid;
+				ti->vfs_inode.i_gid = kgid;
 			}
 
 			/*
@@ -386,6 +217,7 @@ static int tracefs_apply_options(struct super_block *sb, bool remount)
 	return 0;
 }
 
+/* TODO: Christian had most of this function nuked */
 static int tracefs_reconfigure(struct fs_context *fc)
 {
 	struct super_block *sb = fc->root->d_sb;
@@ -395,6 +227,7 @@ static int tracefs_reconfigure(struct fs_context *fc)
 	if (!new_opts)
 		return 0;
 
+	/* TODO: Do we need sync_filesystem with kernfs? */
 	sync_filesystem(sb);
 	/* structure copy of new mount options to sb */
 	*sb_opts = *new_opts;
@@ -402,46 +235,53 @@ static int tracefs_reconfigure(struct fs_context *fc)
 	return tracefs_apply_options(sb, true);
 }
 
-static int tracefs_show_options(struct seq_file *m, struct dentry *root)
+static int tracefs_show_options(struct seq_file *seq, struct kernfs_root *kf_root)
 {
-	struct tracefs_fs_info *fsi = root->d_sb->s_fs_info;
+	kuid_t kuid = global_info.uid;
+	kgid_t kgid = global_info.gid;
+	umode_t mode = global_info.mode;
 
-	if (!uid_eq(fsi->uid, GLOBAL_ROOT_UID))
-		seq_printf(m, ",uid=%u",
-			   from_kuid_munged(&init_user_ns, fsi->uid));
-	if (!gid_eq(fsi->gid, GLOBAL_ROOT_GID))
-		seq_printf(m, ",gid=%u",
-			   from_kgid_munged(&init_user_ns, fsi->gid));
-	if (fsi->mode != TRACEFS_DEFAULT_MODE)
-		seq_printf(m, ",mode=%o", fsi->mode);
+	if (!uid_eq(kuid, GLOBAL_ROOT_UID))
+		seq_printf(seq, ",uid=%u", from_kuid_munged(&init_user_ns, kuid));
+	if (!gid_eq(kgid, GLOBAL_ROOT_GID))
+		seq_printf(seq, ",gid=%u", from_kgid_munged(&init_user_ns, kgid));
+	if (mode != TRACEFS_DEFAULT_MODE)
+		seq_printf(seq, ",mode=%o", mode);
 
 	return 0;
-}
+ }
 
-static int tracefs_drop_inode(struct inode *inode)
-{
-	struct tracefs_inode *ti = get_tracefs(inode);
+static int tracefs_mkdir(struct kernfs_node *parent_kn, const char *name, umode_t mode)
+ {
+	int ret;
+	struct kernfs_node *kn;
 
-	/*
-	 * This inode is being freed and cannot be used for
-	 * eventfs. Clear the flag so that it doesn't call into
-	 * eventfs during the remount flag updates. The eventfs_inode
-	 * gets freed after an RCU cycle, so the content will still
-	 * be safe if the iteration is going on now.
-	 */
-	ti->flags &= ~TRACEFS_EVENT_INODE;
+	if (parent_kn != trace_instance_dir)
+		return -EPERM;
 
-	return 1;
+	kn = tracefs_create_dir(name, parent_kn);
+	if (IS_ERR(kn))
+		return PTR_ERR(kn);
+
+	ret = tracefs_ops.mkdir(name);
+	if (ret)
+		kernfs_remove(kn);
+	return ret;
 }
 
-static const struct super_operations tracefs_super_operations = {
-	.alloc_inode    = tracefs_alloc_inode,
-	.free_inode     = tracefs_free_inode,
-	.destroy_inode  = tracefs_destroy_inode,
-	.drop_inode     = tracefs_drop_inode,
-	.statfs		= simple_statfs,
-	.show_options	= tracefs_show_options,
-};
+static int tracefs_rmdir(struct kernfs_node *kn)
+ {
+	int ret;
+
+	if (kn != trace_instance_dir)
+		return -EPERM;
+
+ 	ret = tracefs_ops.rmdir(kn->name);
+	if (!ret)
+		kernfs_remove(kn);
+
+	return ret;
+}
 
 /*
  * It would be cleaner if eventfs had its own dentry ops.
@@ -464,39 +304,34 @@ static int tracefs_d_revalidate(struct dentry *dentry, unsigned int flags)
 	return !(ei && ei->is_freed);
 }
 
+/* necessary for eventsfs */
 static const struct dentry_operations tracefs_dentry_operations = {
 	.d_revalidate = tracefs_d_revalidate,
 	.d_release = tracefs_d_release,
 };
 
-static int tracefs_fill_super(struct super_block *sb, struct fs_context *fc)
-{
-	static const struct tree_descr trace_files[] = {{""}};
-	int err;
-
-	err = simple_fill_super(sb, TRACEFS_MAGIC, trace_files);
-	if (err)
-		return err;
-
-	sb->s_op = &tracefs_super_operations;
-	sb->s_d_op = &tracefs_dentry_operations;
-
-	return 0;
-}
+static struct kernfs_syscall_ops tracefs_kf_syscall_ops = {
+	.show_options		= tracefs_show_options,
+	.mkdir			= tracefs_mkdir,
+	.rmdir			= tracefs_rmdir,
+};
 
 static int tracefs_get_tree(struct fs_context *fc)
 {
-	int err = get_tree_single(fc, tracefs_fill_super);
+	int ret;
 
-	if (err)
-		return err;
+	ret = kernfs_get_tree(fc);
+	if (!ret)
+		tracefs_apply_options(fc->root->d_sb, false);
 
-	return tracefs_reconfigure(fc);
+	return ret;
 }
 
 static void tracefs_free_fc(struct fs_context *fc)
 {
-	kfree(fc->s_fs_info);
+	struct tracefs_context *ctx = trace_fc2context(fc);
+	kernfs_free_fs_context(fc);
+	kfree(ctx);
 }
 
 static const struct fs_context_operations tracefs_context_ops = {
@@ -521,12 +356,12 @@ static int tracefs_init_fs_context(struct fs_context *fc)
 	return 0;
 }
 
-static struct file_system_type trace_fs_type = {
-	.owner =	THIS_MODULE,
-	.name =		"tracefs",
-	.init_fs_context = tracefs_init_fs_context,
-	.parameters	= tracefs_param_specs,
-	.kill_sb =	kill_litter_super,
+static struct file_system_type tracefs_type = {
+	.owner			= THIS_MODULE,
+	.name 			="tracefs",
+	.init_fs_context 	= tracefs_init_fs_context,
+	.parameters		= tracefs_param_specs,
+	.kill_sb		= kill_litter_super, /* TODO do we need kill_sb? */
 };
 MODULE_ALIAS_FS("tracefs");
 
@@ -537,7 +372,7 @@ struct dentry *tracefs_start_creating(const char *name, struct dentry *parent)
 
 	pr_debug("tracefs: creating file '%s'\n",name);
 
-	error = simple_pin_fs(&trace_fs_type, &tracefs_mount,
+	error = simple_pin_fs(&tracefs_type, &tracefs_mount,
 			      &tracefs_mount_count);
 	if (error)
 		return ERR_PTR(error);
@@ -620,7 +455,7 @@ static struct inode *instance_inode(struct dentry *parent, struct inode *inode)
  * to create a directory, the tracefs_create_dir() function is
  * recommended to be used instead.)
  *
- * This function will return a pointer to a dentry if it succeeds.  This
+ * This function will return a pointer to a kernfs_node if it succeeds.  This
  * pointer must be passed to the tracefs_remove() function when the file is
  * to be removed (no automatic cleanup happens if your module is unloaded,
  * you are responsible here.)  If an error occurs, %NULL will be returned.
@@ -628,74 +463,27 @@ static struct inode *instance_inode(struct dentry *parent, struct inode *inode)
  * If tracefs is not enabled in the kernel, the value -%ENODEV will be
  * returned.
  */
-struct dentry *tracefs_create_file(const char *name, umode_t mode,
-				   struct dentry *parent, void *data,
-				   const struct file_operations *fops)
+struct kernfs_node *tracefs_create_file(const char *name, umode_t mode,
+					struct kernfs_node *parent, void *data,
+					const struct kernfs_ops *ops)
 {
-	struct tracefs_inode *ti;
-	struct dentry *dentry;
-	struct inode *inode;
-
 	if (security_locked_down(LOCKDOWN_TRACEFS))
 		return NULL;
 
 	if (!(mode & S_IFMT))
 		mode |= S_IFREG;
 	BUG_ON(!S_ISREG(mode));
-	dentry = tracefs_start_creating(name, parent);
 
-	if (IS_ERR(dentry))
-		return NULL;
+	/* TODO What is this? */
+	// inode->i_op = &tracefs_file_inode_operations;
 
-	inode = tracefs_get_inode(dentry->d_sb);
-	if (unlikely(!inode))
-		return tracefs_failed_creating(dentry);
-
-	ti = get_tracefs(inode);
-	ti->private = instance_inode(parent, inode);
-
-	inode->i_mode = mode;
-	inode->i_op = &tracefs_file_inode_operations;
-	inode->i_fop = fops ? fops : &tracefs_file_operations;
-	inode->i_private = data;
-	inode->i_uid = d_inode(dentry->d_parent)->i_uid;
-	inode->i_gid = d_inode(dentry->d_parent)->i_gid;
-	d_instantiate(dentry, inode);
-	fsnotify_create(d_inode(dentry->d_parent), dentry);
-	return tracefs_end_creating(dentry);
+	return __kernfs_create_file(parent ?: tracefs_kfs_root_node, name, mode,
+				    kernfs_node_owner(parent),
+				    kernfs_node_group(parent), PAGE_SIZE,
+				    ops ? : &tracefs_default_file_kfops, data, NULL,
+				    NULL);
 }
 
-static struct dentry *__create_dir(const char *name, struct dentry *parent,
-				   const struct inode_operations *ops)
-{
-	struct tracefs_inode *ti;
-	struct dentry *dentry = tracefs_start_creating(name, parent);
-	struct inode *inode;
-
-	if (IS_ERR(dentry))
-		return NULL;
-
-	inode = tracefs_get_inode(dentry->d_sb);
-	if (unlikely(!inode))
-		return tracefs_failed_creating(dentry);
-
-	/* Do not set bits for OTH */
-	inode->i_mode = S_IFDIR | S_IRWXU | S_IRUSR| S_IRGRP | S_IXUSR | S_IXGRP;
-	inode->i_op = ops;
-	inode->i_fop = &simple_dir_operations;
-	inode->i_uid = d_inode(dentry->d_parent)->i_uid;
-	inode->i_gid = d_inode(dentry->d_parent)->i_gid;
-
-	ti = get_tracefs(inode);
-	ti->private = instance_inode(parent, inode);
-
-	/* directory inodes start off with i_nlink == 2 (for "." entry) */
-	inc_nlink(inode);
-	d_instantiate(dentry, inode);
-	inc_nlink(d_inode(dentry->d_parent));
-	fsnotify_mkdir(d_inode(dentry->d_parent), dentry);
-	return tracefs_end_creating(dentry);
-}
 
 /**
  * tracefs_create_dir - create a directory in the tracefs filesystem
@@ -714,18 +502,21 @@ static struct dentry *__create_dir(const char *name, struct dentry *parent,
  * If tracing is not enabled in the kernel, the value -%ENODEV will be
  * returned.
  */
-struct dentry *tracefs_create_dir(const char *name, struct dentry *parent)
-{
-	if (security_locked_down(LOCKDOWN_TRACEFS))
-		return NULL;
+struct kernfs_node *tracefs_create_dir(const char *name,
+				       struct kernfs_node *parent)
+ {
+ 	if (security_locked_down(LOCKDOWN_TRACEFS))
+		return ERR_PTR(-EINVAL);
 
-	return __create_dir(name, parent, &tracefs_dir_inode_operations);
+	return kernfs_create_dir_ns(parent ?: tracefs_kfs_root_node, name,
+				  S_IFDIR | S_IRWXU | S_IRUSR | S_IRGRP |
+				  S_IXUSR | S_IXGRP,
+				  kernfs_node_owner(parent),
+				  kernfs_node_group(parent), NULL, NULL);
 }
 
 /**
  * tracefs_create_instance_dir - create the tracing instances directory
- * @name: The name of the instances directory to create
- * @parent: The parent directory that the instances directory will exist
  * @mkdir: The function to call when a mkdir is performed.
  * @rmdir: The function to call when a rmdir is performed.
  *
@@ -739,48 +530,38 @@ struct dentry *tracefs_create_dir(const char *name, struct dentry *parent)
  *
  * Returns the dentry of the instances directory.
  */
-__init struct dentry *tracefs_create_instance_dir(const char *name,
-					  struct dentry *parent,
-					  int (*mkdir)(const char *name),
-					  int (*rmdir)(const char *name))
+__init struct kernfs_node *tracefs_create_instance_dir(int (*mkdir)(const char *name),
+						       int (*rmdir)(const char *name))
 {
-	struct dentry *dentry;
-
-	/* Only allow one instance of the instances directory. */
-	if (WARN_ON(tracefs_ops.mkdir || tracefs_ops.rmdir))
-		return NULL;
-
-	dentry = __create_dir(name, parent, &tracefs_instance_dir_inode_operations);
-	if (!dentry)
-		return NULL;
+	struct kernfs_node *kn;
 
-	tracefs_ops.mkdir = mkdir;
-	tracefs_ops.rmdir = rmdir;
+ 	/* Only allow one instance of the instances directory. */
+ 	if (WARN_ON(tracefs_ops.mkdir || tracefs_ops.rmdir))
+		return ERR_PTR(-EINVAL);
 
-	return dentry;
-}
+	kn = tracefs_create_dir("instances", tracefs_kfs_root_node);
+	if (IS_ERR(kn))
+		return kn;
 
-static void remove_one(struct dentry *victim)
-{
-	simple_release_fs(&tracefs_mount, &tracefs_mount_count);
+ 	tracefs_ops.mkdir = mkdir;
+ 	tracefs_ops.rmdir = rmdir;
+	return kn;
 }
 
 /**
  * tracefs_remove - recursively removes a directory
- * @dentry: a pointer to a the dentry of the directory to be removed.
+ * @kn: a pointer to a the kernfs_node of the directory to be removed.
  *
  * This function recursively removes a directory tree in tracefs that
  * was previously created with a call to another tracefs function
  * (like tracefs_create_file() or variants thereof.)
  */
-void tracefs_remove(struct dentry *dentry)
+void tracefs_remove(struct kernfs_node *kn)
 {
-	if (IS_ERR_OR_NULL(dentry))
+	if (IS_ERR_OR_NULL(kn))
 		return;
 
-	simple_pin_fs(&trace_fs_type, &tracefs_mount, &tracefs_mount_count);
-	simple_recursive_removal(dentry, remove_one);
-	simple_release_fs(&tracefs_mount, &tracefs_mount_count);
+	kernfs_remove(kn);
 }
 
 /**
@@ -791,36 +572,30 @@ bool tracefs_initialized(void)
 	return tracefs_registered;
 }
 
-static void init_once(void *foo)
-{
-	struct tracefs_inode *ti = (struct tracefs_inode *) foo;
-
-	/* inode_init_once() calls memset() on the vfs_inode portion */
-	inode_init_once(&ti->vfs_inode);
-
-	/* Zero out the rest */
-	memset_after(ti, 0, vfs_inode);
-}
-
 static int __init tracefs_init(void)
 {
 	int retval;
+	struct kernfs_root *kfs_root;
 
-	tracefs_inode_cachep = kmem_cache_create("tracefs_inode_cache",
-						 sizeof(struct tracefs_inode),
-						 0, (SLAB_RECLAIM_ACCOUNT|
-						     SLAB_ACCOUNT),
-						 init_once);
-	if (!tracefs_inode_cachep)
-		return -ENOMEM;
+	kfs_root = kernfs_create_root(&tracefs_kf_syscall_ops,
+				      KERNFS_ROOT_CREATE_DEACTIVATED, NULL);
+	if (IS_ERR(kfs_root))
+                return PTR_ERR(kfs_root);
 
 	retval = sysfs_create_mount_point(kernel_kobj, "tracing");
-	if (retval)
+	if (retval) {
+		kernfs_destroy_root(kfs_root);
 		return -EINVAL;
+	}
 
-	retval = register_filesystem(&trace_fs_type);
+	retval = register_filesystem(&tracefs_type);
 	if (!retval)
 		tracefs_registered = true;
+	else
+		kernfs_destroy_root(kfs_root);
+
+	tracefs_root = kfs_root;
+	tracefs_kfs_root_node = kernfs_root_to_node(kfs_root);
 
 	return retval;
 }
diff --git a/fs/tracefs/internal.h b/fs/tracefs/internal.h
index d83c2a25f288..8679ebcff6c2 100644
--- a/fs/tracefs/internal.h
+++ b/fs/tracefs/internal.h
@@ -2,6 +2,9 @@
 #ifndef _TRACEFS_INTERNAL_H
 #define _TRACEFS_INTERNAL_H
 
+#include <linux/kernfs.h>
+#include <linux/module.h>
+
 enum {
 	TRACEFS_EVENT_INODE		= BIT(1),
 	TRACEFS_GID_PERM_SET		= BIT(2),
diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index 87c79d076d6d..95aafdf6f01d 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -246,6 +246,9 @@ struct kernfs_syscall_ops {
 			 struct kernfs_root *root);
 };
 
+kuid_t kernfs_node_owner(struct kernfs_node *kn);
+kgid_t kernfs_node_group(struct kernfs_node *kn);
+
 struct kernfs_node *kernfs_root_to_node(struct kernfs_root *root);
 
 struct kernfs_open_file {
diff --git a/include/linux/tracefs.h b/include/linux/tracefs.h
index d03f74658716..62f28250a2dc 100644
--- a/include/linux/tracefs.h
+++ b/include/linux/tracefs.h
@@ -13,6 +13,7 @@
 #define _TRACEFS_H_
 
 #include <linux/fs.h>
+#include <linux/kernfs.h>
 #include <linux/seq_file.h>
 
 #include <linux/types.h>
@@ -22,6 +23,7 @@ struct file_operations;
 #ifdef CONFIG_TRACING
 
 struct eventfs_file;
+extern struct kernfs_node *trace_instance_dir;
 
 /**
  * eventfs_callback - A callback function to create dynamic files in eventfs
@@ -90,17 +92,16 @@ struct eventfs_inode *eventfs_create_dir(const char *name, struct eventfs_inode
 void eventfs_remove_events_dir(struct eventfs_inode *ei);
 void eventfs_remove_dir(struct eventfs_inode *ei);
 
-struct dentry *tracefs_create_file(const char *name, umode_t mode,
-				   struct dentry *parent, void *data,
-				   const struct file_operations *fops);
+struct kernfs_node *tracefs_create_file(const char *name, umode_t mode,
+					struct kernfs_node *parent, void *data,
+					const struct kernfs_ops *ops);
 
-struct dentry *tracefs_create_dir(const char *name, struct dentry *parent);
+struct kernfs_node *tracefs_create_dir(const char *name, struct kernfs_node *parent);
 
-void tracefs_remove(struct dentry *dentry);
+void tracefs_remove(struct kernfs_node *kn);
 
-struct dentry *tracefs_create_instance_dir(const char *name, struct dentry *parent,
-					   int (*mkdir)(const char *name),
-					   int (*rmdir)(const char *name));
+struct kernfs_node *tracefs_create_instance_dir(int (*mkdir)(const char *name),
+						int (*rmdir)(const char *name));
 
 bool tracefs_initialized(void);
 
