From 72a1e46e4914f3c896c067cea35cb255a3e72454 Mon Sep 17 00:00:00 2001
From: David Reaver <me@davidreaver.com>
Date: Wed, 22 Jan 2025 14:05:39 -0800
Subject: [PATCH 4/4] tracefs: Port to kernfs
To: Steven Rostedt <rostedt@goodmis.org>,
    Masami Hiramatsu <mhiramat@kernel.org>,
    Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>,
    Tejun Heo <tj@kernel.org>,
    Christian Brauner <brauner@kernel.org>,
    linux-trace-kernel@vger.kernel.org,
    linux-fsdevel@vger.kernel.org,
    linux-kernel@vger.kernel.org

Signed-off-by: David Reaver <me@davidreaver.com>
Suggested-by: Christian Brauner <brauner@kernel.org>
---
 fs/kernfs/inode.c       |  10 +
 fs/tracefs/inode.c      | 569 +++++++++++--------------------------
 fs/tracefs/internal.h   |   3 +
 include/linux/kernfs.h  |   3 +
 include/linux/tracefs.h |  17 +-
 kernel/trace/trace.c    | 611 +++++++++++++++-------------------------
 kernel/trace/trace.h    |  32 +--
 7 files changed, 433 insertions(+), 812 deletions(-)

diff --git a/fs/kernfs/inode.c b/fs/kernfs/inode.c
index b83054da68b3..9a2833f58cb5 100644
--- a/fs/kernfs/inode.c
+++ b/fs/kernfs/inode.c
@@ -196,6 +196,16 @@ int kernfs_iop_getattr(struct mnt_idmap *idmap,
 	return 0;
 }
 
+kuid_t kernfs_node_owner(struct kernfs_node *kn)
+{
+	return kernfs_iattrs(kn)->ia_uid;
+}
+
+kgid_t kernfs_node_group(struct kernfs_node *kn)
+{
+	return kernfs_iattrs(kn)->ia_gid;
+}
+
 static void kernfs_init_inode(struct kernfs_node *kn, struct inode *inode)
 {
 	kernfs_get(kn);
diff --git a/fs/tracefs/inode.c b/fs/tracefs/inode.c
index cfc614c638da..74c5cd78a279 100644
--- a/fs/tracefs/inode.c
+++ b/fs/tracefs/inode.c
@@ -24,7 +24,8 @@
 #include "internal.h"
 
 #define TRACEFS_DEFAULT_MODE	0700
-static struct kmem_cache *tracefs_inode_cachep __ro_after_init;
+static struct kernfs_root *tracefs_root;
+static struct kernfs_node *tracefs_kfs_root_node;
 
 static struct vfsmount *tracefs_mount;
 static int tracefs_mount_count;
@@ -37,56 +38,34 @@ static bool tracefs_registered;
 static DEFINE_SPINLOCK(tracefs_inode_lock);
 static LIST_HEAD(tracefs_inodes);
 
-static struct inode *tracefs_alloc_inode(struct super_block *sb)
+static ssize_t tracefs_kf_default_read(struct kernfs_open_file *of, char *buf,
+				       size_t count, loff_t pos)
 {
-	struct tracefs_inode *ti;
-	unsigned long flags;
-
-	ti = alloc_inode_sb(sb, tracefs_inode_cachep, GFP_KERNEL);
-	if (!ti)
-		return NULL;
-
-	spin_lock_irqsave(&tracefs_inode_lock, flags);
-	list_add_rcu(&ti->list, &tracefs_inodes);
-	spin_unlock_irqrestore(&tracefs_inode_lock, flags);
-
-	return &ti->vfs_inode;
+	return 0;
 }
 
-static void tracefs_free_inode(struct inode *inode)
+static ssize_t tracefs_kf_default_write(struct kernfs_open_file *of, char *buf,
+					size_t count, loff_t pos)
 {
-	struct tracefs_inode *ti = get_tracefs(inode);
-
-	kmem_cache_free(tracefs_inode_cachep, ti);
+	return 0;
 }
 
-static void tracefs_destroy_inode(struct inode *inode)
+static loff_t tracefs_kf_default_llseek(struct kernfs_open_file *of,
+					loff_t offset, int whence)
 {
-	struct tracefs_inode *ti = get_tracefs(inode);
-	unsigned long flags;
-
-	spin_lock_irqsave(&tracefs_inode_lock, flags);
-	list_del_rcu(&ti->list);
-	spin_unlock_irqrestore(&tracefs_inode_lock, flags);
+	return noop_llseek(of->file, offset, whence);
 }
 
-static ssize_t default_read_file(struct file *file, char __user *buf,
-				 size_t count, loff_t *ppos)
+static int tracefs_kf_default_open(struct kernfs_open_file *of)
 {
 	return 0;
 }
 
-static ssize_t default_write_file(struct file *file, const char __user *buf,
-				   size_t count, loff_t *ppos)
-{
-	return count;
-}
-
-static const struct file_operations tracefs_file_operations = {
-	.read =		default_read_file,
-	.write =	default_write_file,
-	.open =		simple_open,
-	.llseek =	noop_llseek,
+static const struct kernfs_ops tracefs_default_file_kfops = {
+	.read		= tracefs_kf_default_read,
+	.write		= tracefs_kf_default_write,
+	.open		= tracefs_kf_default_open,
+	.llseek		= tracefs_kf_default_llseek,
 };
 
 static struct tracefs_dir_ops {
@@ -94,180 +73,6 @@ static struct tracefs_dir_ops {
 	int (*rmdir)(const char *name);
 } tracefs_ops __ro_after_init;
 
-static char *get_dname(struct dentry *dentry)
-{
-	const char *dname;
-	char *name;
-	int len = dentry->d_name.len;
-
-	dname = dentry->d_name.name;
-	name = kmalloc(len + 1, GFP_KERNEL);
-	if (!name)
-		return NULL;
-	memcpy(name, dname, len);
-	name[len] = 0;
-	return name;
-}
-
-static int tracefs_syscall_mkdir(struct mnt_idmap *idmap,
-				 struct inode *inode, struct dentry *dentry,
-				 umode_t mode)
-{
-	struct tracefs_inode *ti;
-	char *name;
-	int ret;
-
-	name = get_dname(dentry);
-	if (!name)
-		return -ENOMEM;
-
-	/*
-	 * This is a new directory that does not take the default of
-	 * the rootfs. It becomes the default permissions for all the
-	 * files and directories underneath it.
-	 */
-	ti = get_tracefs(inode);
-	ti->flags |= TRACEFS_INSTANCE_INODE;
-	ti->private = inode;
-
-	/*
-	 * The mkdir call can call the generic functions that create
-	 * the files within the tracefs system. It is up to the individual
-	 * mkdir routine to handle races.
-	 */
-	inode_unlock(inode);
-	ret = tracefs_ops.mkdir(name);
-	inode_lock(inode);
-
-	kfree(name);
-
-	return ret;
-}
-
-static int tracefs_syscall_rmdir(struct inode *inode, struct dentry *dentry)
-{
-	char *name;
-	int ret;
-
-	name = get_dname(dentry);
-	if (!name)
-		return -ENOMEM;
-
-	/*
-	 * The rmdir call can call the generic functions that create
-	 * the files within the tracefs system. It is up to the individual
-	 * rmdir routine to handle races.
-	 * This time we need to unlock not only the parent (inode) but
-	 * also the directory that is being deleted.
-	 */
-	inode_unlock(inode);
-	inode_unlock(d_inode(dentry));
-
-	ret = tracefs_ops.rmdir(name);
-
-	inode_lock_nested(inode, I_MUTEX_PARENT);
-	inode_lock(d_inode(dentry));
-
-	kfree(name);
-
-	return ret;
-}
-
-static void set_tracefs_inode_owner(struct inode *inode)
-{
-	struct tracefs_inode *ti = get_tracefs(inode);
-	struct inode *root_inode = ti->private;
-	kuid_t uid;
-	kgid_t gid;
-
-	uid = root_inode->i_uid;
-	gid = root_inode->i_gid;
-
-	/*
-	 * If the root is not the mount point, then check the root's
-	 * permissions. If it was never set, then default to the
-	 * mount point.
-	 */
-	if (root_inode != d_inode(root_inode->i_sb->s_root)) {
-		struct tracefs_inode *rti;
-
-		rti = get_tracefs(root_inode);
-		root_inode = d_inode(root_inode->i_sb->s_root);
-
-		if (!(rti->flags & TRACEFS_UID_PERM_SET))
-			uid = root_inode->i_uid;
-
-		if (!(rti->flags & TRACEFS_GID_PERM_SET))
-			gid = root_inode->i_gid;
-	}
-
-	/*
-	 * If this inode has never been referenced, then update
-	 * the permissions to the superblock.
-	 */
-	if (!(ti->flags & TRACEFS_UID_PERM_SET))
-		inode->i_uid = uid;
-
-	if (!(ti->flags & TRACEFS_GID_PERM_SET))
-		inode->i_gid = gid;
-}
-
-static int tracefs_permission(struct mnt_idmap *idmap,
-			      struct inode *inode, int mask)
-{
-	set_tracefs_inode_owner(inode);
-	return generic_permission(idmap, inode, mask);
-}
-
-static int tracefs_getattr(struct mnt_idmap *idmap,
-			   const struct path *path, struct kstat *stat,
-			   u32 request_mask, unsigned int flags)
-{
-	struct inode *inode = d_backing_inode(path->dentry);
-
-	set_tracefs_inode_owner(inode);
-	generic_fillattr(idmap, request_mask, inode, stat);
-	return 0;
-}
-
-static int tracefs_setattr(struct mnt_idmap *idmap, struct dentry *dentry,
-			   struct iattr *attr)
-{
-	unsigned int ia_valid = attr->ia_valid;
-	struct inode *inode = d_inode(dentry);
-	struct tracefs_inode *ti = get_tracefs(inode);
-
-	if (ia_valid & ATTR_UID)
-		ti->flags |= TRACEFS_UID_PERM_SET;
-
-	if (ia_valid & ATTR_GID)
-		ti->flags |= TRACEFS_GID_PERM_SET;
-
-	return simple_setattr(idmap, dentry, attr);
-}
-
-static const struct inode_operations tracefs_instance_dir_inode_operations = {
-	.lookup		= simple_lookup,
-	.mkdir		= tracefs_syscall_mkdir,
-	.rmdir		= tracefs_syscall_rmdir,
-	.permission	= tracefs_permission,
-	.getattr	= tracefs_getattr,
-	.setattr	= tracefs_setattr,
-};
-
-static const struct inode_operations tracefs_dir_inode_operations = {
-	.lookup		= simple_lookup,
-	.permission	= tracefs_permission,
-	.getattr	= tracefs_getattr,
-	.setattr	= tracefs_setattr,
-};
-
-static const struct inode_operations tracefs_file_inode_operations = {
-	.permission	= tracefs_permission,
-	.getattr	= tracefs_getattr,
-	.setattr	= tracefs_setattr,
-};
-
 struct inode *tracefs_get_inode(struct super_block *sb)
 {
 	struct inode *inode = new_inode(sb);
@@ -286,6 +91,14 @@ struct tracefs_fs_info {
 	unsigned int opts;
 };
 
+/* Why do we have global _and_ stuffed into tracefs_context? */
+static struct tracefs_fs_info global_info = {
+	.mode	= TRACEFS_DEFAULT_MODE,
+	.uid	= GLOBAL_ROOT_UID,
+	.gid	= GLOBAL_ROOT_GID,
+	.opts	= 0,
+};
+
 enum {
 	Opt_uid,
 	Opt_gid,
@@ -299,10 +112,24 @@ static const struct fs_parameter_spec tracefs_param_specs[] = {
 	{}
 };
 
+struct tracefs_context {
+	struct kernfs_fs_context kfc;
+ 	struct tracefs_fs_info fs_info;
+};
+
+static inline struct tracefs_context *trace_fc2context(struct fs_context *fc)
+{
+	struct kernfs_fs_context *kfc = fc->fs_private;
+
+	return container_of(kfc, struct tracefs_context, kfc);
+}
+
 static int tracefs_parse_param(struct fs_context *fc, struct fs_parameter *param)
 {
-	struct tracefs_fs_info *opts = fc->s_fs_info;
+	struct tracefs_context *ctx = trace_fc2context(fc);
+	struct tracefs_fs_info *info = &ctx->fs_info;
 	struct fs_parse_result result;
+
 	int opt;
 
 	opt = fs_parse(fc, tracefs_param_specs, param, &result);
@@ -311,13 +138,13 @@ static int tracefs_parse_param(struct fs_context *fc, struct fs_parameter *param
 
 	switch (opt) {
 	case Opt_uid:
-		opts->uid = result.uid;
+		info->uid = result.uid;
 		break;
 	case Opt_gid:
-		opts->gid = result.gid;
+		info->gid = result.gid;
 		break;
 	case Opt_mode:
-		opts->mode = result.uint_32 & S_IALLUGO;
+		info->mode = result.uint_32 & S_IALLUGO;
 		break;
 	/*
 	 * We might like to report bad mount options here;
@@ -325,51 +152,55 @@ static int tracefs_parse_param(struct fs_context *fc, struct fs_parameter *param
 	 */
 	}
 
-	opts->opts |= BIT(opt);
+	info->opts |= BIT(opt);
 
 	return 0;
 }
 
 static int tracefs_apply_options(struct super_block *sb, bool remount)
 {
-	struct tracefs_fs_info *fsi = sb->s_fs_info;
 	struct inode *inode = d_inode(sb->s_root);
 	struct tracefs_inode *ti;
 	bool update_uid, update_gid;
 	umode_t tmp_mode;
 
+	kuid_t kuid = global_info.uid;
+	kgid_t kgid = global_info.gid;
+	umode_t mode = global_info.mode;
+	unsigned int opts = global_info.opts;
+
 	/*
 	 * On remount, only reset mode/uid/gid if they were provided as mount
 	 * options.
 	 */
 
-	if (!remount || fsi->opts & BIT(Opt_mode)) {
+	if (!remount || opts & BIT(Opt_mode)) {
 		tmp_mode = READ_ONCE(inode->i_mode) & ~S_IALLUGO;
-		tmp_mode |= fsi->mode;
+		tmp_mode |= mode;
 		WRITE_ONCE(inode->i_mode, tmp_mode);
 	}
 
-	if (!remount || fsi->opts & BIT(Opt_uid))
-		inode->i_uid = fsi->uid;
+	if (!remount || opts & BIT(Opt_uid))
+		inode->i_uid = kuid;
 
-	if (!remount || fsi->opts & BIT(Opt_gid))
-		inode->i_gid = fsi->gid;
+	if (!remount || opts & BIT(Opt_gid))
+		inode->i_gid = kgid;
 
-	if (remount && (fsi->opts & BIT(Opt_uid) || fsi->opts & BIT(Opt_gid))) {
+	if (remount && (opts & BIT(Opt_uid) || opts & BIT(Opt_gid))) {
 
-		update_uid = fsi->opts & BIT(Opt_uid);
-		update_gid = fsi->opts & BIT(Opt_gid);
+		update_uid = opts & BIT(Opt_uid);
+		update_gid = opts & BIT(Opt_gid);
 
 		rcu_read_lock();
 		list_for_each_entry_rcu(ti, &tracefs_inodes, list) {
 			if (update_uid) {
 				ti->flags &= ~TRACEFS_UID_PERM_SET;
-				ti->vfs_inode.i_uid = fsi->uid;
+				ti->vfs_inode.i_uid = kuid;
 			}
 
 			if (update_gid) {
 				ti->flags &= ~TRACEFS_GID_PERM_SET;
-				ti->vfs_inode.i_gid = fsi->gid;
+				ti->vfs_inode.i_gid = kgid;
 			}
 
 			/*
@@ -386,6 +217,7 @@ static int tracefs_apply_options(struct super_block *sb, bool remount)
 	return 0;
 }
 
+/* TODO: Christian had most of this function nuked */
 static int tracefs_reconfigure(struct fs_context *fc)
 {
 	struct super_block *sb = fc->root->d_sb;
@@ -395,6 +227,7 @@ static int tracefs_reconfigure(struct fs_context *fc)
 	if (!new_opts)
 		return 0;
 
+	/* TODO: Do we need sync_filesystem with kernfs? */
 	sync_filesystem(sb);
 	/* structure copy of new mount options to sb */
 	*sb_opts = *new_opts;
@@ -402,46 +235,53 @@ static int tracefs_reconfigure(struct fs_context *fc)
 	return tracefs_apply_options(sb, true);
 }
 
-static int tracefs_show_options(struct seq_file *m, struct dentry *root)
+static int tracefs_show_options(struct seq_file *seq, struct kernfs_root *kf_root)
 {
-	struct tracefs_fs_info *fsi = root->d_sb->s_fs_info;
+	kuid_t kuid = global_info.uid;
+	kgid_t kgid = global_info.gid;
+	umode_t mode = global_info.mode;
 
-	if (!uid_eq(fsi->uid, GLOBAL_ROOT_UID))
-		seq_printf(m, ",uid=%u",
-			   from_kuid_munged(&init_user_ns, fsi->uid));
-	if (!gid_eq(fsi->gid, GLOBAL_ROOT_GID))
-		seq_printf(m, ",gid=%u",
-			   from_kgid_munged(&init_user_ns, fsi->gid));
-	if (fsi->mode != TRACEFS_DEFAULT_MODE)
-		seq_printf(m, ",mode=%o", fsi->mode);
+	if (!uid_eq(kuid, GLOBAL_ROOT_UID))
+		seq_printf(seq, ",uid=%u", from_kuid_munged(&init_user_ns, kuid));
+	if (!gid_eq(kgid, GLOBAL_ROOT_GID))
+		seq_printf(seq, ",gid=%u", from_kgid_munged(&init_user_ns, kgid));
+	if (mode != TRACEFS_DEFAULT_MODE)
+		seq_printf(seq, ",mode=%o", mode);
 
 	return 0;
-}
+ }
 
-static int tracefs_drop_inode(struct inode *inode)
-{
-	struct tracefs_inode *ti = get_tracefs(inode);
+static int tracefs_mkdir(struct kernfs_node *parent_kn, const char *name, umode_t mode)
+ {
+	int ret;
+	struct kernfs_node *kn;
 
-	/*
-	 * This inode is being freed and cannot be used for
-	 * eventfs. Clear the flag so that it doesn't call into
-	 * eventfs during the remount flag updates. The eventfs_inode
-	 * gets freed after an RCU cycle, so the content will still
-	 * be safe if the iteration is going on now.
-	 */
-	ti->flags &= ~TRACEFS_EVENT_INODE;
+	if (parent_kn != trace_instance_dir)
+		return -EPERM;
 
-	return 1;
+	kn = tracefs_create_dir(name, parent_kn);
+	if (IS_ERR(kn))
+		return PTR_ERR(kn);
+
+	ret = tracefs_ops.mkdir(name);
+	if (ret)
+		kernfs_remove(kn);
+	return ret;
 }
 
-static const struct super_operations tracefs_super_operations = {
-	.alloc_inode    = tracefs_alloc_inode,
-	.free_inode     = tracefs_free_inode,
-	.destroy_inode  = tracefs_destroy_inode,
-	.drop_inode     = tracefs_drop_inode,
-	.statfs		= simple_statfs,
-	.show_options	= tracefs_show_options,
-};
+static int tracefs_rmdir(struct kernfs_node *kn)
+ {
+	int ret;
+
+	if (kn != trace_instance_dir)
+		return -EPERM;
+
+ 	ret = tracefs_ops.rmdir(kn->name);
+	if (!ret)
+		kernfs_remove(kn);
+
+	return ret;
+}
 
 /*
  * It would be cleaner if eventfs had its own dentry ops.
@@ -464,39 +304,34 @@ static int tracefs_d_revalidate(struct dentry *dentry, unsigned int flags)
 	return !(ei && ei->is_freed);
 }
 
+/* necessary for eventsfs */
 static const struct dentry_operations tracefs_dentry_operations = {
 	.d_revalidate = tracefs_d_revalidate,
 	.d_release = tracefs_d_release,
 };
 
-static int tracefs_fill_super(struct super_block *sb, struct fs_context *fc)
-{
-	static const struct tree_descr trace_files[] = {{""}};
-	int err;
-
-	err = simple_fill_super(sb, TRACEFS_MAGIC, trace_files);
-	if (err)
-		return err;
-
-	sb->s_op = &tracefs_super_operations;
-	sb->s_d_op = &tracefs_dentry_operations;
-
-	return 0;
-}
+static struct kernfs_syscall_ops tracefs_kf_syscall_ops = {
+	.show_options		= tracefs_show_options,
+	.mkdir			= tracefs_mkdir,
+	.rmdir			= tracefs_rmdir,
+};
 
 static int tracefs_get_tree(struct fs_context *fc)
 {
-	int err = get_tree_single(fc, tracefs_fill_super);
+	int ret;
 
-	if (err)
-		return err;
+	ret = kernfs_get_tree(fc);
+	if (!ret)
+		tracefs_apply_options(fc->root->d_sb, false);
 
-	return tracefs_reconfigure(fc);
+	return ret;
 }
 
 static void tracefs_free_fc(struct fs_context *fc)
 {
-	kfree(fc->s_fs_info);
+	struct tracefs_context *ctx = trace_fc2context(fc);
+	kernfs_free_fs_context(fc);
+	kfree(ctx);
 }
 
 static const struct fs_context_operations tracefs_context_ops = {
@@ -521,12 +356,12 @@ static int tracefs_init_fs_context(struct fs_context *fc)
 	return 0;
 }
 
-static struct file_system_type trace_fs_type = {
-	.owner =	THIS_MODULE,
-	.name =		"tracefs",
-	.init_fs_context = tracefs_init_fs_context,
-	.parameters	= tracefs_param_specs,
-	.kill_sb =	kill_litter_super,
+static struct file_system_type tracefs_type = {
+	.owner			= THIS_MODULE,
+	.name 			="tracefs",
+	.init_fs_context 	= tracefs_init_fs_context,
+	.parameters		= tracefs_param_specs,
+	.kill_sb		= kill_litter_super, /* TODO do we need kill_sb? */
 };
 MODULE_ALIAS_FS("tracefs");
 
@@ -537,7 +372,7 @@ struct dentry *tracefs_start_creating(const char *name, struct dentry *parent)
 
 	pr_debug("tracefs: creating file '%s'\n",name);
 
-	error = simple_pin_fs(&trace_fs_type, &tracefs_mount,
+	error = simple_pin_fs(&tracefs_type, &tracefs_mount,
 			      &tracefs_mount_count);
 	if (error)
 		return ERR_PTR(error);
@@ -620,7 +455,7 @@ static struct inode *instance_inode(struct dentry *parent, struct inode *inode)
  * to create a directory, the tracefs_create_dir() function is
  * recommended to be used instead.)
  *
- * This function will return a pointer to a dentry if it succeeds.  This
+ * This function will return a pointer to a kernfs_node if it succeeds.  This
  * pointer must be passed to the tracefs_remove() function when the file is
  * to be removed (no automatic cleanup happens if your module is unloaded,
  * you are responsible here.)  If an error occurs, %NULL will be returned.
@@ -628,74 +463,27 @@ static struct inode *instance_inode(struct dentry *parent, struct inode *inode)
  * If tracefs is not enabled in the kernel, the value -%ENODEV will be
  * returned.
  */
-struct dentry *tracefs_create_file(const char *name, umode_t mode,
-				   struct dentry *parent, void *data,
-				   const struct file_operations *fops)
+struct kernfs_node *tracefs_create_file(const char *name, umode_t mode,
+					struct kernfs_node *parent, void *data,
+					const struct kernfs_ops *ops)
 {
-	struct tracefs_inode *ti;
-	struct dentry *dentry;
-	struct inode *inode;
-
 	if (security_locked_down(LOCKDOWN_TRACEFS))
 		return NULL;
 
 	if (!(mode & S_IFMT))
 		mode |= S_IFREG;
 	BUG_ON(!S_ISREG(mode));
-	dentry = tracefs_start_creating(name, parent);
 
-	if (IS_ERR(dentry))
-		return NULL;
+	/* TODO What is this? */
+	// inode->i_op = &tracefs_file_inode_operations;
 
-	inode = tracefs_get_inode(dentry->d_sb);
-	if (unlikely(!inode))
-		return tracefs_failed_creating(dentry);
-
-	ti = get_tracefs(inode);
-	ti->private = instance_inode(parent, inode);
-
-	inode->i_mode = mode;
-	inode->i_op = &tracefs_file_inode_operations;
-	inode->i_fop = fops ? fops : &tracefs_file_operations;
-	inode->i_private = data;
-	inode->i_uid = d_inode(dentry->d_parent)->i_uid;
-	inode->i_gid = d_inode(dentry->d_parent)->i_gid;
-	d_instantiate(dentry, inode);
-	fsnotify_create(d_inode(dentry->d_parent), dentry);
-	return tracefs_end_creating(dentry);
+	return __kernfs_create_file(parent ?: tracefs_kfs_root_node, name, mode,
+				    kernfs_node_owner(parent),
+				    kernfs_node_group(parent), PAGE_SIZE,
+				    ops ? : &tracefs_default_file_kfops, data, NULL,
+				    NULL);
 }
 
-static struct dentry *__create_dir(const char *name, struct dentry *parent,
-				   const struct inode_operations *ops)
-{
-	struct tracefs_inode *ti;
-	struct dentry *dentry = tracefs_start_creating(name, parent);
-	struct inode *inode;
-
-	if (IS_ERR(dentry))
-		return NULL;
-
-	inode = tracefs_get_inode(dentry->d_sb);
-	if (unlikely(!inode))
-		return tracefs_failed_creating(dentry);
-
-	/* Do not set bits for OTH */
-	inode->i_mode = S_IFDIR | S_IRWXU | S_IRUSR| S_IRGRP | S_IXUSR | S_IXGRP;
-	inode->i_op = ops;
-	inode->i_fop = &simple_dir_operations;
-	inode->i_uid = d_inode(dentry->d_parent)->i_uid;
-	inode->i_gid = d_inode(dentry->d_parent)->i_gid;
-
-	ti = get_tracefs(inode);
-	ti->private = instance_inode(parent, inode);
-
-	/* directory inodes start off with i_nlink == 2 (for "." entry) */
-	inc_nlink(inode);
-	d_instantiate(dentry, inode);
-	inc_nlink(d_inode(dentry->d_parent));
-	fsnotify_mkdir(d_inode(dentry->d_parent), dentry);
-	return tracefs_end_creating(dentry);
-}
 
 /**
  * tracefs_create_dir - create a directory in the tracefs filesystem
@@ -714,18 +502,21 @@ static struct dentry *__create_dir(const char *name, struct dentry *parent,
  * If tracing is not enabled in the kernel, the value -%ENODEV will be
  * returned.
  */
-struct dentry *tracefs_create_dir(const char *name, struct dentry *parent)
-{
-	if (security_locked_down(LOCKDOWN_TRACEFS))
-		return NULL;
+struct kernfs_node *tracefs_create_dir(const char *name,
+				       struct kernfs_node *parent)
+ {
+ 	if (security_locked_down(LOCKDOWN_TRACEFS))
+		return ERR_PTR(-EINVAL);
 
-	return __create_dir(name, parent, &tracefs_dir_inode_operations);
+	return kernfs_create_dir_ns(parent ?: tracefs_kfs_root_node, name,
+				  S_IFDIR | S_IRWXU | S_IRUSR | S_IRGRP |
+				  S_IXUSR | S_IXGRP,
+				  kernfs_node_owner(parent),
+				  kernfs_node_group(parent), NULL, NULL);
 }
 
 /**
  * tracefs_create_instance_dir - create the tracing instances directory
- * @name: The name of the instances directory to create
- * @parent: The parent directory that the instances directory will exist
  * @mkdir: The function to call when a mkdir is performed.
  * @rmdir: The function to call when a rmdir is performed.
  *
@@ -739,48 +530,38 @@ struct dentry *tracefs_create_dir(const char *name, struct dentry *parent)
  *
  * Returns the dentry of the instances directory.
  */
-__init struct dentry *tracefs_create_instance_dir(const char *name,
-					  struct dentry *parent,
-					  int (*mkdir)(const char *name),
-					  int (*rmdir)(const char *name))
+__init struct kernfs_node *tracefs_create_instance_dir(int (*mkdir)(const char *name),
+						       int (*rmdir)(const char *name))
 {
-	struct dentry *dentry;
-
-	/* Only allow one instance of the instances directory. */
-	if (WARN_ON(tracefs_ops.mkdir || tracefs_ops.rmdir))
-		return NULL;
-
-	dentry = __create_dir(name, parent, &tracefs_instance_dir_inode_operations);
-	if (!dentry)
-		return NULL;
+	struct kernfs_node *kn;
 
-	tracefs_ops.mkdir = mkdir;
-	tracefs_ops.rmdir = rmdir;
+ 	/* Only allow one instance of the instances directory. */
+ 	if (WARN_ON(tracefs_ops.mkdir || tracefs_ops.rmdir))
+		return ERR_PTR(-EINVAL);
 
-	return dentry;
-}
+	kn = tracefs_create_dir("instances", tracefs_kfs_root_node);
+	if (IS_ERR(kn))
+		return kn;
 
-static void remove_one(struct dentry *victim)
-{
-	simple_release_fs(&tracefs_mount, &tracefs_mount_count);
+ 	tracefs_ops.mkdir = mkdir;
+ 	tracefs_ops.rmdir = rmdir;
+	return kn;
 }
 
 /**
  * tracefs_remove - recursively removes a directory
- * @dentry: a pointer to a the dentry of the directory to be removed.
+ * @kn: a pointer to a the kernfs_node of the directory to be removed.
  *
  * This function recursively removes a directory tree in tracefs that
  * was previously created with a call to another tracefs function
  * (like tracefs_create_file() or variants thereof.)
  */
-void tracefs_remove(struct dentry *dentry)
+void tracefs_remove(struct kernfs_node *kn)
 {
-	if (IS_ERR_OR_NULL(dentry))
+	if (IS_ERR_OR_NULL(kn))
 		return;
 
-	simple_pin_fs(&trace_fs_type, &tracefs_mount, &tracefs_mount_count);
-	simple_recursive_removal(dentry, remove_one);
-	simple_release_fs(&tracefs_mount, &tracefs_mount_count);
+	kernfs_remove(kn);
 }
 
 /**
@@ -791,36 +572,30 @@ bool tracefs_initialized(void)
 	return tracefs_registered;
 }
 
-static void init_once(void *foo)
-{
-	struct tracefs_inode *ti = (struct tracefs_inode *) foo;
-
-	/* inode_init_once() calls memset() on the vfs_inode portion */
-	inode_init_once(&ti->vfs_inode);
-
-	/* Zero out the rest */
-	memset_after(ti, 0, vfs_inode);
-}
-
 static int __init tracefs_init(void)
 {
 	int retval;
+	struct kernfs_root *kfs_root;
 
-	tracefs_inode_cachep = kmem_cache_create("tracefs_inode_cache",
-						 sizeof(struct tracefs_inode),
-						 0, (SLAB_RECLAIM_ACCOUNT|
-						     SLAB_ACCOUNT),
-						 init_once);
-	if (!tracefs_inode_cachep)
-		return -ENOMEM;
+	kfs_root = kernfs_create_root(&tracefs_kf_syscall_ops,
+				      KERNFS_ROOT_CREATE_DEACTIVATED, NULL);
+	if (IS_ERR(kfs_root))
+                return PTR_ERR(kfs_root);
 
 	retval = sysfs_create_mount_point(kernel_kobj, "tracing");
-	if (retval)
+	if (retval) {
+		kernfs_destroy_root(kfs_root);
 		return -EINVAL;
+	}
 
-	retval = register_filesystem(&trace_fs_type);
+	retval = register_filesystem(&tracefs_type);
 	if (!retval)
 		tracefs_registered = true;
+	else
+		kernfs_destroy_root(kfs_root);
+
+	tracefs_root = kfs_root;
+	tracefs_kfs_root_node = kernfs_root_to_node(kfs_root);
 
 	return retval;
 }
diff --git a/fs/tracefs/internal.h b/fs/tracefs/internal.h
index d83c2a25f288..8679ebcff6c2 100644
--- a/fs/tracefs/internal.h
+++ b/fs/tracefs/internal.h
@@ -2,6 +2,9 @@
 #ifndef _TRACEFS_INTERNAL_H
 #define _TRACEFS_INTERNAL_H
 
+#include <linux/kernfs.h>
+#include <linux/module.h>
+
 enum {
 	TRACEFS_EVENT_INODE		= BIT(1),
 	TRACEFS_GID_PERM_SET		= BIT(2),
diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index 02ee62e057a8..3dfd640389bb 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -246,6 +246,9 @@ struct kernfs_syscall_ops {
 			 struct kernfs_root *root);
 };
 
+kuid_t kernfs_node_owner(struct kernfs_node *kn);
+kgid_t kernfs_node_group(struct kernfs_node *kn);
+
 struct kernfs_node *kernfs_root_to_node(struct kernfs_root *root);
 
 struct kernfs_open_file {
diff --git a/include/linux/tracefs.h b/include/linux/tracefs.h
index d03f74658716..62f28250a2dc 100644
--- a/include/linux/tracefs.h
+++ b/include/linux/tracefs.h
@@ -13,6 +13,7 @@
 #define _TRACEFS_H_
 
 #include <linux/fs.h>
+#include <linux/kernfs.h>
 #include <linux/seq_file.h>
 
 #include <linux/types.h>
@@ -22,6 +23,7 @@ struct file_operations;
 #ifdef CONFIG_TRACING
 
 struct eventfs_file;
+extern struct kernfs_node *trace_instance_dir;
 
 /**
  * eventfs_callback - A callback function to create dynamic files in eventfs
@@ -90,17 +92,16 @@ struct eventfs_inode *eventfs_create_dir(const char *name, struct eventfs_inode
 void eventfs_remove_events_dir(struct eventfs_inode *ei);
 void eventfs_remove_dir(struct eventfs_inode *ei);
 
-struct dentry *tracefs_create_file(const char *name, umode_t mode,
-				   struct dentry *parent, void *data,
-				   const struct file_operations *fops);
+struct kernfs_node *tracefs_create_file(const char *name, umode_t mode,
+					struct kernfs_node *parent, void *data,
+					const struct kernfs_ops *ops);
 
-struct dentry *tracefs_create_dir(const char *name, struct dentry *parent);
+struct kernfs_node *tracefs_create_dir(const char *name, struct kernfs_node *parent);
 
-void tracefs_remove(struct dentry *dentry);
+void tracefs_remove(struct kernfs_node *kn);
 
-struct dentry *tracefs_create_instance_dir(const char *name, struct dentry *parent,
-					   int (*mkdir)(const char *name),
-					   int (*rmdir)(const char *name));
+struct kernfs_node *tracefs_create_instance_dir(int (*mkdir)(const char *name),
+						int (*rmdir)(const char *name));
 
 bool tracefs_initialized(void);
 
diff --git a/kernel/trace/trace.c b/kernel/trace/trace.c
index 1496a5ac33ae..61abf7e0eff2 100644
--- a/kernel/trace/trace.c
+++ b/kernel/trace/trace.c
@@ -1826,69 +1826,16 @@ static ssize_t trace_seq_to_buffer(struct trace_seq *s, void *buf, size_t cnt)
 unsigned long __read_mostly	tracing_thresh;
 
 #ifdef CONFIG_TRACER_MAX_TRACE
-static const struct file_operations tracing_max_lat_fops;
+static const struct kernfs_ops tracing_max_lat_fops;
 
 #ifdef LATENCY_FS_NOTIFY
 
-static struct workqueue_struct *fsnotify_wq;
-
-static void latency_fsnotify_workfn(struct work_struct *work)
-{
-	struct trace_array *tr = container_of(work, struct trace_array,
-					      fsnotify_work);
-	fsnotify_inode(tr->d_max_latency->d_inode, FS_MODIFY);
-}
-
-static void latency_fsnotify_workfn_irq(struct irq_work *iwork)
-{
-	struct trace_array *tr = container_of(iwork, struct trace_array,
-					      fsnotify_irqwork);
-	queue_work(fsnotify_wq, &tr->fsnotify_work);
-}
-
-static void trace_create_maxlat_file(struct trace_array *tr,
-				     struct dentry *d_tracer)
-{
-	INIT_WORK(&tr->fsnotify_work, latency_fsnotify_workfn);
-	init_irq_work(&tr->fsnotify_irqwork, latency_fsnotify_workfn_irq);
-	tr->d_max_latency = trace_create_file("tracing_max_latency",
-					      TRACE_MODE_WRITE,
-					      d_tracer, tr,
-					      &tracing_max_lat_fops);
-}
-
-__init static int latency_fsnotify_init(void)
-{
-	fsnotify_wq = alloc_workqueue("tr_max_lat_wq",
-				      WQ_UNBOUND | WQ_HIGHPRI, 0);
-	if (!fsnotify_wq) {
-		pr_err("Unable to allocate tr_max_lat_wq\n");
-		return -ENOMEM;
-	}
-	return 0;
-}
-
-late_initcall_sync(latency_fsnotify_init);
-
 void latency_fsnotify(struct trace_array *tr)
 {
-	if (!fsnotify_wq)
-		return;
-	/*
-	 * We cannot call queue_work(&tr->fsnotify_work) from here because it's
-	 * possible that we are called from __schedule() or do_idle(), which
-	 * could cause a deadlock.
-	 */
-	irq_work_queue(&tr->fsnotify_irqwork);
+	kernfs_notify(tr->d_max_latency);
 }
 
-#else /* !LATENCY_FS_NOTIFY */
-
-#define trace_create_maxlat_file(tr, d_tracer)				\
-	trace_create_file("tracing_max_latency", TRACE_MODE_WRITE,	\
-			  d_tracer, tr, &tracing_max_lat_fops)
-
-#endif
+#endif /* !LATENCY_FS_NOTIFY */
 
 /*
  * Copy the new maximum trace into the separate maximum-trace
@@ -4512,12 +4459,12 @@ static int s_show(struct seq_file *m, void *v)
 
 /*
  * Should be used after trace_array_get(), trace_types_lock
- * ensures that i_cdev was already initialized.
+ * ensures that kernfs_node->priv was already initialized.
  */
-static inline int tracing_get_cpu(struct inode *inode)
+static inline int tracing_get_cpu(struct kernfs_node *kfn)
 {
-	if (inode->i_cdev) /* See trace_create_cpu_file() */
-		return (long)inode->i_cdev - 1;
+	if (kfn->priv) /* See trace_create_cpu_file() */
+		return (long)kfn->priv - 1;
 	return RING_BUFFER_ALL_CPUS;
 }
 
@@ -4548,16 +4495,16 @@ static void free_trace_iter_content(struct trace_iterator *iter)
 }
 
 static struct trace_iterator *
-__tracing_open(struct inode *inode, struct file *file, bool snapshot)
+__tracing_open(struct kernfs_open_file *of, bool snapshot)
 {
-	struct trace_array *tr = inode->i_private;
+	struct trace_array *tr = of->priv;
 	struct trace_iterator *iter;
 	int cpu;
 
 	if (tracing_disabled)
 		return ERR_PTR(-ENODEV);
 
-	iter = __seq_open_private(file, &tracer_seq_ops, sizeof(*iter));
+	iter = __seq_open_private(of->file, &tracer_seq_ops, sizeof(*iter));
 	if (!iter)
 		return ERR_PTR(-ENOMEM);
 
@@ -4605,7 +4552,7 @@ __tracing_open(struct inode *inode, struct file *file, bool snapshot)
 		iter->array_buffer = &tr->array_buffer;
 	iter->snapshot = snapshot;
 	iter->pos = -1;
-	iter->cpu_file = tracing_get_cpu(inode);
+	iter->cpu_file = tracing_get_cpu(of->kn);
 	mutex_init(&iter->mutex);
 
 	/* Notify the tracer early; before we stop tracing. */
@@ -4660,7 +4607,7 @@ __tracing_open(struct inode *inode, struct file *file, bool snapshot)
 	return ERR_PTR(-ENOMEM);
 }
 
-int tracing_open_generic(struct inode *inode, struct file *filp)
+int tracing_open_generic(struct kernfs_open_file *of)
 {
 	int ret;
 
@@ -4668,7 +4615,8 @@ int tracing_open_generic(struct inode *inode, struct file *filp)
 	if (ret)
 		return ret;
 
-	filp->private_data = inode->i_private;
+	of->priv = of->kn->priv;
+
 	return 0;
 }
 
@@ -4681,16 +4629,16 @@ bool tracing_is_disabled(void)
  * Open and update trace_array ref count.
  * Must have the current trace_array passed to it.
  */
-int tracing_open_generic_tr(struct inode *inode, struct file *filp)
+int tracing_open_generic_tr(struct kernfs_open_file *of)
 {
-	struct trace_array *tr = inode->i_private;
+	struct trace_array *tr = of->kn->priv;
 	int ret;
 
 	ret = tracing_check_open_get_tr(tr);
 	if (ret)
 		return ret;
 
-	filp->private_data = inode->i_private;
+	of->priv = of->kn->priv;
 
 	return 0;
 }
@@ -4699,9 +4647,9 @@ int tracing_open_generic_tr(struct inode *inode, struct file *filp)
  * The private pointer of the inode is the trace_event_file.
  * Update the tr ref count associated to it.
  */
-int tracing_open_file_tr(struct inode *inode, struct file *filp)
+int tracing_open_file_tr(struct kernfs_open_file *of)
 {
-	struct trace_event_file *file = inode->i_private;
+	struct trace_event_file *file = of->priv;
 	int ret;
 
 	ret = tracing_check_open_get_tr(file->tr);
@@ -4722,31 +4670,22 @@ int tracing_open_file_tr(struct inode *inode, struct file *filp)
 	if (ret)
 		return ret;
 
-	filp->private_data = inode->i_private;
-
 	return 0;
 }
 
-int tracing_release_file_tr(struct inode *inode, struct file *filp)
+void tracing_release_file_tr(struct kernfs_open_file *of)
 {
-	struct trace_event_file *file = inode->i_private;
+	struct trace_event_file *file = of->priv;
 
 	trace_array_put(file->tr);
 	event_file_put(file);
-
-	return 0;
 }
 
-int tracing_single_release_file_tr(struct inode *inode, struct file *filp)
+static int tracing_mark_open(struct kernfs_open_file *of)
 {
-	tracing_release_file_tr(inode, filp);
-	return single_release(inode, filp);
-}
-
-static int tracing_mark_open(struct inode *inode, struct file *filp)
-{
-	stream_open(inode, filp);
-	return tracing_open_generic_tr(inode, filp);
+	/* TODO What does stream_open do? */
+	/* stream_open(inode, filp); */
+	return tracing_open_generic_tr(of);
 }
 
 static int tracing_release(struct inode *inode, struct file *file)
@@ -4787,26 +4726,16 @@ static int tracing_release(struct inode *inode, struct file *file)
 	return 0;
 }
 
-int tracing_release_generic_tr(struct inode *inode, struct file *file)
+void tracing_release_generic_tr(struct kernfs_open_file *of)
 {
-	struct trace_array *tr = inode->i_private;
+	struct trace_array *tr = of->priv;
 
 	trace_array_put(tr);
-	return 0;
 }
 
-static int tracing_single_release_tr(struct inode *inode, struct file *file)
+static int tracing_open(struct kernfs_open_file *of)
 {
-	struct trace_array *tr = inode->i_private;
-
-	trace_array_put(tr);
-
-	return single_release(inode, file);
-}
-
-static int tracing_open(struct inode *inode, struct file *file)
-{
-	struct trace_array *tr = inode->i_private;
+	struct trace_array *tr = of->priv;
 	struct trace_iterator *iter;
 	int ret;
 
@@ -4815,8 +4744,8 @@ static int tracing_open(struct inode *inode, struct file *file)
 		return ret;
 
 	/* If this file was open for write, then erase contents */
-	if ((file->f_mode & FMODE_WRITE) && (file->f_flags & O_TRUNC)) {
-		int cpu = tracing_get_cpu(inode);
+	if ((of->file->f_mode & FMODE_WRITE) && (of->file->f_flags & O_TRUNC)) {
+		int cpu = tracing_get_cpu(of->kn);
 		struct array_buffer *trace_buf = &tr->array_buffer;
 
 #ifdef CONFIG_TRACER_MAX_TRACE
@@ -4830,8 +4759,8 @@ static int tracing_open(struct inode *inode, struct file *file)
 			tracing_reset_cpu(trace_buf, cpu);
 	}
 
-	if (file->f_mode & FMODE_READ) {
-		iter = __tracing_open(inode, file, false);
+	if (of->file->f_mode & FMODE_READ) {
+		iter = __tracing_open(of, false);
 		if (IS_ERR(iter))
 			ret = PTR_ERR(iter);
 		else if (tr->trace_flags & TRACE_ITER_LATENCY_FMT)
@@ -4920,35 +4849,6 @@ static int t_show(struct seq_file *m, void *v)
 	return 0;
 }
 
-static const struct seq_operations show_traces_seq_ops = {
-	.start		= t_start,
-	.next		= t_next,
-	.stop		= t_stop,
-	.show		= t_show,
-};
-
-static int show_traces_open(struct inode *inode, struct file *file)
-{
-	struct trace_array *tr = inode->i_private;
-	struct seq_file *m;
-	int ret;
-
-	ret = tracing_check_open_get_tr(tr);
-	if (ret)
-		return ret;
-
-	ret = seq_open(file, &show_traces_seq_ops);
-	if (ret) {
-		trace_array_put(tr);
-		return ret;
-	}
-
-	m = file->private_data;
-	m->private = tr;
-
-	return 0;
-}
-
 static int tracing_seq_release(struct inode *inode, struct file *file)
 {
 	struct trace_array *tr = inode->i_private;
@@ -4976,7 +4876,8 @@ loff_t tracing_lseek(struct file *file, loff_t offset, int whence)
 	return ret;
 }
 
-static const struct file_operations tracing_fops = {
+static const struct kernfs_ops tracing_fops = {
+	/* TODO This uses tracer_seq_ops under the hood, nested in __tracing_open */
 	.open		= tracing_open,
 	.read		= seq_read,
 	.read_iter	= seq_read_iter,
@@ -4986,39 +4887,28 @@ static const struct file_operations tracing_fops = {
 	.release	= tracing_release,
 };
 
-static const struct file_operations show_traces_fops = {
-	.open		= show_traces_open,
-	.read		= seq_read,
-	.llseek		= seq_lseek,
-	.release	= tracing_seq_release,
+static const struct kernfs_ops show_traces_fops = {
+	.open		= tracing_open_generic_tr,
+	.seq_start	= t_start,
+	.seq_next	= t_next,
+	.seq_stop	= t_stop,
+	.seq_show	= t_show,
 };
 
 static ssize_t
-tracing_cpumask_read(struct file *filp, char __user *ubuf,
-		     size_t count, loff_t *ppos)
+tracing_cpumask_read(struct kernfs_open_file *of, char *buf,
+		     size_t count, loff_t ppos)
 {
-	struct trace_array *tr = file_inode(filp)->i_private;
-	char *mask_str;
+	struct trace_array *tr = of->priv;
 	int len;
 
-	len = snprintf(NULL, 0, "%*pb\n",
-		       cpumask_pr_args(tr->tracing_cpumask)) + 1;
-	mask_str = kmalloc(len, GFP_KERNEL);
-	if (!mask_str)
-		return -ENOMEM;
-
-	len = snprintf(mask_str, len, "%*pb\n",
+	len = snprintf(buf, len, "%*pb\n",
 		       cpumask_pr_args(tr->tracing_cpumask));
 	if (len >= count) {
 		count = -EINVAL;
-		goto out_err;
 	}
-	count = simple_read_from_buffer(ubuf, count, ppos, mask_str, len);
 
-out_err:
-	kfree(mask_str);
-
-	return count;
+	return len;
 }
 
 int tracing_set_cpumask(struct trace_array *tr,
@@ -5062,10 +4952,10 @@ int tracing_set_cpumask(struct trace_array *tr,
 }
 
 static ssize_t
-tracing_cpumask_write(struct file *filp, const char __user *ubuf,
-		      size_t count, loff_t *ppos)
+tracing_cpumask_write(struct kernfs_open_file *of, char *buf,
+		      size_t count, loff_t ppos)
 {
-	struct trace_array *tr = file_inode(filp)->i_private;
+	struct trace_array *tr = of->priv;
 	cpumask_var_t tracing_cpumask_new;
 	int err;
 
@@ -5075,7 +4965,7 @@ tracing_cpumask_write(struct file *filp, const char __user *ubuf,
 	if (!zalloc_cpumask_var(&tracing_cpumask_new, GFP_KERNEL))
 		return -ENOMEM;
 
-	err = cpumask_parse_user(ubuf, count, tracing_cpumask_new);
+	err = cpumask_parse_user(buf, count, tracing_cpumask_new);
 	if (err)
 		goto err_free;
 
@@ -5093,12 +4983,11 @@ tracing_cpumask_write(struct file *filp, const char __user *ubuf,
 	return err;
 }
 
-static const struct file_operations tracing_cpumask_fops = {
+static const struct kernfs_ops tracing_cpumask_fops = {
 	.open		= tracing_open_generic_tr,
 	.read		= tracing_cpumask_read,
 	.write		= tracing_cpumask_write,
 	.release	= tracing_release_generic_tr,
-	.llseek		= generic_file_llseek,
 };
 
 static int tracing_trace_options_show(struct seq_file *m, void *v)
@@ -5309,52 +5198,26 @@ static void __init apply_trace_boot_options(void)
 }
 
 static ssize_t
-tracing_trace_options_write(struct file *filp, const char __user *ubuf,
-			size_t cnt, loff_t *ppos)
+tracing_trace_options_write(struct kernfs_open_file *of, char *buf,
+			    size_t cnt, loff_t ppos)
 {
-	struct seq_file *m = filp->private_data;
+	struct seq_file *m = of->priv;
 	struct trace_array *tr = m->private;
-	char buf[64];
 	int ret;
 
 	if (cnt >= sizeof(buf))
 		return -EINVAL;
 
-	if (copy_from_user(buf, ubuf, cnt))
-		return -EFAULT;
-
-	buf[cnt] = 0;
-
 	ret = trace_set_options(tr, buf);
 	if (ret < 0)
 		return ret;
 
-	*ppos += cnt;
-
 	return cnt;
 }
 
-static int tracing_trace_options_open(struct inode *inode, struct file *file)
-{
-	struct trace_array *tr = inode->i_private;
-	int ret;
-
-	ret = tracing_check_open_get_tr(tr);
-	if (ret)
-		return ret;
-
-	ret = single_open(file, tracing_trace_options_show, inode->i_private);
-	if (ret < 0)
-		trace_array_put(tr);
-
-	return ret;
-}
-
-static const struct file_operations tracing_iter_fops = {
-	.open		= tracing_trace_options_open,
-	.read		= seq_read,
-	.llseek		= seq_lseek,
-	.release	= tracing_single_release_tr,
+static const struct kernfs_ops tracing_iter_fops = {
+	.seq_show	= tracing_trace_options_show,
+	.release	= tracing_release_generic_tr,
 	.write		= tracing_trace_options_write,
 };
 
@@ -5657,17 +5520,31 @@ static const char readme_msg[] =
 ;
 
 static ssize_t
-tracing_readme_read(struct file *filp, char __user *ubuf,
-		       size_t cnt, loff_t *ppos)
+tracing_readme_read(struct kernfs_open_file *of, char *buf,
+		    size_t count, loff_t ppos)
 {
-	return simple_read_from_buffer(ubuf, cnt, ppos,
-					readme_msg, strlen(readme_msg));
+	/*
+	 * TODO Is there a generic kernel function like simple_write_to_buffer
+	 * for non-user buffers? This is all boilerplate. Maybe write one in
+	 * kernfs?
+	 */
+	size_t available = strlen(readme_msg);
+	size_t remaining = available - ppos;
+
+	if (ppos >= available || !count)
+		return 0;
+
+	if (count > remaining)
+		count = remaining;
+
+	memcpy(buf, readme_msg + ppos, count);
+
+	return count;
 }
 
-static const struct file_operations tracing_readme_fops = {
+static const struct kernfs_ops tracing_readme_fops = {
 	.open		= tracing_open_generic,
 	.read		= tracing_readme_read,
-	.llseek		= generic_file_llseek,
 };
 
 #ifdef CONFIG_TRACE_EVAL_MAP_FILE
@@ -5738,29 +5615,12 @@ static int eval_map_show(struct seq_file *m, void *v)
 	return 0;
 }
 
-static const struct seq_operations tracing_eval_map_seq_ops = {
-	.start		= eval_map_start,
-	.next		= eval_map_next,
-	.stop		= eval_map_stop,
-	.show		= eval_map_show,
-};
-
-static int tracing_eval_map_open(struct inode *inode, struct file *filp)
-{
-	int ret;
-
-	ret = tracing_check_open_get_tr(NULL);
-	if (ret)
-		return ret;
-
-	return seq_open(filp, &tracing_eval_map_seq_ops);
-}
-
-static const struct file_operations tracing_eval_map_fops = {
-	.open		= tracing_eval_map_open,
-	.read		= seq_read,
-	.llseek		= seq_lseek,
-	.release	= seq_release,
+static const struct kernfs_ops tracing_eval_map_fops = {
+	.open		= tracing_open_generic,
+	.seq_start	= eval_map_start,
+	.seq_next	= eval_map_next,
+	.seq_stop	= eval_map_stop,
+	.seq_show	= eval_map_show,
 };
 
 static inline union trace_eval_map_item *
@@ -5818,14 +5678,14 @@ trace_insert_eval_map_file(struct module *mod, struct trace_eval_map **start,
 	memset(map_array, 0, sizeof(*map_array));
 }
 
-static void trace_create_eval_file(struct dentry *d_tracer)
+static void trace_create_eval_file(struct kernfs_node *d_tracer)
 {
 	trace_create_file("eval_map", TRACE_MODE_READ, d_tracer,
 			  NULL, &tracing_eval_map_fops);
 }
 
 #else /* CONFIG_TRACE_EVAL_MAP_FILE */
-static inline void trace_create_eval_file(struct dentry *d_tracer) { }
+static inline void trace_create_eval_file(struct kernfs_node *d_tracer) { }
 static inline void trace_insert_eval_map_file(struct module *mod,
 			      struct trace_eval_map **start, int len) { }
 #endif /* !CONFIG_TRACE_EVAL_MAP_FILE */
@@ -5845,19 +5705,16 @@ static void trace_insert_eval_map(struct module *mod,
 	trace_insert_eval_map_file(mod, start, len);
 }
 
-static ssize_t
-tracing_set_trace_read(struct file *filp, char __user *ubuf,
-		       size_t cnt, loff_t *ppos)
+static int tracing_set_trace_show(struct seq_file *seq, void *m)
 {
-	struct trace_array *tr = filp->private_data;
-	char buf[MAX_TRACER_SIZE+2];
-	int r;
+	struct kernfs_open_file *of = seq->private;
+	struct trace_array *tr = of->priv;
 
 	mutex_lock(&trace_types_lock);
-	r = sprintf(buf, "%s\n", tr->current_trace->name);
+	seq_printf(seq, "%s\n", tr->current_trace->name);
 	mutex_unlock(&trace_types_lock);
 
-	return simple_read_from_buffer(ubuf, cnt, ppos, buf, r);
+	return 0;
 }
 
 int tracer_init(struct tracer *t, struct trace_array *tr)
@@ -6186,11 +6043,10 @@ int tracing_set_tracer(struct trace_array *tr, const char *buf)
 }
 
 static ssize_t
-tracing_set_trace_write(struct file *filp, const char __user *ubuf,
-			size_t cnt, loff_t *ppos)
+tracing_set_trace_write(struct kernfs_open_file *of, char *buf,
+			size_t cnt, loff_t ppos)
 {
-	struct trace_array *tr = filp->private_data;
-	char buf[MAX_TRACER_SIZE+1];
+	struct trace_array *tr = of->priv;
 	char *name;
 	size_t ret;
 	int err;
@@ -6200,68 +6056,50 @@ tracing_set_trace_write(struct file *filp, const char __user *ubuf,
 	if (cnt > MAX_TRACER_SIZE)
 		cnt = MAX_TRACER_SIZE;
 
-	if (copy_from_user(buf, ubuf, cnt))
-		return -EFAULT;
-
-	buf[cnt] = 0;
-
 	name = strim(buf);
 
 	err = tracing_set_tracer(tr, name);
 	if (err)
 		return err;
 
-	*ppos += ret;
-
 	return ret;
 }
 
-static ssize_t
-tracing_nsecs_read(unsigned long *ptr, char __user *ubuf,
-		   size_t cnt, loff_t *ppos)
+static int tracing_nsecs_show(unsigned long *ptr, struct seq_file *seq)
 {
-	char buf[64];
-	int r;
-
-	r = snprintf(buf, sizeof(buf), "%ld\n",
-		     *ptr == (unsigned long)-1 ? -1 : nsecs_to_usecs(*ptr));
-	if (r > sizeof(buf))
-		r = sizeof(buf);
-	return simple_read_from_buffer(ubuf, cnt, ppos, buf, r);
+	seq_printf(seq, "%ld\n",
+		   *ptr == (unsigned long)-1 ? -1 : nsecs_to_usecs(*ptr));
+	return 0;
 }
 
-static ssize_t
-tracing_nsecs_write(unsigned long *ptr, const char __user *ubuf,
-		    size_t cnt, loff_t *ppos)
+static ssize_t tracing_nsecs_write(unsigned long *ptr, const char *buf)
 {
 	unsigned long val;
 	int ret;
 
-	ret = kstrtoul_from_user(ubuf, cnt, 10, &val);
+	ret = kstrtoul(buf, 10, &val);
 	if (ret)
 		return ret;
 
 	*ptr = val * 1000;
 
-	return cnt;
+	return 0;
 }
 
-static ssize_t
-tracing_thresh_read(struct file *filp, char __user *ubuf,
-		    size_t cnt, loff_t *ppos)
+static int tracing_thresh_show(struct seq_file *seq, void *m)
 {
-	return tracing_nsecs_read(&tracing_thresh, ubuf, cnt, ppos);
+	return tracing_nsecs_show(&tracing_thresh, seq);
 }
 
 static ssize_t
-tracing_thresh_write(struct file *filp, const char __user *ubuf,
-		     size_t cnt, loff_t *ppos)
+tracing_thresh_write(struct kernfs_open_file *of, char *buf,
+		     size_t cnt, loff_t ppos)
 {
-	struct trace_array *tr = filp->private_data;
+	struct trace_array *tr = of->priv;
 	int ret;
 
 	guard(mutex)(&trace_types_lock);
-	ret = tracing_nsecs_write(&tracing_thresh, ubuf, cnt, ppos);
+	ret = tracing_nsecs_write(&tracing_thresh, buf);
 	if (ret < 0)
 		return ret;
 
@@ -6276,22 +6114,26 @@ tracing_thresh_write(struct file *filp, const char __user *ubuf,
 
 #ifdef CONFIG_TRACER_MAX_TRACE
 
-static ssize_t
-tracing_max_lat_read(struct file *filp, char __user *ubuf,
-		     size_t cnt, loff_t *ppos)
+static int tracing_max_lat_show(struct seq_file *seq, void *m)
 {
-	struct trace_array *tr = filp->private_data;
+	struct kernfs_open_file *of = seq->private;
+	struct trace_array *tr = of->priv;
 
-	return tracing_nsecs_read(&tr->max_latency, ubuf, cnt, ppos);
+	return tracing_nsecs_show(&tr->max_latency, seq);
 }
 
 static ssize_t
-tracing_max_lat_write(struct file *filp, const char __user *ubuf,
-		      size_t cnt, loff_t *ppos)
+tracing_max_lat_write(struct kernfs_open_file *of, char *buf,
+		      size_t cnt, loff_t ppos)
 {
-	struct trace_array *tr = filp->private_data;
+	struct trace_array *tr = of->priv;
+	int ret;
 
-	return tracing_nsecs_write(&tr->max_latency, ubuf, cnt, ppos);
+	ret = tracing_nsecs_write(&tr->max_latency, buf);
+	if (ret < 0)
+		return ret;
+
+	return cnt;
 }
 
 #endif
@@ -6321,9 +6163,9 @@ static void close_pipe_on_cpu(struct trace_array *tr, int cpu)
 	}
 }
 
-static int tracing_open_pipe(struct inode *inode, struct file *filp)
+static int tracing_open_pipe(struct kernfs_open_file *of)
 {
-	struct trace_array *tr = inode->i_private;
+	struct trace_array *tr = of->priv;
 	struct trace_iterator *iter;
 	int cpu;
 	int ret;
@@ -6333,7 +6175,7 @@ static int tracing_open_pipe(struct inode *inode, struct file *filp)
 		return ret;
 
 	mutex_lock(&trace_types_lock);
-	cpu = tracing_get_cpu(inode);
+	cpu = tracing_get_cpu(of->kn);
 	ret = open_pipe_on_cpu(tr, cpu);
 	if (ret)
 		goto fail_pipe_on_cpu;
@@ -6367,7 +6209,7 @@ static int tracing_open_pipe(struct inode *inode, struct file *filp)
 	iter->array_buffer = &tr->array_buffer;
 	iter->cpu_file = cpu;
 	mutex_init(&iter->mutex);
-	filp->private_data = iter;
+	of->file->private_data = iter;
 
 	if (iter->trace->pipe_open)
 		iter->trace->pipe_open(iter);
@@ -6389,10 +6231,10 @@ static int tracing_open_pipe(struct inode *inode, struct file *filp)
 	return ret;
 }
 
-static int tracing_release_pipe(struct inode *inode, struct file *file)
+static int tracing_release_pipe(struct kernfs_open_file *of)
 {
-	struct trace_iterator *iter = file->private_data;
-	struct trace_array *tr = inode->i_private;
+	struct trace_iterator *iter = of->file->private_data;
+	struct trace_array *tr = of->priv;
 
 	mutex_lock(&trace_types_lock);
 
@@ -6412,7 +6254,8 @@ static int tracing_release_pipe(struct inode *inode, struct file *file)
 }
 
 static __poll_t
-trace_poll(struct trace_iterator *iter, struct file *filp, poll_table *poll_table)
+trace_poll(struct trace_iterator *iter, struct kernfs_open_file *of,
+	   poll_table *poll_table)
 {
 	struct trace_array *tr = iter->tr;
 
@@ -6427,15 +6270,15 @@ trace_poll(struct trace_iterator *iter, struct file *filp, poll_table *poll_tabl
 		return EPOLLIN | EPOLLRDNORM;
 	else
 		return ring_buffer_poll_wait(iter->array_buffer->buffer, iter->cpu_file,
-					     filp, poll_table, iter->tr->buffer_percent);
+					     of->file, poll_table, iter->tr->buffer_percent);
 }
 
 static __poll_t
-tracing_poll_pipe(struct file *filp, poll_table *poll_table)
+tracing_poll_pipe(struct kernfs_open_file *of, struct poll_table_struct *pt)
 {
-	struct trace_iterator *iter = filp->private_data;
+	struct trace_iterator *iter = of->file->private_data;
 
-	return trace_poll(iter, filp, poll_table);
+	return trace_poll(iter, of, pt);
 }
 
 /* Must be called with iter->mutex held. */
@@ -6479,10 +6322,10 @@ static int tracing_wait_pipe(struct file *filp)
  * Consumer reader.
  */
 static ssize_t
-tracing_read_pipe(struct file *filp, char __user *ubuf,
-		  size_t cnt, loff_t *ppos)
+tracing_read_pipe(struct kernfs_open_file *of, char *buf,
+		  size_t cnt, loff_t ppos)
 {
-	struct trace_iterator *iter = filp->private_data;
+	struct trace_iterator *iter = of->priv;
 	ssize_t sret;
 
 	/*
@@ -6506,7 +6349,7 @@ tracing_read_pipe(struct file *filp, char __user *ubuf,
 	}
 
 waitagain:
-	sret = tracing_wait_pipe(filp);
+	sret = tracing_wait_pipe(of->file);
 	if (sret <= 0)
 		return sret;
 
@@ -6718,16 +6561,11 @@ static ssize_t tracing_splice_read_pipe(struct file *filp,
 	goto out;
 }
 
-static ssize_t
-tracing_entries_read(struct file *filp, char __user *ubuf,
-		     size_t cnt, loff_t *ppos)
+static int tracing_entries_show(struct seq_file *seq, void *m)
 {
-	struct inode *inode = file_inode(filp);
-	struct trace_array *tr = inode->i_private;
-	int cpu = tracing_get_cpu(inode);
-	char buf[64];
-	int r = 0;
-	ssize_t ret;
+	struct kernfs_open_file *of = seq->private;
+	struct trace_array *tr = of->priv;
+	int cpu = tracing_get_cpu(of->kn);
 
 	mutex_lock(&trace_types_lock);
 
@@ -6750,32 +6588,30 @@ tracing_entries_read(struct file *filp, char __user *ubuf,
 
 		if (buf_size_same) {
 			if (!tr->ring_buffer_expanded)
-				r = sprintf(buf, "%lu (expanded: %lu)\n",
-					    size >> 10,
-					    trace_buf_size >> 10);
+				seq_printf(seq, "%lu (expanded: %lu)\n",
+					   size >> 10,
+					   trace_buf_size >> 10);
 			else
-				r = sprintf(buf, "%lu\n", size >> 10);
+				seq_printf(seq, "%lu\n", size >> 10);
 		} else
-			r = sprintf(buf, "X\n");
+			seq_printf(seq, "X\n");
 	} else
-		r = sprintf(buf, "%lu\n", per_cpu_ptr(tr->array_buffer.data, cpu)->entries >> 10);
+		seq_printf(seq, "%lu\n", per_cpu_ptr(tr->array_buffer.data, cpu)->entries >> 10);
 
 	mutex_unlock(&trace_types_lock);
 
-	ret = simple_read_from_buffer(ubuf, cnt, ppos, buf, r);
-	return ret;
+	return 0;
 }
 
 static ssize_t
-tracing_entries_write(struct file *filp, const char __user *ubuf,
-		      size_t cnt, loff_t *ppos)
+tracing_entries_write(struct kernfs_open_file *of, char *buf,
+		      size_t cnt, loff_t ppos)
 {
-	struct inode *inode = file_inode(filp);
-	struct trace_array *tr = inode->i_private;
+	struct trace_array *tr = of->priv;
 	unsigned long val;
 	int ret;
 
-	ret = kstrtoul_from_user(ubuf, cnt, 10, &val);
+	ret = kstrtoul(buf, 10, &val);
 	if (ret)
 		return ret;
 
@@ -6785,12 +6621,10 @@ tracing_entries_write(struct file *filp, const char __user *ubuf,
 
 	/* value is in KB */
 	val <<= 10;
-	ret = tracing_resize_ring_buffer(tr, val, tracing_get_cpu(inode));
+	ret = tracing_resize_ring_buffer(tr, val, tracing_get_cpu(of->kn));
 	if (ret < 0)
 		return ret;
 
-	*ppos += cnt;
-
 	return cnt;
 }
 
@@ -6833,17 +6667,18 @@ tracing_last_boot_read(struct file *filp, char __user *ubuf, size_t cnt, loff_t
 	return simple_read_from_buffer(ubuf, cnt, ppos, buf, seq_buf_used(&seq));
 }
 
-static int tracing_buffer_meta_open(struct inode *inode, struct file *filp)
+static int tracing_buffer_meta_open(struct kernfs_open_file *of)
 {
-	struct trace_array *tr = inode->i_private;
-	int cpu = tracing_get_cpu(inode);
+	struct trace_array *tr = of->priv;
+	int cpu = tracing_get_cpu(of->kn);
 	int ret;
 
 	ret = tracing_check_open_get_tr(tr);
 	if (ret)
 		return ret;
 
-	ret = ring_buffer_meta_seq_init(filp, tr->array_buffer.buffer, cpu);
+	/* TODO: This is wrong. Just use kernfs seq ops directly */
+	ret = ring_buffer_meta_seq_init(of->file, tr->array_buffer.buffer, cpu);
 	if (ret < 0)
 		__trace_array_put(tr);
 	return ret;
@@ -7191,9 +7026,9 @@ struct ftrace_buffer_info {
 };
 
 #ifdef CONFIG_TRACER_SNAPSHOT
-static int tracing_snapshot_open(struct inode *inode, struct file *file)
+static int tracing_snapshot_open(struct kernfs_open_file *of)
 {
-	struct trace_array *tr = inode->i_private;
+	struct trace_array *tr = of->priv;
 	struct trace_iterator *iter;
 	struct seq_file *m;
 	int ret;
@@ -7202,8 +7037,8 @@ static int tracing_snapshot_open(struct inode *inode, struct file *file)
 	if (ret)
 		return ret;
 
-	if (file->f_mode & FMODE_READ) {
-		iter = __tracing_open(inode, file, true);
+	if (of->file->f_mode & FMODE_READ) {
+		iter = __tracing_open(of, true);
 		if (IS_ERR(iter))
 			ret = PTR_ERR(iter);
 	} else {
@@ -7221,9 +7056,9 @@ static int tracing_snapshot_open(struct inode *inode, struct file *file)
 
 		iter->tr = tr;
 		iter->array_buffer = &tr->max_buffer;
-		iter->cpu_file = tracing_get_cpu(inode);
+		iter->cpu_file = tracing_get_cpu(of->kn);
 		m->private = iter;
-		file->private_data = m;
+		of->file->private_data = m;
 	}
 out:
 	if (ret < 0)
@@ -7370,32 +7205,29 @@ static int snapshot_raw_open(struct inode *inode, struct file *filp)
 #endif /* CONFIG_TRACER_SNAPSHOT */
 
 
-static const struct file_operations tracing_thresh_fops = {
+static const struct kernfs_ops tracing_thresh_fops = {
 	.open		= tracing_open_generic,
-	.read		= tracing_thresh_read,
+	.seq_show	= tracing_thresh_show,
 	.write		= tracing_thresh_write,
-	.llseek		= generic_file_llseek,
 };
 
 #ifdef CONFIG_TRACER_MAX_TRACE
-static const struct file_operations tracing_max_lat_fops = {
+static const struct kernfs_ops tracing_max_lat_fops = {
 	.open		= tracing_open_generic_tr,
-	.read		= tracing_max_lat_read,
+	.seq_show	= tracing_max_lat_show,
 	.write		= tracing_max_lat_write,
-	.llseek		= generic_file_llseek,
 	.release	= tracing_release_generic_tr,
 };
 #endif
 
-static const struct file_operations set_tracer_fops = {
+static const struct kernfs_ops set_tracer_fops = {
 	.open		= tracing_open_generic_tr,
-	.read		= tracing_set_trace_read,
+	.seq_show	= tracing_set_trace_show,
 	.write		= tracing_set_trace_write,
-	.llseek		= generic_file_llseek,
 	.release	= tracing_release_generic_tr,
 };
 
-static const struct file_operations tracing_pipe_fops = {
+static const struct kernfs_ops tracing_pipe_fops = {
 	.open		= tracing_open_pipe,
 	.poll		= tracing_poll_pipe,
 	.read		= tracing_read_pipe,
@@ -7403,62 +7235,61 @@ static const struct file_operations tracing_pipe_fops = {
 	.release	= tracing_release_pipe,
 };
 
-static const struct file_operations tracing_entries_fops = {
+static const struct kernfs_ops tracing_entries_fops = {
 	.open		= tracing_open_generic_tr,
-	.read		= tracing_entries_read,
+	.seq_show	= tracing_entries_show,
 	.write		= tracing_entries_write,
-	.llseek		= generic_file_llseek,
 	.release	= tracing_release_generic_tr,
 };
 
-static const struct file_operations tracing_buffer_meta_fops = {
+static const struct kernfs_ops tracing_buffer_meta_fops = {
 	.open		= tracing_buffer_meta_open,
 	.read		= seq_read,
 	.llseek		= seq_lseek,
 	.release	= tracing_seq_release,
 };
 
-static const struct file_operations tracing_total_entries_fops = {
+static const struct kernfs_ops tracing_total_entries_fops = {
 	.open		= tracing_open_generic_tr,
 	.read		= tracing_total_entries_read,
 	.llseek		= generic_file_llseek,
 	.release	= tracing_release_generic_tr,
 };
 
-static const struct file_operations tracing_free_buffer_fops = {
+static const struct kernfs_ops tracing_free_buffer_fops = {
 	.open		= tracing_open_generic_tr,
 	.write		= tracing_free_buffer_write,
 	.release	= tracing_free_buffer_release,
 };
 
-static const struct file_operations tracing_mark_fops = {
+static const struct kernfs_ops tracing_mark_fops = {
 	.open		= tracing_mark_open,
 	.write		= tracing_mark_write,
 	.release	= tracing_release_generic_tr,
 };
 
-static const struct file_operations tracing_mark_raw_fops = {
+static const struct kernfs_ops tracing_mark_raw_fops = {
 	.open		= tracing_mark_open,
 	.write		= tracing_mark_raw_write,
 	.release	= tracing_release_generic_tr,
 };
 
-static const struct file_operations trace_clock_fops = {
+static const struct kernfs_ops trace_clock_fops = {
 	.open		= tracing_clock_open,
 	.read		= seq_read,
 	.llseek		= seq_lseek,
-	.release	= tracing_single_release_tr,
+	.release	= tracing_release_file_tr,
 	.write		= tracing_clock_write,
 };
 
-static const struct file_operations trace_time_stamp_mode_fops = {
+static const struct kernfs_ops trace_time_stamp_mode_fops = {
 	.open		= tracing_time_stamp_mode_open,
 	.read		= seq_read,
 	.llseek		= seq_lseek,
 	.release	= tracing_single_release_tr,
 };
 
-static const struct file_operations last_boot_fops = {
+static const struct kernfs_ops last_boot_fops = {
 	.open		= tracing_open_generic_tr,
 	.read		= tracing_last_boot_read,
 	.llseek		= generic_file_llseek,
@@ -7466,7 +7297,7 @@ static const struct file_operations last_boot_fops = {
 };
 
 #ifdef CONFIG_TRACER_SNAPSHOT
-static const struct file_operations snapshot_fops = {
+static const struct kernfs_ops snapshot_fops = {
 	.open		= tracing_snapshot_open,
 	.read		= seq_read,
 	.write		= tracing_snapshot_write,
@@ -7474,7 +7305,7 @@ static const struct file_operations snapshot_fops = {
 	.release	= tracing_snapshot_release,
 };
 
-static const struct file_operations snapshot_raw_fops = {
+static const struct kernfs_ops snapshot_raw_fops = {
 	.open		= snapshot_raw_open,
 	.read		= tracing_buffers_read,
 	.release	= tracing_buffers_release,
@@ -7562,7 +7393,7 @@ trace_min_max_read(struct file *filp, char __user *ubuf, size_t cnt, loff_t *ppo
 	return simple_read_from_buffer(ubuf, cnt, ppos, buf, len);
 }
 
-const struct file_operations trace_min_max_fops = {
+const struct kernfs_ops trace_min_max_fops = {
 	.open		= tracing_open_generic,
 	.read		= trace_min_max_read,
 	.write		= trace_min_max_write,
@@ -7834,7 +7665,7 @@ static int tracing_err_log_release(struct inode *inode, struct file *file)
 	return 0;
 }
 
-static const struct file_operations tracing_err_log_fops = {
+static const struct kernfs_ops tracing_err_log_fops = {
 	.open           = tracing_err_log_open,
 	.write		= tracing_err_log_write,
 	.read           = seq_read,
@@ -8298,7 +8129,7 @@ static int tracing_buffers_mmap(struct file *filp, struct vm_area_struct *vma)
 	return ret;
 }
 
-static const struct file_operations tracing_buffers_fops = {
+static const struct kernfs_ops tracing_buffers_fops = {
 	.open		= tracing_buffers_open,
 	.read		= tracing_buffers_read,
 	.poll		= tracing_buffers_poll,
@@ -8373,7 +8204,7 @@ tracing_stats_read(struct file *filp, char __user *ubuf,
 	return count;
 }
 
-static const struct file_operations tracing_stats_fops = {
+static const struct kernfs_ops tracing_stats_fops = {
 	.open		= tracing_open_generic_tr,
 	.read		= tracing_stats_read,
 	.llseek		= generic_file_llseek,
@@ -8412,7 +8243,7 @@ tracing_read_dyn_info(struct file *filp, char __user *ubuf,
 	return ret;
 }
 
-static const struct file_operations tracing_dyn_info_fops = {
+static const struct kernfs_ops tracing_dyn_info_fops = {
 	.open		= tracing_open_generic,
 	.read		= tracing_read_dyn_info,
 	.llseek		= generic_file_llseek,
@@ -8583,7 +8414,7 @@ static __init int register_snapshot_cmd(void)
 static inline __init int register_snapshot_cmd(void) { return 0; }
 #endif /* defined(CONFIG_TRACER_SNAPSHOT) && defined(CONFIG_DYNAMIC_FTRACE) */
 
-static struct dentry *tracing_get_dentry(struct trace_array *tr)
+static struct kernfs_node *tracing_dir(struct trace_array *tr)
 {
 	if (WARN_ON(!tr->dir))
 		return ERR_PTR(-ENODEV);
@@ -8596,14 +8427,14 @@ static struct dentry *tracing_get_dentry(struct trace_array *tr)
 	return tr->dir;
 }
 
-static struct dentry *tracing_dentry_percpu(struct trace_array *tr, int cpu)
+static struct kernfs_node *tracing_percpu_dir(struct trace_array *tr, int cpu)
 {
-	struct dentry *d_tracer;
+	struct kernfs_node *d_tracer;
 
 	if (tr->percpu_dir)
 		return tr->percpu_dir;
 
-	d_tracer = tracing_get_dentry(tr);
+	d_tracer = tracing_dir(tr);
 	if (IS_ERR(d_tracer))
 		return NULL;
 
@@ -8615,22 +8446,22 @@ static struct dentry *tracing_dentry_percpu(struct trace_array *tr, int cpu)
 	return tr->percpu_dir;
 }
 
-static struct dentry *
-trace_create_cpu_file(const char *name, umode_t mode, struct dentry *parent,
-		      void *data, long cpu, const struct file_operations *fops)
+static struct kernfs_node *
+trace_create_cpu_file(const char *name, umode_t mode, struct kernfs_node *parent,
+		      void *data, long cpu, const struct kernfs_ops *fops)
 {
-	struct dentry *ret = trace_create_file(name, mode, parent, data, fops);
+	struct kernfs_node *ret = trace_create_file(name, mode, parent, data, fops);
 
 	if (ret) /* See tracing_get_cpu() */
-		d_inode(ret)->i_cdev = (void *)(cpu + 1);
+		ret->priv = (void *)(cpu + 1);
 	return ret;
 }
 
 static void
 tracing_init_tracefs_percpu(struct trace_array *tr, long cpu)
 {
-	struct dentry *d_percpu = tracing_dentry_percpu(tr, cpu);
-	struct dentry *d_cpu;
+	struct kernfs_node *d_percpu = tracing_percpu_dir(tr, cpu);
+	struct kernfs_node *d_cpu;
 	char cpu_dir[30]; /* 30 characters should be more than enough */
 
 	if (!d_percpu)
@@ -8744,7 +8575,7 @@ static int tracing_release_options(struct inode *inode, struct file *file)
 	return 0;
 }
 
-static const struct file_operations trace_options_fops = {
+static const struct kernfs_ops trace_options_fops = {
 	.open = tracing_open_options,
 	.read = trace_options_read,
 	.write = trace_options_write,
@@ -8837,20 +8668,20 @@ trace_options_core_write(struct file *filp, const char __user *ubuf, size_t cnt,
 	return cnt;
 }
 
-static const struct file_operations trace_options_core_fops = {
+static const struct kernfs_ops trace_options_core_fops = {
 	.open = tracing_open_generic,
 	.read = trace_options_core_read,
 	.write = trace_options_core_write,
 	.llseek = generic_file_llseek,
 };
 
-struct dentry *trace_create_file(const char *name,
-				 umode_t mode,
-				 struct dentry *parent,
-				 void *data,
-				 const struct file_operations *fops)
+struct kernfs_node *trace_create_file(const char *name,
+				      umode_t mode,
+				      struct kernfs_node *parent,
+				      void *data,
+				      const struct kernfs_ops *fops)
 {
-	struct dentry *ret;
+	struct kernfs_node *ret;
 
 	ret = tracefs_create_file(name, mode, parent, data, fops);
 	if (!ret)
@@ -8860,14 +8691,14 @@ struct dentry *trace_create_file(const char *name,
 }
 
 
-static struct dentry *trace_options_init_dentry(struct trace_array *tr)
+static struct kernfs_node *trace_options_init_dir(struct trace_array *tr)
 {
-	struct dentry *d_tracer;
+	struct kernfs_node *d_tracer;
 
 	if (tr->options)
 		return tr->options;
 
-	d_tracer = tracing_get_dentry(tr);
+	d_tracer = tracing_dir(tr);
 	if (IS_ERR(d_tracer))
 		return NULL;
 
@@ -8886,9 +8717,9 @@ create_trace_option_file(struct trace_array *tr,
 			 struct tracer_flags *flags,
 			 struct tracer_opt *opt)
 {
-	struct dentry *t_options;
+	struct kernfs_node *t_options;
 
-	t_options = trace_options_init_dentry(tr);
+	t_options = trace_options_init_dir(tr);
 	if (!t_options)
 		return;
 
@@ -8968,7 +8799,7 @@ create_trace_option_core_file(struct trace_array *tr,
 {
 	struct dentry *t_options;
 
-	t_options = trace_options_init_dentry(tr);
+	t_options = trace_options_init_dir(tr);
 	if (!t_options)
 		return NULL;
 
@@ -8983,7 +8814,7 @@ static void create_trace_options_dir(struct trace_array *tr)
 	bool top_level = tr == &global_trace;
 	int i;
 
-	t_options = trace_options_init_dentry(tr);
+	t_options = trace_options_init_dir(tr);
 	if (!t_options)
 		return;
 
@@ -9044,7 +8875,7 @@ rb_simple_write(struct file *filp, const char __user *ubuf,
 	return cnt;
 }
 
-static const struct file_operations rb_simple_fops = {
+static const struct kernfs_ops rb_simple_fops = {
 	.open		= tracing_open_generic_tr,
 	.read		= rb_simple_read,
 	.write		= rb_simple_write,
@@ -9088,7 +8919,7 @@ buffer_percent_write(struct file *filp, const char __user *ubuf,
 	return cnt;
 }
 
-static const struct file_operations buffer_percent_fops = {
+static const struct kernfs_ops buffer_percent_fops = {
 	.open		= tracing_open_generic_tr,
 	.read		= buffer_percent_read,
 	.write		= buffer_percent_write,
@@ -9185,7 +9016,7 @@ buffer_subbuf_size_write(struct file *filp, const char __user *ubuf,
 	return cnt;
 }
 
-static const struct file_operations buffer_subbuf_size_fops = {
+static const struct kernfs_ops buffer_subbuf_size_fops = {
 	.open		= tracing_open_generic_tr,
 	.read		= buffer_subbuf_size_read,
 	.write		= buffer_subbuf_size_write,
@@ -9626,8 +9457,7 @@ static __init void create_trace_instances(struct dentry *d_tracer)
 {
 	struct trace_array *tr;
 
-	trace_instance_dir = tracefs_create_instance_dir("instances", d_tracer,
-							 instance_mkdir,
+	trace_instance_dir = tracefs_create_instance_dir(instance_mkdir,
 							 instance_rmdir);
 	if (MEM_FAIL(!trace_instance_dir, "Failed to create instances directory\n"))
 		return;
@@ -9645,7 +9475,7 @@ static __init void create_trace_instances(struct dentry *d_tracer)
 }
 
 static void
-init_tracer_tracefs(struct trace_array *tr, struct dentry *d_tracer)
+init_tracer_tracefs(struct trace_array *tr, struct kernfs_node *d_tracer)
 {
 	int cpu;
 
@@ -9704,7 +9534,8 @@ init_tracer_tracefs(struct trace_array *tr, struct dentry *d_tracer)
 	create_trace_options_dir(tr);
 
 #ifdef CONFIG_TRACER_MAX_TRACE
-	trace_create_maxlat_file(tr, d_tracer);
+	trace_create_file("tracing_max_latency", TRACE_MODE_WRITE,
+			  d_tracer, tr, &tracing_max_lat_fops);
 #endif
 
 	if (ftrace_create_function_files(tr, d_tracer))
diff --git a/kernel/trace/trace.h b/kernel/trace/trace.h
index 9c21ba45b7af..2500ab6fd852 100644
--- a/kernel/trace/trace.h
+++ b/kernel/trace/trace.h
@@ -339,9 +339,7 @@ struct trace_array {
 	unsigned int		snapshot;
 	unsigned long		max_latency;
 #ifdef CONFIG_FSNOTIFY
-	struct dentry		*d_max_latency;
-	struct work_struct	fsnotify_work;
-	struct irq_work		fsnotify_irqwork;
+	struct kernfs_node	*d_max_latency;
 #endif
 #endif
 	/* The below is for memory mapped ring buffer */
@@ -387,9 +385,9 @@ struct trace_array {
 	raw_spinlock_t		start_lock;
 	const char		*system_names;
 	struct list_head	err_log;
-	struct dentry		*dir;
-	struct dentry		*options;
-	struct dentry		*percpu_dir;
+	struct kernfs_node	*dir;
+	struct kernfs_node	*options;
+	struct kernfs_node	*percpu_dir;
 	struct eventfs_inode	*event_dir;
 	struct trace_options	*topts;
 	struct list_head	systems;
@@ -641,21 +639,21 @@ int tracing_is_enabled(void);
 void tracing_reset_online_cpus(struct array_buffer *buf);
 void tracing_reset_all_online_cpus(void);
 void tracing_reset_all_online_cpus_unlocked(void);
-int tracing_open_generic(struct inode *inode, struct file *filp);
-int tracing_open_generic_tr(struct inode *inode, struct file *filp);
-int tracing_release_generic_tr(struct inode *inode, struct file *file);
-int tracing_open_file_tr(struct inode *inode, struct file *filp);
-int tracing_release_file_tr(struct inode *inode, struct file *filp);
-int tracing_single_release_file_tr(struct inode *inode, struct file *filp);
+int tracing_open_generic(struct kernfs_open_file *of);
+int tracing_open_generic_tr(struct kernfs_open_file *of);
+void tracing_release_generic_tr(struct kernfs_open_file *of);
+int tracing_open_file_tr(struct kernfs_open_file *of);
+void tracing_release_file_tr(struct kernfs_open_file *of);
+int tracing_single_release_file_tr(struct kernfs_open_file *of);
 bool tracing_is_disabled(void);
 bool tracer_tracing_is_on(struct trace_array *tr);
 void tracer_tracing_on(struct trace_array *tr);
 void tracer_tracing_off(struct trace_array *tr);
-struct dentry *trace_create_file(const char *name,
-				 umode_t mode,
-				 struct dentry *parent,
-				 void *data,
-				 const struct file_operations *fops);
+struct kernfs_node *trace_create_file(const char *name,
+				      umode_t mode,
+				      struct kernfs_node *parent,
+				      void *data,
+				      const struct kernfs_ops *fops);
 
 int tracing_init_dentry(void);
 
