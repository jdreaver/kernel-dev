From f33f39efe585ab643eb3691097651b3c7cdae38f Mon Sep 17 00:00:00 2001
From: David Reaver <me@davidreaver.com>
Date: Wed, 22 Jan 2025 14:05:39 -0800
Subject: [PATCH 4/4] tracefs: Port to kernfs
To: Steven Rostedt <rostedt@goodmis.org>,
    Masami Hiramatsu <mhiramat@kernel.org>,
    Mathieu Desnoyers <mathieu.desnoyers@efficios.com>
Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>,
    Tejun Heo <tj@kernel.org>,
    Christian Brauner <brauner@kernel.org>,
    linux-trace-kernel@vger.kernel.org,
    linux-fsdevel@vger.kernel.org,
    linux-kernel@vger.kernel.org

Signed-off-by: David Reaver <me@davidreaver.com>
Suggested-by: Christian Brauner <brauner@kernel.org>
---
 fs/kernfs/inode.c       |  10 +
 fs/tracefs/inode.c      | 569 ++++++++++++----------------------------
 fs/tracefs/internal.h   |   3 +
 include/linux/kernfs.h  |   3 +
 include/linux/tracefs.h |  17 +-
 kernel/trace/trace.c    | 212 +++++++--------
 kernel/trace/trace.h    |  30 +--
 7 files changed, 308 insertions(+), 536 deletions(-)

diff --git a/fs/kernfs/inode.c b/fs/kernfs/inode.c
index b83054da68b3..9a2833f58cb5 100644
--- a/fs/kernfs/inode.c
+++ b/fs/kernfs/inode.c
@@ -196,6 +196,16 @@ int kernfs_iop_getattr(struct mnt_idmap *idmap,
 	return 0;
 }
 
+kuid_t kernfs_node_owner(struct kernfs_node *kn)
+{
+	return kernfs_iattrs(kn)->ia_uid;
+}
+
+kgid_t kernfs_node_group(struct kernfs_node *kn)
+{
+	return kernfs_iattrs(kn)->ia_gid;
+}
+
 static void kernfs_init_inode(struct kernfs_node *kn, struct inode *inode)
 {
 	kernfs_get(kn);
diff --git a/fs/tracefs/inode.c b/fs/tracefs/inode.c
index cfc614c638da..74c5cd78a279 100644
--- a/fs/tracefs/inode.c
+++ b/fs/tracefs/inode.c
@@ -24,7 +24,8 @@
 #include "internal.h"
 
 #define TRACEFS_DEFAULT_MODE	0700
-static struct kmem_cache *tracefs_inode_cachep __ro_after_init;
+static struct kernfs_root *tracefs_root;
+static struct kernfs_node *tracefs_kfs_root_node;
 
 static struct vfsmount *tracefs_mount;
 static int tracefs_mount_count;
@@ -37,56 +38,34 @@ static bool tracefs_registered;
 static DEFINE_SPINLOCK(tracefs_inode_lock);
 static LIST_HEAD(tracefs_inodes);
 
-static struct inode *tracefs_alloc_inode(struct super_block *sb)
+static ssize_t tracefs_kf_default_read(struct kernfs_open_file *of, char *buf,
+				       size_t count, loff_t pos)
 {
-	struct tracefs_inode *ti;
-	unsigned long flags;
-
-	ti = alloc_inode_sb(sb, tracefs_inode_cachep, GFP_KERNEL);
-	if (!ti)
-		return NULL;
-
-	spin_lock_irqsave(&tracefs_inode_lock, flags);
-	list_add_rcu(&ti->list, &tracefs_inodes);
-	spin_unlock_irqrestore(&tracefs_inode_lock, flags);
-
-	return &ti->vfs_inode;
+	return 0;
 }
 
-static void tracefs_free_inode(struct inode *inode)
+static ssize_t tracefs_kf_default_write(struct kernfs_open_file *of, char *buf,
+					size_t count, loff_t pos)
 {
-	struct tracefs_inode *ti = get_tracefs(inode);
-
-	kmem_cache_free(tracefs_inode_cachep, ti);
+	return 0;
 }
 
-static void tracefs_destroy_inode(struct inode *inode)
+static loff_t tracefs_kf_default_llseek(struct kernfs_open_file *of,
+					loff_t offset, int whence)
 {
-	struct tracefs_inode *ti = get_tracefs(inode);
-	unsigned long flags;
-
-	spin_lock_irqsave(&tracefs_inode_lock, flags);
-	list_del_rcu(&ti->list);
-	spin_unlock_irqrestore(&tracefs_inode_lock, flags);
+	return noop_llseek(of->file, offset, whence);
 }
 
-static ssize_t default_read_file(struct file *file, char __user *buf,
-				 size_t count, loff_t *ppos)
+static int tracefs_kf_default_open(struct kernfs_open_file *of)
 {
 	return 0;
 }
 
-static ssize_t default_write_file(struct file *file, const char __user *buf,
-				   size_t count, loff_t *ppos)
-{
-	return count;
-}
-
-static const struct file_operations tracefs_file_operations = {
-	.read =		default_read_file,
-	.write =	default_write_file,
-	.open =		simple_open,
-	.llseek =	noop_llseek,
+static const struct kernfs_ops tracefs_default_file_kfops = {
+	.read		= tracefs_kf_default_read,
+	.write		= tracefs_kf_default_write,
+	.open		= tracefs_kf_default_open,
+	.llseek		= tracefs_kf_default_llseek,
 };
 
 static struct tracefs_dir_ops {
@@ -94,180 +73,6 @@ static struct tracefs_dir_ops {
 	int (*rmdir)(const char *name);
 } tracefs_ops __ro_after_init;
 
-static char *get_dname(struct dentry *dentry)
-{
-	const char *dname;
-	char *name;
-	int len = dentry->d_name.len;
-
-	dname = dentry->d_name.name;
-	name = kmalloc(len + 1, GFP_KERNEL);
-	if (!name)
-		return NULL;
-	memcpy(name, dname, len);
-	name[len] = 0;
-	return name;
-}
-
-static int tracefs_syscall_mkdir(struct mnt_idmap *idmap,
-				 struct inode *inode, struct dentry *dentry,
-				 umode_t mode)
-{
-	struct tracefs_inode *ti;
-	char *name;
-	int ret;
-
-	name = get_dname(dentry);
-	if (!name)
-		return -ENOMEM;
-
-	/*
-	 * This is a new directory that does not take the default of
-	 * the rootfs. It becomes the default permissions for all the
-	 * files and directories underneath it.
-	 */
-	ti = get_tracefs(inode);
-	ti->flags |= TRACEFS_INSTANCE_INODE;
-	ti->private = inode;
-
-	/*
-	 * The mkdir call can call the generic functions that create
-	 * the files within the tracefs system. It is up to the individual
-	 * mkdir routine to handle races.
-	 */
-	inode_unlock(inode);
-	ret = tracefs_ops.mkdir(name);
-	inode_lock(inode);
-
-	kfree(name);
-
-	return ret;
-}
-
-static int tracefs_syscall_rmdir(struct inode *inode, struct dentry *dentry)
-{
-	char *name;
-	int ret;
-
-	name = get_dname(dentry);
-	if (!name)
-		return -ENOMEM;
-
-	/*
-	 * The rmdir call can call the generic functions that create
-	 * the files within the tracefs system. It is up to the individual
-	 * rmdir routine to handle races.
-	 * This time we need to unlock not only the parent (inode) but
-	 * also the directory that is being deleted.
-	 */
-	inode_unlock(inode);
-	inode_unlock(d_inode(dentry));
-
-	ret = tracefs_ops.rmdir(name);
-
-	inode_lock_nested(inode, I_MUTEX_PARENT);
-	inode_lock(d_inode(dentry));
-
-	kfree(name);
-
-	return ret;
-}
-
-static void set_tracefs_inode_owner(struct inode *inode)
-{
-	struct tracefs_inode *ti = get_tracefs(inode);
-	struct inode *root_inode = ti->private;
-	kuid_t uid;
-	kgid_t gid;
-
-	uid = root_inode->i_uid;
-	gid = root_inode->i_gid;
-
-	/*
-	 * If the root is not the mount point, then check the root's
-	 * permissions. If it was never set, then default to the
-	 * mount point.
-	 */
-	if (root_inode != d_inode(root_inode->i_sb->s_root)) {
-		struct tracefs_inode *rti;
-
-		rti = get_tracefs(root_inode);
-		root_inode = d_inode(root_inode->i_sb->s_root);
-
-		if (!(rti->flags & TRACEFS_UID_PERM_SET))
-			uid = root_inode->i_uid;
-
-		if (!(rti->flags & TRACEFS_GID_PERM_SET))
-			gid = root_inode->i_gid;
-	}
-
-	/*
-	 * If this inode has never been referenced, then update
-	 * the permissions to the superblock.
-	 */
-	if (!(ti->flags & TRACEFS_UID_PERM_SET))
-		inode->i_uid = uid;
-
-	if (!(ti->flags & TRACEFS_GID_PERM_SET))
-		inode->i_gid = gid;
-}
-
-static int tracefs_permission(struct mnt_idmap *idmap,
-			      struct inode *inode, int mask)
-{
-	set_tracefs_inode_owner(inode);
-	return generic_permission(idmap, inode, mask);
-}
-
-static int tracefs_getattr(struct mnt_idmap *idmap,
-			   const struct path *path, struct kstat *stat,
-			   u32 request_mask, unsigned int flags)
-{
-	struct inode *inode = d_backing_inode(path->dentry);
-
-	set_tracefs_inode_owner(inode);
-	generic_fillattr(idmap, request_mask, inode, stat);
-	return 0;
-}
-
-static int tracefs_setattr(struct mnt_idmap *idmap, struct dentry *dentry,
-			   struct iattr *attr)
-{
-	unsigned int ia_valid = attr->ia_valid;
-	struct inode *inode = d_inode(dentry);
-	struct tracefs_inode *ti = get_tracefs(inode);
-
-	if (ia_valid & ATTR_UID)
-		ti->flags |= TRACEFS_UID_PERM_SET;
-
-	if (ia_valid & ATTR_GID)
-		ti->flags |= TRACEFS_GID_PERM_SET;
-
-	return simple_setattr(idmap, dentry, attr);
-}
-
-static const struct inode_operations tracefs_instance_dir_inode_operations = {
-	.lookup		= simple_lookup,
-	.mkdir		= tracefs_syscall_mkdir,
-	.rmdir		= tracefs_syscall_rmdir,
-	.permission	= tracefs_permission,
-	.getattr	= tracefs_getattr,
-	.setattr	= tracefs_setattr,
-};
-
-static const struct inode_operations tracefs_dir_inode_operations = {
-	.lookup		= simple_lookup,
-	.permission	= tracefs_permission,
-	.getattr	= tracefs_getattr,
-	.setattr	= tracefs_setattr,
-};
-
-static const struct inode_operations tracefs_file_inode_operations = {
-	.permission	= tracefs_permission,
-	.getattr	= tracefs_getattr,
-	.setattr	= tracefs_setattr,
-};
-
 struct inode *tracefs_get_inode(struct super_block *sb)
 {
 	struct inode *inode = new_inode(sb);
@@ -286,6 +91,14 @@ struct tracefs_fs_info {
 	unsigned int opts;
 };
 
+/* Why do we have global _and_ stuffed into tracefs_context? */
+static struct tracefs_fs_info global_info = {
+	.mode	= TRACEFS_DEFAULT_MODE,
+	.uid	= GLOBAL_ROOT_UID,
+	.gid	= GLOBAL_ROOT_GID,
+	.opts	= 0,
+};
+
 enum {
 	Opt_uid,
 	Opt_gid,
@@ -299,10 +112,24 @@ static const struct fs_parameter_spec tracefs_param_specs[] = {
 	{}
 };
 
+struct tracefs_context {
+	struct kernfs_fs_context kfc;
+ 	struct tracefs_fs_info fs_info;
+};
+
+static inline struct tracefs_context *trace_fc2context(struct fs_context *fc)
+{
+	struct kernfs_fs_context *kfc = fc->fs_private;
+
+	return container_of(kfc, struct tracefs_context, kfc);
+}
+
 static int tracefs_parse_param(struct fs_context *fc, struct fs_parameter *param)
 {
-	struct tracefs_fs_info *opts = fc->s_fs_info;
+	struct tracefs_context *ctx = trace_fc2context(fc);
+	struct tracefs_fs_info *info = &ctx->fs_info;
 	struct fs_parse_result result;
+
 	int opt;
 
 	opt = fs_parse(fc, tracefs_param_specs, param, &result);
@@ -311,13 +138,13 @@ static int tracefs_parse_param(struct fs_context *fc, struct fs_parameter *param
 
 	switch (opt) {
 	case Opt_uid:
-		opts->uid = result.uid;
+		info->uid = result.uid;
 		break;
 	case Opt_gid:
-		opts->gid = result.gid;
+		info->gid = result.gid;
 		break;
 	case Opt_mode:
-		opts->mode = result.uint_32 & S_IALLUGO;
+		info->mode = result.uint_32 & S_IALLUGO;
 		break;
 	/*
 	 * We might like to report bad mount options here;
@@ -325,51 +152,55 @@ static int tracefs_parse_param(struct fs_context *fc, struct fs_parameter *param
 	 */
 	}
 
-	opts->opts |= BIT(opt);
+	info->opts |= BIT(opt);
 
 	return 0;
 }
 
 static int tracefs_apply_options(struct super_block *sb, bool remount)
 {
-	struct tracefs_fs_info *fsi = sb->s_fs_info;
 	struct inode *inode = d_inode(sb->s_root);
 	struct tracefs_inode *ti;
 	bool update_uid, update_gid;
 	umode_t tmp_mode;
 
+	kuid_t kuid = global_info.uid;
+	kgid_t kgid = global_info.gid;
+	umode_t mode = global_info.mode;
+	unsigned int opts = global_info.opts;
+
 	/*
 	 * On remount, only reset mode/uid/gid if they were provided as mount
 	 * options.
 	 */
 
-	if (!remount || fsi->opts & BIT(Opt_mode)) {
+	if (!remount || opts & BIT(Opt_mode)) {
 		tmp_mode = READ_ONCE(inode->i_mode) & ~S_IALLUGO;
-		tmp_mode |= fsi->mode;
+		tmp_mode |= mode;
 		WRITE_ONCE(inode->i_mode, tmp_mode);
 	}
 
-	if (!remount || fsi->opts & BIT(Opt_uid))
-		inode->i_uid = fsi->uid;
+	if (!remount || opts & BIT(Opt_uid))
+		inode->i_uid = kuid;
 
-	if (!remount || fsi->opts & BIT(Opt_gid))
-		inode->i_gid = fsi->gid;
+	if (!remount || opts & BIT(Opt_gid))
+		inode->i_gid = kgid;
 
-	if (remount && (fsi->opts & BIT(Opt_uid) || fsi->opts & BIT(Opt_gid))) {
+	if (remount && (opts & BIT(Opt_uid) || opts & BIT(Opt_gid))) {
 
-		update_uid = fsi->opts & BIT(Opt_uid);
-		update_gid = fsi->opts & BIT(Opt_gid);
+		update_uid = opts & BIT(Opt_uid);
+		update_gid = opts & BIT(Opt_gid);
 
 		rcu_read_lock();
 		list_for_each_entry_rcu(ti, &tracefs_inodes, list) {
 			if (update_uid) {
 				ti->flags &= ~TRACEFS_UID_PERM_SET;
-				ti->vfs_inode.i_uid = fsi->uid;
+				ti->vfs_inode.i_uid = kuid;
 			}
 
 			if (update_gid) {
 				ti->flags &= ~TRACEFS_GID_PERM_SET;
-				ti->vfs_inode.i_gid = fsi->gid;
+				ti->vfs_inode.i_gid = kgid;
 			}
 
 			/*
@@ -386,6 +217,7 @@ static int tracefs_apply_options(struct super_block *sb, bool remount)
 	return 0;
 }
 
+/* TODO: Christian had most of this function nuked */
 static int tracefs_reconfigure(struct fs_context *fc)
 {
 	struct super_block *sb = fc->root->d_sb;
@@ -395,6 +227,7 @@ static int tracefs_reconfigure(struct fs_context *fc)
 	if (!new_opts)
 		return 0;
 
+	/* TODO: Do we need sync_filesystem with kernfs? */
 	sync_filesystem(sb);
 	/* structure copy of new mount options to sb */
 	*sb_opts = *new_opts;
@@ -402,46 +235,53 @@ static int tracefs_reconfigure(struct fs_context *fc)
 	return tracefs_apply_options(sb, true);
 }
 
-static int tracefs_show_options(struct seq_file *m, struct dentry *root)
+static int tracefs_show_options(struct seq_file *seq, struct kernfs_root *kf_root)
 {
-	struct tracefs_fs_info *fsi = root->d_sb->s_fs_info;
+	kuid_t kuid = global_info.uid;
+	kgid_t kgid = global_info.gid;
+	umode_t mode = global_info.mode;
 
-	if (!uid_eq(fsi->uid, GLOBAL_ROOT_UID))
-		seq_printf(m, ",uid=%u",
-			   from_kuid_munged(&init_user_ns, fsi->uid));
-	if (!gid_eq(fsi->gid, GLOBAL_ROOT_GID))
-		seq_printf(m, ",gid=%u",
-			   from_kgid_munged(&init_user_ns, fsi->gid));
-	if (fsi->mode != TRACEFS_DEFAULT_MODE)
-		seq_printf(m, ",mode=%o", fsi->mode);
+	if (!uid_eq(kuid, GLOBAL_ROOT_UID))
+		seq_printf(seq, ",uid=%u", from_kuid_munged(&init_user_ns, kuid));
+	if (!gid_eq(kgid, GLOBAL_ROOT_GID))
+		seq_printf(seq, ",gid=%u", from_kgid_munged(&init_user_ns, kgid));
+	if (mode != TRACEFS_DEFAULT_MODE)
+		seq_printf(seq, ",mode=%o", mode);
 
 	return 0;
-}
+ }
 
-static int tracefs_drop_inode(struct inode *inode)
-{
-	struct tracefs_inode *ti = get_tracefs(inode);
+static int tracefs_mkdir(struct kernfs_node *parent_kn, const char *name, umode_t mode)
+ {
+	int ret;
+	struct kernfs_node *kn;
 
-	/*
-	 * This inode is being freed and cannot be used for
-	 * eventfs. Clear the flag so that it doesn't call into
-	 * eventfs during the remount flag updates. The eventfs_inode
-	 * gets freed after an RCU cycle, so the content will still
-	 * be safe if the iteration is going on now.
-	 */
-	ti->flags &= ~TRACEFS_EVENT_INODE;
+	if (parent_kn != trace_instance_dir)
+		return -EPERM;
 
-	return 1;
+	kn = tracefs_create_dir(name, parent_kn);
+	if (IS_ERR(kn))
+		return PTR_ERR(kn);
+
+	ret = tracefs_ops.mkdir(name);
+	if (ret)
+		kernfs_remove(kn);
+	return ret;
 }
 
-static const struct super_operations tracefs_super_operations = {
-	.alloc_inode    = tracefs_alloc_inode,
-	.free_inode     = tracefs_free_inode,
-	.destroy_inode  = tracefs_destroy_inode,
-	.drop_inode     = tracefs_drop_inode,
-	.statfs		= simple_statfs,
-	.show_options	= tracefs_show_options,
-};
+static int tracefs_rmdir(struct kernfs_node *kn)
+ {
+	int ret;
+
+	if (kn != trace_instance_dir)
+		return -EPERM;
+
+ 	ret = tracefs_ops.rmdir(kn->name);
+	if (!ret)
+		kernfs_remove(kn);
+
+	return ret;
+}
 
 /*
  * It would be cleaner if eventfs had its own dentry ops.
@@ -464,39 +304,34 @@ static int tracefs_d_revalidate(struct dentry *dentry, unsigned int flags)
 	return !(ei && ei->is_freed);
 }
 
+/* necessary for eventsfs */
 static const struct dentry_operations tracefs_dentry_operations = {
 	.d_revalidate = tracefs_d_revalidate,
 	.d_release = tracefs_d_release,
 };
 
-static int tracefs_fill_super(struct super_block *sb, struct fs_context *fc)
-{
-	static const struct tree_descr trace_files[] = {{""}};
-	int err;
-
-	err = simple_fill_super(sb, TRACEFS_MAGIC, trace_files);
-	if (err)
-		return err;
-
-	sb->s_op = &tracefs_super_operations;
-	sb->s_d_op = &tracefs_dentry_operations;
-
-	return 0;
-}
+static struct kernfs_syscall_ops tracefs_kf_syscall_ops = {
+	.show_options		= tracefs_show_options,
+	.mkdir			= tracefs_mkdir,
+	.rmdir			= tracefs_rmdir,
+};
 
 static int tracefs_get_tree(struct fs_context *fc)
 {
-	int err = get_tree_single(fc, tracefs_fill_super);
+	int ret;
 
-	if (err)
-		return err;
+	ret = kernfs_get_tree(fc);
+	if (!ret)
+		tracefs_apply_options(fc->root->d_sb, false);
 
-	return tracefs_reconfigure(fc);
+	return ret;
 }
 
 static void tracefs_free_fc(struct fs_context *fc)
 {
-	kfree(fc->s_fs_info);
+	struct tracefs_context *ctx = trace_fc2context(fc);
+	kernfs_free_fs_context(fc);
+	kfree(ctx);
 }
 
 static const struct fs_context_operations tracefs_context_ops = {
@@ -521,12 +356,12 @@ static int tracefs_init_fs_context(struct fs_context *fc)
 	return 0;
 }
 
-static struct file_system_type trace_fs_type = {
-	.owner =	THIS_MODULE,
-	.name =		"tracefs",
-	.init_fs_context = tracefs_init_fs_context,
-	.parameters	= tracefs_param_specs,
-	.kill_sb =	kill_litter_super,
+static struct file_system_type tracefs_type = {
+	.owner			= THIS_MODULE,
+	.name 			="tracefs",
+	.init_fs_context 	= tracefs_init_fs_context,
+	.parameters		= tracefs_param_specs,
+	.kill_sb		= kill_litter_super, /* TODO do we need kill_sb? */
 };
 MODULE_ALIAS_FS("tracefs");
 
@@ -537,7 +372,7 @@ struct dentry *tracefs_start_creating(const char *name, struct dentry *parent)
 
 	pr_debug("tracefs: creating file '%s'\n",name);
 
-	error = simple_pin_fs(&trace_fs_type, &tracefs_mount,
+	error = simple_pin_fs(&tracefs_type, &tracefs_mount,
 			      &tracefs_mount_count);
 	if (error)
 		return ERR_PTR(error);
@@ -620,7 +455,7 @@ static struct inode *instance_inode(struct dentry *parent, struct inode *inode)
  * to create a directory, the tracefs_create_dir() function is
  * recommended to be used instead.)
  *
- * This function will return a pointer to a dentry if it succeeds.  This
+ * This function will return a pointer to a kernfs_node if it succeeds.  This
  * pointer must be passed to the tracefs_remove() function when the file is
  * to be removed (no automatic cleanup happens if your module is unloaded,
  * you are responsible here.)  If an error occurs, %NULL will be returned.
@@ -628,74 +463,27 @@ static struct inode *instance_inode(struct dentry *parent, struct inode *inode)
  * If tracefs is not enabled in the kernel, the value -%ENODEV will be
  * returned.
  */
-struct dentry *tracefs_create_file(const char *name, umode_t mode,
-				   struct dentry *parent, void *data,
-				   const struct file_operations *fops)
+struct kernfs_node *tracefs_create_file(const char *name, umode_t mode,
+					struct kernfs_node *parent, void *data,
+					const struct kernfs_ops *ops)
 {
-	struct tracefs_inode *ti;
-	struct dentry *dentry;
-	struct inode *inode;
-
 	if (security_locked_down(LOCKDOWN_TRACEFS))
 		return NULL;
 
 	if (!(mode & S_IFMT))
 		mode |= S_IFREG;
 	BUG_ON(!S_ISREG(mode));
-	dentry = tracefs_start_creating(name, parent);
 
-	if (IS_ERR(dentry))
-		return NULL;
+	/* TODO What is this? */
+	// inode->i_op = &tracefs_file_inode_operations;
 
-	inode = tracefs_get_inode(dentry->d_sb);
-	if (unlikely(!inode))
-		return tracefs_failed_creating(dentry);
-
-	ti = get_tracefs(inode);
-	ti->private = instance_inode(parent, inode);
-
-	inode->i_mode = mode;
-	inode->i_op = &tracefs_file_inode_operations;
-	inode->i_fop = fops ? fops : &tracefs_file_operations;
-	inode->i_private = data;
-	inode->i_uid = d_inode(dentry->d_parent)->i_uid;
-	inode->i_gid = d_inode(dentry->d_parent)->i_gid;
-	d_instantiate(dentry, inode);
-	fsnotify_create(d_inode(dentry->d_parent), dentry);
-	return tracefs_end_creating(dentry);
+	return __kernfs_create_file(parent ?: tracefs_kfs_root_node, name, mode,
+				    kernfs_node_owner(parent),
+				    kernfs_node_group(parent), PAGE_SIZE,
+				    ops ? : &tracefs_default_file_kfops, data, NULL,
+				    NULL);
 }
 
-static struct dentry *__create_dir(const char *name, struct dentry *parent,
-				   const struct inode_operations *ops)
-{
-	struct tracefs_inode *ti;
-	struct dentry *dentry = tracefs_start_creating(name, parent);
-	struct inode *inode;
-
-	if (IS_ERR(dentry))
-		return NULL;
-
-	inode = tracefs_get_inode(dentry->d_sb);
-	if (unlikely(!inode))
-		return tracefs_failed_creating(dentry);
-
-	/* Do not set bits for OTH */
-	inode->i_mode = S_IFDIR | S_IRWXU | S_IRUSR| S_IRGRP | S_IXUSR | S_IXGRP;
-	inode->i_op = ops;
-	inode->i_fop = &simple_dir_operations;
-	inode->i_uid = d_inode(dentry->d_parent)->i_uid;
-	inode->i_gid = d_inode(dentry->d_parent)->i_gid;
-
-	ti = get_tracefs(inode);
-	ti->private = instance_inode(parent, inode);
-
-	/* directory inodes start off with i_nlink == 2 (for "." entry) */
-	inc_nlink(inode);
-	d_instantiate(dentry, inode);
-	inc_nlink(d_inode(dentry->d_parent));
-	fsnotify_mkdir(d_inode(dentry->d_parent), dentry);
-	return tracefs_end_creating(dentry);
-}
 
 /**
  * tracefs_create_dir - create a directory in the tracefs filesystem
@@ -714,18 +502,21 @@ static struct dentry *__create_dir(const char *name, struct dentry *parent,
  * If tracing is not enabled in the kernel, the value -%ENODEV will be
  * returned.
  */
-struct dentry *tracefs_create_dir(const char *name, struct dentry *parent)
-{
-	if (security_locked_down(LOCKDOWN_TRACEFS))
-		return NULL;
+struct kernfs_node *tracefs_create_dir(const char *name,
+				       struct kernfs_node *parent)
+ {
+ 	if (security_locked_down(LOCKDOWN_TRACEFS))
+		return ERR_PTR(-EINVAL);
 
-	return __create_dir(name, parent, &tracefs_dir_inode_operations);
+	return kernfs_create_dir_ns(parent ?: tracefs_kfs_root_node, name,
+				  S_IFDIR | S_IRWXU | S_IRUSR | S_IRGRP |
+				  S_IXUSR | S_IXGRP,
+				  kernfs_node_owner(parent),
+				  kernfs_node_group(parent), NULL, NULL);
 }
 
 /**
  * tracefs_create_instance_dir - create the tracing instances directory
- * @name: The name of the instances directory to create
- * @parent: The parent directory that the instances directory will exist
  * @mkdir: The function to call when a mkdir is performed.
  * @rmdir: The function to call when a rmdir is performed.
  *
@@ -739,48 +530,38 @@ struct dentry *tracefs_create_dir(const char *name, struct dentry *parent)
  *
  * Returns the dentry of the instances directory.
  */
-__init struct dentry *tracefs_create_instance_dir(const char *name,
-					  struct dentry *parent,
-					  int (*mkdir)(const char *name),
-					  int (*rmdir)(const char *name))
+__init struct kernfs_node *tracefs_create_instance_dir(int (*mkdir)(const char *name),
+						       int (*rmdir)(const char *name))
 {
-	struct dentry *dentry;
-
-	/* Only allow one instance of the instances directory. */
-	if (WARN_ON(tracefs_ops.mkdir || tracefs_ops.rmdir))
-		return NULL;
-
-	dentry = __create_dir(name, parent, &tracefs_instance_dir_inode_operations);
-	if (!dentry)
-		return NULL;
+	struct kernfs_node *kn;
 
-	tracefs_ops.mkdir = mkdir;
-	tracefs_ops.rmdir = rmdir;
+ 	/* Only allow one instance of the instances directory. */
+ 	if (WARN_ON(tracefs_ops.mkdir || tracefs_ops.rmdir))
+		return ERR_PTR(-EINVAL);
 
-	return dentry;
-}
+	kn = tracefs_create_dir("instances", tracefs_kfs_root_node);
+	if (IS_ERR(kn))
+		return kn;
 
-static void remove_one(struct dentry *victim)
-{
-	simple_release_fs(&tracefs_mount, &tracefs_mount_count);
+ 	tracefs_ops.mkdir = mkdir;
+ 	tracefs_ops.rmdir = rmdir;
+	return kn;
 }
 
 /**
  * tracefs_remove - recursively removes a directory
- * @dentry: a pointer to a the dentry of the directory to be removed.
+ * @kn: a pointer to a the kernfs_node of the directory to be removed.
  *
  * This function recursively removes a directory tree in tracefs that
  * was previously created with a call to another tracefs function
  * (like tracefs_create_file() or variants thereof.)
  */
-void tracefs_remove(struct dentry *dentry)
+void tracefs_remove(struct kernfs_node *kn)
 {
-	if (IS_ERR_OR_NULL(dentry))
+	if (IS_ERR_OR_NULL(kn))
 		return;
 
-	simple_pin_fs(&trace_fs_type, &tracefs_mount, &tracefs_mount_count);
-	simple_recursive_removal(dentry, remove_one);
-	simple_release_fs(&tracefs_mount, &tracefs_mount_count);
+	kernfs_remove(kn);
 }
 
 /**
@@ -791,36 +572,30 @@ bool tracefs_initialized(void)
 	return tracefs_registered;
 }
 
-static void init_once(void *foo)
-{
-	struct tracefs_inode *ti = (struct tracefs_inode *) foo;
-
-	/* inode_init_once() calls memset() on the vfs_inode portion */
-	inode_init_once(&ti->vfs_inode);
-
-	/* Zero out the rest */
-	memset_after(ti, 0, vfs_inode);
-}
-
 static int __init tracefs_init(void)
 {
 	int retval;
+	struct kernfs_root *kfs_root;
 
-	tracefs_inode_cachep = kmem_cache_create("tracefs_inode_cache",
-						 sizeof(struct tracefs_inode),
-						 0, (SLAB_RECLAIM_ACCOUNT|
-						     SLAB_ACCOUNT),
-						 init_once);
-	if (!tracefs_inode_cachep)
-		return -ENOMEM;
+	kfs_root = kernfs_create_root(&tracefs_kf_syscall_ops,
+				      KERNFS_ROOT_CREATE_DEACTIVATED, NULL);
+	if (IS_ERR(kfs_root))
+                return PTR_ERR(kfs_root);
 
 	retval = sysfs_create_mount_point(kernel_kobj, "tracing");
-	if (retval)
+	if (retval) {
+		kernfs_destroy_root(kfs_root);
 		return -EINVAL;
+	}
 
-	retval = register_filesystem(&trace_fs_type);
+	retval = register_filesystem(&tracefs_type);
 	if (!retval)
 		tracefs_registered = true;
+	else
+		kernfs_destroy_root(kfs_root);
+
+	tracefs_root = kfs_root;
+	tracefs_kfs_root_node = kernfs_root_to_node(kfs_root);
 
 	return retval;
 }
diff --git a/fs/tracefs/internal.h b/fs/tracefs/internal.h
index d83c2a25f288..8679ebcff6c2 100644
--- a/fs/tracefs/internal.h
+++ b/fs/tracefs/internal.h
@@ -2,6 +2,9 @@
 #ifndef _TRACEFS_INTERNAL_H
 #define _TRACEFS_INTERNAL_H
 
+#include <linux/kernfs.h>
+#include <linux/module.h>
+
 enum {
 	TRACEFS_EVENT_INODE		= BIT(1),
 	TRACEFS_GID_PERM_SET		= BIT(2),
diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h
index 02ee62e057a8..3dfd640389bb 100644
--- a/include/linux/kernfs.h
+++ b/include/linux/kernfs.h
@@ -246,6 +246,9 @@ struct kernfs_syscall_ops {
 			 struct kernfs_root *root);
 };
 
+kuid_t kernfs_node_owner(struct kernfs_node *kn);
+kgid_t kernfs_node_group(struct kernfs_node *kn);
+
 struct kernfs_node *kernfs_root_to_node(struct kernfs_root *root);
 
 struct kernfs_open_file {
diff --git a/include/linux/tracefs.h b/include/linux/tracefs.h
index d03f74658716..62f28250a2dc 100644
--- a/include/linux/tracefs.h
+++ b/include/linux/tracefs.h
@@ -13,6 +13,7 @@
 #define _TRACEFS_H_
 
 #include <linux/fs.h>
+#include <linux/kernfs.h>
 #include <linux/seq_file.h>
 
 #include <linux/types.h>
@@ -22,6 +23,7 @@ struct file_operations;
 #ifdef CONFIG_TRACING
 
 struct eventfs_file;
+extern struct kernfs_node *trace_instance_dir;
 
 /**
  * eventfs_callback - A callback function to create dynamic files in eventfs
@@ -90,17 +92,16 @@ struct eventfs_inode *eventfs_create_dir(const char *name, struct eventfs_inode
 void eventfs_remove_events_dir(struct eventfs_inode *ei);
 void eventfs_remove_dir(struct eventfs_inode *ei);
 
-struct dentry *tracefs_create_file(const char *name, umode_t mode,
-				   struct dentry *parent, void *data,
-				   const struct file_operations *fops);
+struct kernfs_node *tracefs_create_file(const char *name, umode_t mode,
+					struct kernfs_node *parent, void *data,
+					const struct kernfs_ops *ops);
 
-struct dentry *tracefs_create_dir(const char *name, struct dentry *parent);
+struct kernfs_node *tracefs_create_dir(const char *name, struct kernfs_node *parent);
 
-void tracefs_remove(struct dentry *dentry);
+void tracefs_remove(struct kernfs_node *kn);
 
-struct dentry *tracefs_create_instance_dir(const char *name, struct dentry *parent,
-					   int (*mkdir)(const char *name),
-					   int (*rmdir)(const char *name));
+struct kernfs_node *tracefs_create_instance_dir(int (*mkdir)(const char *name),
+						int (*rmdir)(const char *name));
 
 bool tracefs_initialized(void);
 
diff --git a/kernel/trace/trace.c b/kernel/trace/trace.c
index 2542ec398b5d..86763dd68ffd 100644
--- a/kernel/trace/trace.c
+++ b/kernel/trace/trace.c
@@ -1839,7 +1839,7 @@ static ssize_t trace_seq_to_buffer(struct trace_seq *s, void *buf, size_t cnt)
 unsigned long __read_mostly	tracing_thresh;
 
 #ifdef CONFIG_TRACER_MAX_TRACE
-static const struct file_operations tracing_max_lat_fops;
+static const struct kernfs_ops tracing_max_lat_fops;
 
 #ifdef LATENCY_FS_NOTIFY
 
@@ -1849,7 +1849,8 @@ static void latency_fsnotify_workfn(struct work_struct *work)
 {
 	struct trace_array *tr = container_of(work, struct trace_array,
 					      fsnotify_work);
-	fsnotify_inode(tr->d_max_latency->d_inode, FS_MODIFY);
+	struct inode *inode = kernfs_get_inode(tr->d_max_latency);
+	fsnotify_inode(inode, FS_MODIFY);
 }
 
 static void latency_fsnotify_workfn_irq(struct irq_work *iwork)
@@ -1860,7 +1861,7 @@ static void latency_fsnotify_workfn_irq(struct irq_work *iwork)
 }
 
 static void trace_create_maxlat_file(struct trace_array *tr,
-				     struct dentry *d_tracer)
+				     struct kernfs_node *d_tracer)
 {
 	INIT_WORK(&tr->fsnotify_work, latency_fsnotify_workfn);
 	init_irq_work(&tr->fsnotify_irqwork, latency_fsnotify_workfn_irq);
@@ -4679,7 +4680,7 @@ __tracing_open(struct inode *inode, struct file *file, bool snapshot)
 	return ERR_PTR(-ENOMEM);
 }
 
-int tracing_open_generic(struct inode *inode, struct file *filp)
+int tracing_open_generic(struct kernfs_open_file *of)
 {
 	int ret;
 
@@ -4687,7 +4688,8 @@ int tracing_open_generic(struct inode *inode, struct file *filp)
 	if (ret)
 		return ret;
 
-	filp->private_data = inode->i_private;
+	of->priv = of->kn->priv;
+
 	return 0;
 }
 
@@ -4700,16 +4702,16 @@ bool tracing_is_disabled(void)
  * Open and update trace_array ref count.
  * Must have the current trace_array passed to it.
  */
-int tracing_open_generic_tr(struct inode *inode, struct file *filp)
+int tracing_open_generic_tr(struct kernfs_open_file *of)
 {
-	struct trace_array *tr = inode->i_private;
+	struct trace_array *tr = of->kn->priv;
 	int ret;
 
 	ret = tracing_check_open_get_tr(tr);
 	if (ret)
 		return ret;
 
-	filp->private_data = inode->i_private;
+	of->priv = of->kn->priv;
 
 	return 0;
 }
@@ -4718,9 +4720,9 @@ int tracing_open_generic_tr(struct inode *inode, struct file *filp)
  * The private pointer of the inode is the trace_event_file.
  * Update the tr ref count associated to it.
  */
-int tracing_open_file_tr(struct inode *inode, struct file *filp)
+int tracing_open_file_tr(struct kernfs_open_file *of)
 {
-	struct trace_event_file *file = inode->i_private;
+	struct trace_event_file *file = of->priv;
 	int ret;
 
 	ret = tracing_check_open_get_tr(file->tr);
@@ -4741,31 +4743,22 @@ int tracing_open_file_tr(struct inode *inode, struct file *filp)
 	if (ret)
 		return ret;
 
-	filp->private_data = inode->i_private;
-
 	return 0;
 }
 
-int tracing_release_file_tr(struct inode *inode, struct file *filp)
+void tracing_release_file_tr(struct kernfs_open_file *of)
 {
-	struct trace_event_file *file = inode->i_private;
+	struct trace_event_file *file = of->priv;
 
 	trace_array_put(file->tr);
 	event_file_put(file);
-
-	return 0;
-}
-
-int tracing_single_release_file_tr(struct inode *inode, struct file *filp)
-{
-	tracing_release_file_tr(inode, filp);
-	return single_release(inode, filp);
 }
 
-static int tracing_mark_open(struct inode *inode, struct file *filp)
+static int tracing_mark_open(struct kernfs_open_file *of)
 {
-	stream_open(inode, filp);
-	return tracing_open_generic_tr(inode, filp);
+	/* TODO What does stream_open do? */
+	/* stream_open(inode, filp); */
+	return tracing_open_generic_tr(of);
 }
 
 static int tracing_release(struct inode *inode, struct file *file)
@@ -4806,21 +4799,11 @@ static int tracing_release(struct inode *inode, struct file *file)
 	return 0;
 }
 
-int tracing_release_generic_tr(struct inode *inode, struct file *file)
+void tracing_release_generic_tr(struct kernfs_open_file *of)
 {
-	struct trace_array *tr = inode->i_private;
+	struct trace_array *tr = of->priv;
 
 	trace_array_put(tr);
-	return 0;
-}
-
-static int tracing_single_release_tr(struct inode *inode, struct file *file)
-{
-	struct trace_array *tr = inode->i_private;
-
-	trace_array_put(tr);
-
-	return single_release(inode, file);
 }
 
 static int tracing_open(struct inode *inode, struct file *file)
@@ -5013,10 +4996,10 @@ static const struct file_operations show_traces_fops = {
 };
 
 static ssize_t
-tracing_cpumask_read(struct file *filp, char __user *ubuf,
-		     size_t count, loff_t *ppos)
+tracing_cpumask_read(struct kernfs_open_file *of, char *ubuf,
+		     size_t count, loff_t ppos)
 {
-	struct trace_array *tr = file_inode(filp)->i_private;
+	struct trace_array *tr = of->priv;
 	char *mask_str;
 	int len;
 
@@ -5081,10 +5064,10 @@ int tracing_set_cpumask(struct trace_array *tr,
 }
 
 static ssize_t
-tracing_cpumask_write(struct file *filp, const char __user *ubuf,
-		      size_t count, loff_t *ppos)
+tracing_cpumask_write(struct kernfs_open_file *of, char *buf,
+		      size_t count, loff_t ppos)
 {
-	struct trace_array *tr = file_inode(filp)->i_private;
+	struct trace_array *tr = of->priv;
 	cpumask_var_t tracing_cpumask_new;
 	int err;
 
@@ -5094,7 +5077,7 @@ tracing_cpumask_write(struct file *filp, const char __user *ubuf,
 	if (!zalloc_cpumask_var(&tracing_cpumask_new, GFP_KERNEL))
 		return -ENOMEM;
 
-	err = cpumask_parse_user(ubuf, count, tracing_cpumask_new);
+	err = cpumask_parse_user(buf, count, tracing_cpumask_new);
 	if (err)
 		goto err_free;
 
@@ -5112,7 +5095,7 @@ tracing_cpumask_write(struct file *filp, const char __user *ubuf,
 	return err;
 }
 
-static const struct file_operations tracing_cpumask_fops = {
+static const struct kernfs_ops tracing_cpumask_fops = {
 	.open		= tracing_open_generic_tr,
 	.read		= tracing_cpumask_read,
 	.write		= tracing_cpumask_write,
@@ -5328,10 +5311,10 @@ static void __init apply_trace_boot_options(void)
 }
 
 static ssize_t
-tracing_trace_options_write(struct file *filp, const char __user *ubuf,
-			size_t cnt, loff_t *ppos)
+tracing_trace_options_write(struct kernfs_open_file *of, const char *ubuf,
+			    size_t cnt, loff_t *ppos)
 {
-	struct seq_file *m = filp->private_data;
+	struct seq_file *m = of->priv;
 	struct trace_array *tr = m->private;
 	char buf[64];
 	int ret;
@@ -5353,9 +5336,9 @@ tracing_trace_options_write(struct file *filp, const char __user *ubuf,
 	return cnt;
 }
 
-static int tracing_trace_options_open(struct inode *inode, struct file *file)
+static int tracing_trace_options_open(struct kernfs_open_file *of)
 {
-	struct trace_array *tr = inode->i_private;
+	struct trace_array *tr = of->priv;
 	int ret;
 
 	ret = tracing_check_open_get_tr(tr);
@@ -5369,11 +5352,11 @@ static int tracing_trace_options_open(struct inode *inode, struct file *file)
 	return ret;
 }
 
-static const struct file_operations tracing_iter_fops = {
+static const struct kernfs_ops tracing_iter_fops = {
 	.open		= tracing_trace_options_open,
 	.read		= seq_read,
 	.llseek		= seq_lseek,
-	.release	= tracing_single_release_tr,
+	.release	= tracing_release_generic_tr,
 	.write		= tracing_trace_options_write,
 };
 
@@ -5674,17 +5657,17 @@ static const char readme_msg[] =
 ;
 
 static ssize_t
-tracing_readme_read(struct file *filp, char __user *ubuf,
-		       size_t cnt, loff_t *ppos)
+tracing_readme_read(struct kernfs_open_file *of, char *buf,
+		    size_t bytes, loff_t *ppos)
 {
-	return simple_read_from_buffer(ubuf, cnt, ppos,
-					readme_msg, strlen(readme_msg));
+	/* TODO: Change from user buffer to non-user buffer? */
+	return simple_read_from_buffer(buf, bytes, ppos,
+				       readme_msg, strlen(readme_msg));
 }
 
-static const struct file_operations tracing_readme_fops = {
+static const struct kernfs_ops tracing_readme_fops = {
 	.open		= tracing_open_generic,
 	.read		= tracing_readme_read,
-	.llseek		= generic_file_llseek,
 };
 
 #ifdef CONFIG_TRACE_EVAL_MAP_FILE
@@ -6279,15 +6262,15 @@ tracing_nsecs_write(unsigned long *ptr, const char __user *ubuf,
 }
 
 static ssize_t
-tracing_thresh_read(struct file *filp, char __user *ubuf,
-		    size_t cnt, loff_t *ppos)
+tracing_thresh_read(struct kernfs_open_file *of, char *buf,
+		    size_t cnt, loff_t ppos)
 {
 	return tracing_nsecs_read(&tracing_thresh, ubuf, cnt, ppos);
 }
 
 static ssize_t
-tracing_thresh_write(struct file *filp, const char __user *ubuf,
-		     size_t cnt, loff_t *ppos)
+tracing_thresh_write(struct kernfs_open_file *of, const char *ubuf,
+		     size_t cnt, loff_t ppos)
 {
 	struct trace_array *tr = filp->private_data;
 	int ret;
@@ -7424,15 +7407,14 @@ static int snapshot_raw_open(struct inode *inode, struct file *filp)
 #endif /* CONFIG_TRACER_SNAPSHOT */
 
 
-static const struct file_operations tracing_thresh_fops = {
+static const struct kernfs_ops tracing_thresh_fops = {
 	.open		= tracing_open_generic,
 	.read		= tracing_thresh_read,
 	.write		= tracing_thresh_write,
-	.llseek		= generic_file_llseek,
 };
 
 #ifdef CONFIG_TRACER_MAX_TRACE
-static const struct file_operations tracing_max_lat_fops = {
+static const struct kernfs_ops tracing_max_lat_fops = {
 	.open		= tracing_open_generic_tr,
 	.read		= tracing_max_lat_read,
 	.write		= tracing_max_lat_write,
@@ -7441,15 +7423,14 @@ static const struct file_operations tracing_max_lat_fops = {
 };
 #endif
 
-static const struct file_operations set_tracer_fops = {
+static const struct kernfs_ops set_tracer_fops = {
 	.open		= tracing_open_generic_tr,
 	.read		= tracing_set_trace_read,
 	.write		= tracing_set_trace_write,
-	.llseek		= generic_file_llseek,
 	.release	= tracing_release_generic_tr,
 };
 
-static const struct file_operations tracing_pipe_fops = {
+static const struct kernfs_ops tracing_pipe_fops = {
 	.open		= tracing_open_pipe,
 	.poll		= tracing_poll_pipe,
 	.read		= tracing_read_pipe,
@@ -7457,7 +7438,7 @@ static const struct file_operations tracing_pipe_fops = {
 	.release	= tracing_release_pipe,
 };
 
-static const struct file_operations tracing_entries_fops = {
+static const struct kernfs_ops tracing_entries_fops = {
 	.open		= tracing_open_generic_tr,
 	.read		= tracing_entries_read,
 	.write		= tracing_entries_write,
@@ -7465,54 +7446,54 @@ static const struct file_operations tracing_entries_fops = {
 	.release	= tracing_release_generic_tr,
 };
 
-static const struct file_operations tracing_buffer_meta_fops = {
+static const struct kernfs_ops tracing_buffer_meta_fops = {
 	.open		= tracing_buffer_meta_open,
 	.read		= seq_read,
 	.llseek		= seq_lseek,
 	.release	= tracing_seq_release,
 };
 
-static const struct file_operations tracing_total_entries_fops = {
+static const struct kernfs_ops tracing_total_entries_fops = {
 	.open		= tracing_open_generic_tr,
 	.read		= tracing_total_entries_read,
 	.llseek		= generic_file_llseek,
 	.release	= tracing_release_generic_tr,
 };
 
-static const struct file_operations tracing_free_buffer_fops = {
+static const struct kernfs_ops tracing_free_buffer_fops = {
 	.open		= tracing_open_generic_tr,
 	.write		= tracing_free_buffer_write,
 	.release	= tracing_free_buffer_release,
 };
 
-static const struct file_operations tracing_mark_fops = {
+static const struct kernfs_ops tracing_mark_fops = {
 	.open		= tracing_mark_open,
 	.write		= tracing_mark_write,
 	.release	= tracing_release_generic_tr,
 };
 
-static const struct file_operations tracing_mark_raw_fops = {
+static const struct kernfs_ops tracing_mark_raw_fops = {
 	.open		= tracing_mark_open,
 	.write		= tracing_mark_raw_write,
 	.release	= tracing_release_generic_tr,
 };
 
-static const struct file_operations trace_clock_fops = {
+static const struct kernfs_ops trace_clock_fops = {
 	.open		= tracing_clock_open,
 	.read		= seq_read,
 	.llseek		= seq_lseek,
-	.release	= tracing_single_release_tr,
+	.release	= tracing_release_file_tr,
 	.write		= tracing_clock_write,
 };
 
-static const struct file_operations trace_time_stamp_mode_fops = {
+static const struct kernfs_ops trace_time_stamp_mode_fops = {
 	.open		= tracing_time_stamp_mode_open,
 	.read		= seq_read,
 	.llseek		= seq_lseek,
 	.release	= tracing_single_release_tr,
 };
 
-static const struct file_operations last_boot_fops = {
+static const struct kernfs_ops last_boot_fops = {
 	.open		= tracing_open_generic_tr,
 	.read		= tracing_last_boot_read,
 	.llseek		= generic_file_llseek,
@@ -7520,7 +7501,7 @@ static const struct file_operations last_boot_fops = {
 };
 
 #ifdef CONFIG_TRACER_SNAPSHOT
-static const struct file_operations snapshot_fops = {
+static const struct kernfs_ops snapshot_fops = {
 	.open		= tracing_snapshot_open,
 	.read		= seq_read,
 	.write		= tracing_snapshot_write,
@@ -7528,7 +7509,7 @@ static const struct file_operations snapshot_fops = {
 	.release	= tracing_snapshot_release,
 };
 
-static const struct file_operations snapshot_raw_fops = {
+static const struct kernfs_ops snapshot_raw_fops = {
 	.open		= snapshot_raw_open,
 	.read		= tracing_buffers_read,
 	.release	= tracing_buffers_release,
@@ -7616,7 +7597,7 @@ trace_min_max_read(struct file *filp, char __user *ubuf, size_t cnt, loff_t *ppo
 	return simple_read_from_buffer(ubuf, cnt, ppos, buf, len);
 }
 
-const struct file_operations trace_min_max_fops = {
+const struct kernfs_ops trace_min_max_fops = {
 	.open		= tracing_open_generic,
 	.read		= trace_min_max_read,
 	.write		= trace_min_max_write,
@@ -7890,7 +7871,7 @@ static int tracing_err_log_release(struct inode *inode, struct file *file)
 	return 0;
 }
 
-static const struct file_operations tracing_err_log_fops = {
+static const struct kernfs_ops tracing_err_log_fops = {
 	.open           = tracing_err_log_open,
 	.write		= tracing_err_log_write,
 	.read           = seq_read,
@@ -8354,7 +8335,7 @@ static int tracing_buffers_mmap(struct file *filp, struct vm_area_struct *vma)
 	return ret;
 }
 
-static const struct file_operations tracing_buffers_fops = {
+static const struct kernfs_ops tracing_buffers_fops = {
 	.open		= tracing_buffers_open,
 	.read		= tracing_buffers_read,
 	.poll		= tracing_buffers_poll,
@@ -8429,7 +8410,7 @@ tracing_stats_read(struct file *filp, char __user *ubuf,
 	return count;
 }
 
-static const struct file_operations tracing_stats_fops = {
+static const struct kernfs_ops tracing_stats_fops = {
 	.open		= tracing_open_generic_tr,
 	.read		= tracing_stats_read,
 	.llseek		= generic_file_llseek,
@@ -8468,7 +8449,7 @@ tracing_read_dyn_info(struct file *filp, char __user *ubuf,
 	return ret;
 }
 
-static const struct file_operations tracing_dyn_info_fops = {
+static const struct kernfs_ops tracing_dyn_info_fops = {
 	.open		= tracing_open_generic,
 	.read		= tracing_read_dyn_info,
 	.llseek		= generic_file_llseek,
@@ -8639,7 +8620,7 @@ static __init int register_snapshot_cmd(void)
 static inline __init int register_snapshot_cmd(void) { return 0; }
 #endif /* defined(CONFIG_TRACER_SNAPSHOT) && defined(CONFIG_DYNAMIC_FTRACE) */
 
-static struct dentry *tracing_get_dentry(struct trace_array *tr)
+static struct kernfs_node *tracing_dir(struct trace_array *tr)
 {
 	if (WARN_ON(!tr->dir))
 		return ERR_PTR(-ENODEV);
@@ -8652,14 +8633,14 @@ static struct dentry *tracing_get_dentry(struct trace_array *tr)
 	return tr->dir;
 }
 
-static struct dentry *tracing_dentry_percpu(struct trace_array *tr, int cpu)
+static struct kernfs_node *tracing_percpu_dir(struct trace_array *tr, int cpu)
 {
-	struct dentry *d_tracer;
+	struct kernfs_node *d_tracer;
 
 	if (tr->percpu_dir)
 		return tr->percpu_dir;
 
-	d_tracer = tracing_get_dentry(tr);
+	d_tracer = tracing_dir(tr);
 	if (IS_ERR(d_tracer))
 		return NULL;
 
@@ -8671,11 +8652,11 @@ static struct dentry *tracing_dentry_percpu(struct trace_array *tr, int cpu)
 	return tr->percpu_dir;
 }
 
-static struct dentry *
-trace_create_cpu_file(const char *name, umode_t mode, struct dentry *parent,
-		      void *data, long cpu, const struct file_operations *fops)
+static struct kernfs_node *
+trace_create_cpu_file(const char *name, umode_t mode, struct kernfs_node *parent,
+		      void *data, long cpu, const struct kernfs_ops *fops)
 {
-	struct dentry *ret = trace_create_file(name, mode, parent, data, fops);
+	struct kernfs_node *ret = trace_create_file(name, mode, parent, data, fops);
 
 	if (ret) /* See tracing_get_cpu() */
 		d_inode(ret)->i_cdev = (void *)(cpu + 1);
@@ -8685,8 +8666,8 @@ trace_create_cpu_file(const char *name, umode_t mode, struct dentry *parent,
 static void
 tracing_init_tracefs_percpu(struct trace_array *tr, long cpu)
 {
-	struct dentry *d_percpu = tracing_dentry_percpu(tr, cpu);
-	struct dentry *d_cpu;
+	struct kernfs_node *d_percpu = tracing_percpu_dir(tr, cpu);
+	struct kernfs_node *d_cpu;
 	char cpu_dir[30]; /* 30 characters should be more than enough */
 
 	if (!d_percpu)
@@ -8800,7 +8781,7 @@ static int tracing_release_options(struct inode *inode, struct file *file)
 	return 0;
 }
 
-static const struct file_operations trace_options_fops = {
+static const struct kernfs_ops trace_options_fops = {
 	.open = tracing_open_options,
 	.read = trace_options_read,
 	.write = trace_options_write,
@@ -8893,20 +8874,20 @@ trace_options_core_write(struct file *filp, const char __user *ubuf, size_t cnt,
 	return cnt;
 }
 
-static const struct file_operations trace_options_core_fops = {
+static const struct kernfs_ops trace_options_core_fops = {
 	.open = tracing_open_generic,
 	.read = trace_options_core_read,
 	.write = trace_options_core_write,
 	.llseek = generic_file_llseek,
 };
 
-struct dentry *trace_create_file(const char *name,
-				 umode_t mode,
-				 struct dentry *parent,
-				 void *data,
-				 const struct file_operations *fops)
+struct kernfs_node *trace_create_file(const char *name,
+				      umode_t mode,
+				      struct kernfs_node *parent,
+				      void *data,
+				      const struct kernfs_ops *fops)
 {
-	struct dentry *ret;
+	struct kernfs_node *ret;
 
 	ret = tracefs_create_file(name, mode, parent, data, fops);
 	if (!ret)
@@ -8916,14 +8897,14 @@ struct dentry *trace_create_file(const char *name,
 }
 
 
-static struct dentry *trace_options_init_dentry(struct trace_array *tr)
+static struct kernfs_node *trace_options_init_dir(struct trace_array *tr)
 {
-	struct dentry *d_tracer;
+	struct kernfs_node *d_tracer;
 
 	if (tr->options)
 		return tr->options;
 
-	d_tracer = tracing_get_dentry(tr);
+	d_tracer = tracing_dir(tr);
 	if (IS_ERR(d_tracer))
 		return NULL;
 
@@ -8942,9 +8923,9 @@ create_trace_option_file(struct trace_array *tr,
 			 struct tracer_flags *flags,
 			 struct tracer_opt *opt)
 {
-	struct dentry *t_options;
+	struct kernfs_node *t_options;
 
-	t_options = trace_options_init_dentry(tr);
+	t_options = trace_options_init_dir(tr);
 	if (!t_options)
 		return;
 
@@ -9024,7 +9005,7 @@ create_trace_option_core_file(struct trace_array *tr,
 {
 	struct dentry *t_options;
 
-	t_options = trace_options_init_dentry(tr);
+	t_options = trace_options_init_dir(tr);
 	if (!t_options)
 		return NULL;
 
@@ -9039,7 +9020,7 @@ static void create_trace_options_dir(struct trace_array *tr)
 	bool top_level = tr == &global_trace;
 	int i;
 
-	t_options = trace_options_init_dentry(tr);
+	t_options = trace_options_init_dir(tr);
 	if (!t_options)
 		return;
 
@@ -9100,7 +9081,7 @@ rb_simple_write(struct file *filp, const char __user *ubuf,
 	return cnt;
 }
 
-static const struct file_operations rb_simple_fops = {
+static const struct kernfs_ops rb_simple_fops = {
 	.open		= tracing_open_generic_tr,
 	.read		= rb_simple_read,
 	.write		= rb_simple_write,
@@ -9144,7 +9125,7 @@ buffer_percent_write(struct file *filp, const char __user *ubuf,
 	return cnt;
 }
 
-static const struct file_operations buffer_percent_fops = {
+static const struct kernfs_ops buffer_percent_fops = {
 	.open		= tracing_open_generic_tr,
 	.read		= buffer_percent_read,
 	.write		= buffer_percent_write,
@@ -9241,7 +9222,7 @@ buffer_subbuf_size_write(struct file *filp, const char __user *ubuf,
 	return cnt;
 }
 
-static const struct file_operations buffer_subbuf_size_fops = {
+static const struct kernfs_ops buffer_subbuf_size_fops = {
 	.open		= tracing_open_generic_tr,
 	.read		= buffer_subbuf_size_read,
 	.write		= buffer_subbuf_size_write,
@@ -9694,8 +9675,7 @@ static __init void create_trace_instances(struct dentry *d_tracer)
 {
 	struct trace_array *tr;
 
-	trace_instance_dir = tracefs_create_instance_dir("instances", d_tracer,
-							 instance_mkdir,
+	trace_instance_dir = tracefs_create_instance_dir(instance_mkdir,
 							 instance_rmdir);
 	if (MEM_FAIL(!trace_instance_dir, "Failed to create instances directory\n"))
 		return;
@@ -9716,7 +9696,7 @@ static __init void create_trace_instances(struct dentry *d_tracer)
 }
 
 static void
-init_tracer_tracefs(struct trace_array *tr, struct dentry *d_tracer)
+init_tracer_tracefs(struct trace_array *tr, struct kernfs_node *d_tracer)
 {
 	int cpu;
 
diff --git a/kernel/trace/trace.h b/kernel/trace/trace.h
index 04058a9889b7..5d5ebf01f838 100644
--- a/kernel/trace/trace.h
+++ b/kernel/trace/trace.h
@@ -339,7 +339,7 @@ struct trace_array {
 	unsigned int		snapshot;
 	unsigned long		max_latency;
 #ifdef CONFIG_FSNOTIFY
-	struct dentry		*d_max_latency;
+	struct kernfs_node	*d_max_latency;
 	struct work_struct	fsnotify_work;
 	struct irq_work		fsnotify_irqwork;
 #endif
@@ -387,9 +387,9 @@ struct trace_array {
 	raw_spinlock_t		start_lock;
 	const char		*system_names;
 	struct list_head	err_log;
-	struct dentry		*dir;
-	struct dentry		*options;
-	struct dentry		*percpu_dir;
+	struct kernfs_node	*dir;
+	struct kernfs_node	*options;
+	struct kernfs_node	*percpu_dir;
 	struct eventfs_inode	*event_dir;
 	struct trace_options	*topts;
 	struct list_head	systems;
@@ -629,21 +629,21 @@ int tracing_is_enabled(void);
 void tracing_reset_online_cpus(struct array_buffer *buf);
 void tracing_reset_all_online_cpus(void);
 void tracing_reset_all_online_cpus_unlocked(void);
-int tracing_open_generic(struct inode *inode, struct file *filp);
-int tracing_open_generic_tr(struct inode *inode, struct file *filp);
-int tracing_release_generic_tr(struct inode *inode, struct file *file);
-int tracing_open_file_tr(struct inode *inode, struct file *filp);
-int tracing_release_file_tr(struct inode *inode, struct file *filp);
-int tracing_single_release_file_tr(struct inode *inode, struct file *filp);
+int tracing_open_generic(struct kernfs_open_file *of);
+int tracing_open_generic_tr(struct kernfs_open_file *of);
+void tracing_release_generic_tr(struct kernfs_open_file *of);
+int tracing_open_file_tr(struct kernfs_open_file *of);
+void tracing_release_file_tr(struct kernfs_open_file *of);
+int tracing_single_release_file_tr(struct kernfs_open_file *of);
 bool tracing_is_disabled(void);
 bool tracer_tracing_is_on(struct trace_array *tr);
 void tracer_tracing_on(struct trace_array *tr);
 void tracer_tracing_off(struct trace_array *tr);
-struct dentry *trace_create_file(const char *name,
-				 umode_t mode,
-				 struct dentry *parent,
-				 void *data,
-				 const struct file_operations *fops);
+struct kernfs_node *trace_create_file(const char *name,
+				      umode_t mode,
+				      struct kernfs_node *parent,
+				      void *data,
+				      const struct kernfs_ops *fops);
 
 int tracing_init_dentry(void);
 
