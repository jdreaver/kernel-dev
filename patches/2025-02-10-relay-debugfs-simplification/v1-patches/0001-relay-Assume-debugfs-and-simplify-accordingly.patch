From 24d685c9ff2a415d9379438c1618a11707fc667d Mon Sep 17 00:00:00 2001
From: David Reaver <me@davidreaver.com>
Date: Mon, 10 Feb 2025 16:30:48 -0800
Subject: [RFC PATCH] relay: Assume debugfs and simplify accordingly
To: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Cc: Alexander Viro <viro@zeniv.linux.org.uk>,
    linux-fsdevel@vger.kernel.org,
    linux-kernel@vger.kernel.org,
    David Reaver <me@davidreaver.com>

While the relay documentation suggests support for non-debugfs users, in
practice all relay users rely on debugfs. By assuming relay is only used in
debugfs, we can vastly simplify the code and documentation. We realized
this when while migrating relay to use an opaque handle for debugfs nodes
instead of dentry [1].

The create_buf_file and remove_buf_file callbacks have been removed and
replaced with direct calls to debugfs_create_file and debugfs_remove. Users
now just specify a struct file_operations and an optional is_global flag.

Lastly, relay_late_setup_files() was unused, so it has been removed.

Link: https://lore.kernel.org/linux-fsdevel/2025021048-thieving-failing-7831@gregkh/ [1]

Signed-off-by: David Reaver <me@davidreaver.com>
Suggested-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
---
 Documentation/filesystems/relay.rst           | 136 +++++-------------
 drivers/gpu/drm/i915/gt/uc/intel_guc_log.c    |  43 +-----
 drivers/net/wireless/ath/ath10k/spectral.c    |  28 +---
 drivers/net/wireless/ath/ath11k/spectral.c    |  25 +---
 .../net/wireless/ath/ath9k/common-spectral.c  |  28 +---
 .../wireless/mediatek/mt76/mt7915/debugfs.c   |  28 +---
 .../wireless/mediatek/mt76/mt7996/debugfs.c   |  28 +---
 drivers/net/wwan/iosm/iosm_ipc_trace.c        |  24 +---
 drivers/net/wwan/t7xx/t7xx_port_trace.c       |  21 +--
 include/linux/relay.h                         |  47 +-----
 kernel/relay.c                                | 127 ++--------------
 kernel/trace/blktrace.c                       |  21 +--
 12 files changed, 64 insertions(+), 492 deletions(-)

diff --git a/Documentation/filesystems/relay.rst b/Documentation/filesystems/relay.rst
index 04ad083cfe62..222b9dbbbbff 100644
--- a/Documentation/filesystems/relay.rst
+++ b/Documentation/filesystems/relay.rst
@@ -15,8 +15,8 @@ clients write into the channel buffers using efficient write
 functions; these automatically log into the current cpu's channel
 buffer.  User space applications mmap() or read() from the relay files
 and retrieve the data as it becomes available.  The relay files
-themselves are files created in a host filesystem, e.g. debugfs, and
-are associated with the channel buffers using the API described below.
+themselves are files created in debugfs, andare associated with the
+channel buffers using the API described below.
 
 The format of the data logged into the channel buffers is completely
 up to the kernel client; the relay interface does however provide
@@ -142,17 +142,16 @@ close()     decrements the channel buffer's refcount.  When the refcount
 	    buffer open, the channel buffer is freed.
 =========== ============================================================
 
-In order for a user application to make use of relay files, the
-host filesystem must be mounted.  For example::
+In order for a user application to make use of relay files, debugfs must
+be mounted. For example::
 
 	mount -t debugfs debugfs /sys/kernel/debug
 
 .. Note::
 
-	the host filesystem doesn't need to be mounted for kernel
-	clients to create or use channels - it only needs to be
-	mounted when user space applications need access to the buffer
-	data.
+	debugfs doesn't need to be mounted for kernel clients to create
+	or use channels - it only needs to be mounted when user space
+	applications need access to the buffer data.
 
 
 The relay interface kernel API
@@ -184,8 +183,6 @@ TBD(curr. line MT:/API/)
     subbuf_start(buf, subbuf, prev_subbuf, prev_padding)
     buf_mapped(buf, filp)
     buf_unmapped(buf, filp)
-    create_buf_file(filename, parent, mode, buf, is_global)
-    remove_buf_file(dentry)
 
   helper functions::
 
@@ -196,72 +193,20 @@ TBD(curr. line MT:/API/)
 Creating a channel
 ------------------
 
-relay_open() is used to create a channel, along with its per-cpu
-channel buffers.  Each channel buffer will have an associated file
-created for it in the host filesystem, which can be and mmapped or
-read from in user space.  The files are named basename0...basenameN-1
-where N is the number of online cpus, and by default will be created
-in the root of the filesystem (if the parent param is NULL).  If you
-want a directory structure to contain your relay files, you should
-create it using the host filesystem's directory creation function,
-e.g. debugfs_create_dir(), and pass the parent directory to
-relay_open().  Users are responsible for cleaning up any directory
-structure they create, when the channel is closed - again the host
-filesystem's directory removal functions should be used for that,
-e.g. debugfs_remove().
-
-In order for a channel to be created and the host filesystem's files
-associated with its channel buffers, the user must provide definitions
-for two callback functions, create_buf_file() and remove_buf_file().
-create_buf_file() is called once for each per-cpu buffer from
-relay_open() and allows the user to create the file which will be used
-to represent the corresponding channel buffer.  The callback should
-return the dentry of the file created to represent the channel buffer.
-remove_buf_file() must also be defined; it's responsible for deleting
-the file(s) created in create_buf_file() and is called during
-relay_close().
-
-Here are some typical definitions for these callbacks, in this case
-using debugfs::
-
-    /*
-    * create_buf_file() callback.  Creates relay file in debugfs.
-    */
-    static struct dentry *create_buf_file_handler(const char *filename,
-						struct dentry *parent,
-						umode_t mode,
-						struct rchan_buf *buf,
-						int *is_global)
-    {
-	    return debugfs_create_file(filename, mode, parent, buf,
-				    &relay_file_operations);
-    }
-
-    /*
-    * remove_buf_file() callback.  Removes relay file from debugfs.
-    */
-    static int remove_buf_file_handler(struct dentry *dentry)
-    {
-	    debugfs_remove(dentry);
-
-	    return 0;
-    }
+relay_open() is used to create a channel, along with its per-cpu channel
+buffers. Each channel buffer will have an associated file created for it
+in debugfs, which can be and mmapped or read from in user space. The
+files are named basename0...basenameN-1 where N is the number of online
+cpus, and by will be created under the directory specified by the parent
+param.
 
-    /*
-    * relay interface callbacks
-    */
-    static struct rchan_callbacks relay_callbacks =
-    {
-	    .create_buf_file = create_buf_file_handler,
-	    .remove_buf_file = remove_buf_file_handler,
-    };
-
-And an example relay_open() invocation using them::
-
-  chan = relay_open("cpu", NULL, SUBBUF_SIZE, N_SUBBUFS, &relay_callbacks, NULL);
+In order for a channel to be created, the user must specify the
+file_operations for the associated debugfs files. A debugfs file is
+created once for each per-cpu buffer from relay_open(), using the given
+file_operations.
 
-If the create_buf_file() callback fails, or isn't defined, channel
-creation and thus relay_open() will fail.
+If file_ops isn't defined, channel creation and thus relay_open() will
+fail.
 
 The total size of each per-cpu buffer is calculated by multiplying the
 number of sub-buffers by the sub-buffer size passed into relay_open().
@@ -277,39 +222,24 @@ though, it's safe to assume that having only 1 sub-buffer is a bad
 idea - you're guaranteed to either overwrite data or lose events
 depending on the channel mode being used.
 
-The create_buf_file() implementation can also be defined in such a way
-as to allow the creation of a single 'global' buffer instead of the
-default per-cpu set.  This can be useful for applications interested
-mainly in seeing the relative ordering of system-wide events without
-the need to bother with saving explicit timestamps for the purpose of
+relay also supports the creation of a single 'global' buffer instead of
+the default per-cpu set. This can be useful for applications interested
+mainly in seeing the relative ordering of system-wide events without the
+need to bother with saving explicit timestamps for the purpose of
 merging/sorting per-cpu files in a postprocessing step.
 
-To have relay_open() create a global buffer, the create_buf_file()
-implementation should set the value of the is_global outparam to a
-non-zero value in addition to creating the file that will be used to
-represent the single buffer.  In the case of a global buffer,
-create_buf_file() and remove_buf_file() will be called only once.  The
-normal channel-writing functions, e.g. relay_write(), can still be
-used - writes from any cpu will transparently end up in the global
-buffer - but since it is a global buffer, callers should make sure
-they use the proper locking for such a buffer, either by wrapping
-writes in a spinlock, or by copying a write function from relay.h and
-creating a local version that internally does the proper locking.
+To create a global buffer, the is_global value in rchan_callbacks should
+be set to a non-zero value. The normal channel-writing functions, e.g.
+relay_write(), can still be used - writes from any cpu will
+transparently end up in the global buffer - but since it is a global
+buffer, callers should make sure they use the proper locking for such a
+buffer, either by wrapping writes in a spinlock, or by copying a write
+function from relay.h and creating a local version that internally does
+the proper locking.
 
 The private_data passed into relay_open() allows clients to associate
-user-defined data with a channel, and is immediately available
-(including in create_buf_file()) via chan->private_data or
-buf->chan->private_data.
-
-Buffer-only channels
---------------------
-
-These channels have no files associated and can be created with
-relay_open(NULL, NULL, ...). Such channels are useful in scenarios such
-as when doing early tracing in the kernel, before the VFS is up. In these
-cases, one may open a buffer-only channel and then call
-relay_late_setup_files() when the kernel is ready to handle files,
-to expose the buffered data to the userspace.
+user-defined data with a channel, and is immediately available via
+chan->private_data or buf->chan->private_data.
 
 Channel 'modes'
 ---------------
diff --git a/drivers/gpu/drm/i915/gt/uc/intel_guc_log.c b/drivers/gpu/drm/i915/gt/uc/intel_guc_log.c
index e8a04e476c57..af6c310472b1 100644
--- a/drivers/gpu/drm/i915/gt/uc/intel_guc_log.c
+++ b/drivers/gpu/drm/i915/gt/uc/intel_guc_log.c
@@ -239,50 +239,11 @@ static int subbuf_start_callback(struct rchan_buf *buf,
 	return 1;
 }
 
-/*
- * file_create() callback. Creates relay file in debugfs.
- */
-static struct dentry *create_buf_file_callback(const char *filename,
-					       struct dentry *parent,
-					       umode_t mode,
-					       struct rchan_buf *buf,
-					       int *is_global)
-{
-	struct dentry *buf_file;
-
-	/*
-	 * This to enable the use of a single buffer for the relay channel and
-	 * correspondingly have a single file exposed to User, through which
-	 * it can collect the logs in order without any post-processing.
-	 * Need to set 'is_global' even if parent is NULL for early logging.
-	 */
-	*is_global = 1;
-
-	if (!parent)
-		return NULL;
-
-	buf_file = debugfs_create_file(filename, mode,
-				       parent, buf, &relay_file_operations);
-	if (IS_ERR(buf_file))
-		return NULL;
-
-	return buf_file;
-}
-
-/*
- * file_remove() default callback. Removes relay file in debugfs.
- */
-static int remove_buf_file_callback(struct dentry *dentry)
-{
-	debugfs_remove(dentry);
-	return 0;
-}
-
 /* relay channel callbacks */
 static const struct rchan_callbacks relay_callbacks = {
 	.subbuf_start = subbuf_start_callback,
-	.create_buf_file = create_buf_file_callback,
-	.remove_buf_file = remove_buf_file_callback,
+	.file_ops = &relay_file_operations,
+	.is_global = 1,
 };
 
 static void guc_move_to_next_buf(struct intel_guc_log *log)
diff --git a/drivers/net/wireless/ath/ath10k/spectral.c b/drivers/net/wireless/ath/ath10k/spectral.c
index 2240994390ed..bb3320f784ed 100644
--- a/drivers/net/wireless/ath/ath10k/spectral.c
+++ b/drivers/net/wireless/ath/ath10k/spectral.c
@@ -463,33 +463,9 @@ static const struct file_operations fops_spectral_bins = {
 	.llseek = default_llseek,
 };
 
-static struct dentry *create_buf_file_handler(const char *filename,
-					      struct dentry *parent,
-					      umode_t mode,
-					      struct rchan_buf *buf,
-					      int *is_global)
-{
-	struct dentry *buf_file;
-
-	buf_file = debugfs_create_file(filename, mode, parent, buf,
-				       &relay_file_operations);
-	if (IS_ERR(buf_file))
-		return NULL;
-
-	*is_global = 1;
-	return buf_file;
-}
-
-static int remove_buf_file_handler(struct dentry *dentry)
-{
-	debugfs_remove(dentry);
-
-	return 0;
-}
-
 static const struct rchan_callbacks rfs_spec_scan_cb = {
-	.create_buf_file = create_buf_file_handler,
-	.remove_buf_file = remove_buf_file_handler,
+	.file_ops = &relay_file_operations,
+	.is_global = 1,
 };
 
 int ath10k_spectral_start(struct ath10k *ar)
diff --git a/drivers/net/wireless/ath/ath11k/spectral.c b/drivers/net/wireless/ath/ath11k/spectral.c
index 79e091134515..377621f9f41e 100644
--- a/drivers/net/wireless/ath/ath11k/spectral.c
+++ b/drivers/net/wireless/ath/ath11k/spectral.c
@@ -127,30 +127,9 @@ struct ath11k_spectral_search_report {
 	u8 rel_pwr_db;
 };
 
-static struct dentry *create_buf_file_handler(const char *filename,
-					      struct dentry *parent,
-					      umode_t mode,
-					      struct rchan_buf *buf,
-					      int *is_global)
-{
-	struct dentry *buf_file;
-
-	buf_file = debugfs_create_file(filename, mode, parent, buf,
-				       &relay_file_operations);
-	*is_global = 1;
-	return buf_file;
-}
-
-static int remove_buf_file_handler(struct dentry *dentry)
-{
-	debugfs_remove(dentry);
-
-	return 0;
-}
-
 static const struct rchan_callbacks rfs_scan_cb = {
-	.create_buf_file = create_buf_file_handler,
-	.remove_buf_file = remove_buf_file_handler,
+	.file_ops = &relay_file_operations,
+	.is_global = 1,
 };
 
 static struct ath11k_vif *ath11k_spectral_get_vdev(struct ath11k *ar)
diff --git a/drivers/net/wireless/ath/ath9k/common-spectral.c b/drivers/net/wireless/ath/ath9k/common-spectral.c
index 628eeec4b82f..da5557ba6c93 100644
--- a/drivers/net/wireless/ath/ath9k/common-spectral.c
+++ b/drivers/net/wireless/ath/ath9k/common-spectral.c
@@ -1008,33 +1008,9 @@ static const struct file_operations fops_spectral_fft_period = {
 /* Relay interface */
 /*******************/
 
-static struct dentry *create_buf_file_handler(const char *filename,
-					      struct dentry *parent,
-					      umode_t mode,
-					      struct rchan_buf *buf,
-					      int *is_global)
-{
-	struct dentry *buf_file;
-
-	buf_file = debugfs_create_file(filename, mode, parent, buf,
-				       &relay_file_operations);
-	if (IS_ERR(buf_file))
-		return NULL;
-
-	*is_global = 1;
-	return buf_file;
-}
-
-static int remove_buf_file_handler(struct dentry *dentry)
-{
-	debugfs_remove(dentry);
-
-	return 0;
-}
-
 static const struct rchan_callbacks rfs_spec_scan_cb = {
-	.create_buf_file = create_buf_file_handler,
-	.remove_buf_file = remove_buf_file_handler,
+	.file_ops = &relay_file_operations,
+	.is_global = 1,
 };
 
 /*********************/
diff --git a/drivers/net/wireless/mediatek/mt76/mt7915/debugfs.c b/drivers/net/wireless/mediatek/mt76/mt7915/debugfs.c
index 578013884e43..bd1ffae023ac 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7915/debugfs.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7915/debugfs.c
@@ -582,36 +582,12 @@ mt7915_fw_debug_wa_get(void *data, u64 *val)
 DEFINE_DEBUGFS_ATTRIBUTE(fops_fw_debug_wa, mt7915_fw_debug_wa_get,
 			 mt7915_fw_debug_wa_set, "%lld\n");
 
-static struct dentry *
-create_buf_file_cb(const char *filename, struct dentry *parent, umode_t mode,
-		   struct rchan_buf *buf, int *is_global)
-{
-	struct dentry *f;
-
-	f = debugfs_create_file("fwlog_data", mode, parent, buf,
-				&relay_file_operations);
-	if (IS_ERR(f))
-		return NULL;
-
-	*is_global = 1;
-
-	return f;
-}
-
-static int
-remove_buf_file_cb(struct dentry *f)
-{
-	debugfs_remove(f);
-
-	return 0;
-}
-
 static int
 mt7915_fw_debug_bin_set(void *data, u64 val)
 {
 	static struct rchan_callbacks relay_cb = {
-		.create_buf_file = create_buf_file_cb,
-		.remove_buf_file = remove_buf_file_cb,
+		.file_ops = &relay_file_operations,
+		.is_global = 1,
 	};
 	struct mt7915_dev *dev = data;
 
diff --git a/drivers/net/wireless/mediatek/mt76/mt7996/debugfs.c b/drivers/net/wireless/mediatek/mt76/mt7996/debugfs.c
index 7b2bb72b407d..9e4a9aff5234 100644
--- a/drivers/net/wireless/mediatek/mt76/mt7996/debugfs.c
+++ b/drivers/net/wireless/mediatek/mt76/mt7996/debugfs.c
@@ -375,36 +375,12 @@ mt7996_fw_debug_wa_get(void *data, u64 *val)
 DEFINE_DEBUGFS_ATTRIBUTE(fops_fw_debug_wa, mt7996_fw_debug_wa_get,
 			 mt7996_fw_debug_wa_set, "%lld\n");
 
-static struct dentry *
-create_buf_file_cb(const char *filename, struct dentry *parent, umode_t mode,
-		   struct rchan_buf *buf, int *is_global)
-{
-	struct dentry *f;
-
-	f = debugfs_create_file("fwlog_data", mode, parent, buf,
-				&relay_file_operations);
-	if (IS_ERR(f))
-		return NULL;
-
-	*is_global = 1;
-
-	return f;
-}
-
-static int
-remove_buf_file_cb(struct dentry *f)
-{
-	debugfs_remove(f);
-
-	return 0;
-}
-
 static int
 mt7996_fw_debug_bin_set(void *data, u64 val)
 {
 	static struct rchan_callbacks relay_cb = {
-		.create_buf_file = create_buf_file_cb,
-		.remove_buf_file = remove_buf_file_cb,
+		.file_ops = &relay_file_operations,
+		.is_global = 1,
 	};
 	struct mt7996_dev *dev = data;
 
diff --git a/drivers/net/wwan/iosm/iosm_ipc_trace.c b/drivers/net/wwan/iosm/iosm_ipc_trace.c
index eeecfa3d10c5..51b7d3c55251 100644
--- a/drivers/net/wwan/iosm/iosm_ipc_trace.c
+++ b/drivers/net/wwan/iosm/iosm_ipc_trace.c
@@ -30,26 +30,6 @@ void ipc_trace_port_rx(struct iosm_imem *ipc_imem, struct sk_buff *skb)
 	dev_kfree_skb(skb);
 }
 
-/* Creates relay file in debugfs. */
-static struct dentry *
-ipc_trace_create_buf_file_handler(const char *filename,
-				  struct dentry *parent,
-				  umode_t mode,
-				  struct rchan_buf *buf,
-				  int *is_global)
-{
-	*is_global = 1;
-	return debugfs_create_file(filename, mode, parent, buf,
-				   &relay_file_operations);
-}
-
-/* Removes relay file from debugfs. */
-static int ipc_trace_remove_buf_file_handler(struct dentry *dentry)
-{
-	debugfs_remove(dentry);
-	return 0;
-}
-
 static int ipc_trace_subbuf_start_handler(struct rchan_buf *buf, void *subbuf,
 					  void *prev_subbuf,
 					  size_t prev_padding)
@@ -65,8 +45,8 @@ static int ipc_trace_subbuf_start_handler(struct rchan_buf *buf, void *subbuf,
 /* Relay interface callbacks */
 static struct rchan_callbacks relay_callbacks = {
 	.subbuf_start = ipc_trace_subbuf_start_handler,
-	.create_buf_file = ipc_trace_create_buf_file_handler,
-	.remove_buf_file = ipc_trace_remove_buf_file_handler,
+	.file_ops = &relay_file_operations,
+	.is_global = 1,
 };
 
 /* Copy the trace control mode to user buffer */
diff --git a/drivers/net/wwan/t7xx/t7xx_port_trace.c b/drivers/net/wwan/t7xx/t7xx_port_trace.c
index 4ed8b4e29bf1..211279818ae6 100644
--- a/drivers/net/wwan/t7xx/t7xx_port_trace.c
+++ b/drivers/net/wwan/t7xx/t7xx_port_trace.c
@@ -15,23 +15,6 @@
 #define T7XX_TRC_SUB_BUFF_SIZE		131072
 #define T7XX_TRC_N_SUB_BUFF		32
 
-static struct dentry *t7xx_trace_create_buf_file_handler(const char *filename,
-							 struct dentry *parent,
-							 umode_t mode,
-							 struct rchan_buf *buf,
-							 int *is_global)
-{
-	*is_global = 1;
-	return debugfs_create_file(filename, mode, parent, buf,
-				   &relay_file_operations);
-}
-
-static int t7xx_trace_remove_buf_file_handler(struct dentry *dentry)
-{
-	debugfs_remove(dentry);
-	return 0;
-}
-
 static int t7xx_trace_subbuf_start_handler(struct rchan_buf *buf, void *subbuf,
 					   void *prev_subbuf, size_t prev_padding)
 {
@@ -45,8 +28,8 @@ static int t7xx_trace_subbuf_start_handler(struct rchan_buf *buf, void *subbuf,
 
 static struct rchan_callbacks relay_callbacks = {
 	.subbuf_start = t7xx_trace_subbuf_start_handler,
-	.create_buf_file = t7xx_trace_create_buf_file_handler,
-	.remove_buf_file = t7xx_trace_remove_buf_file_handler,
+	.file_ops = &relay_file_operations,
+	.is_global = 1,
 };
 
 static void t7xx_trace_port_uninit(struct t7xx_port *port)
diff --git a/include/linux/relay.h b/include/linux/relay.h
index 72b876dd5cb8..138a28539ba5 100644
--- a/include/linux/relay.h
+++ b/include/linux/relay.h
@@ -104,49 +104,14 @@ struct rchan_callbacks
 			     size_t prev_padding);
 
 	/*
-	 * create_buf_file - create file to represent a relay channel buffer
-	 * @filename: the name of the file to create
-	 * @parent: the parent of the file to create
-	 * @mode: the mode of the file to create
-	 * @buf: the channel buffer
-	 * @is_global: outparam - set non-zero if the buffer should be global
-	 *
-	 * Called during relay_open(), once for each per-cpu buffer,
-	 * to allow the client to create a file to be used to
-	 * represent the corresponding channel buffer.  If the file is
-	 * created outside of relay, the parent must also exist in
-	 * that filesystem.
-	 *
-	 * The callback should return the dentry of the file created
-	 * to represent the relay buffer.
-	 *
-	 * Setting the is_global outparam to a non-zero value will
-	 * cause relay_open() to create a single global buffer rather
-	 * than the default set of per-cpu buffers.
-	 *
-	 * This callback is mandatory.
-	 *
-	 * See Documentation/filesystems/relay.rst for more info.
+	 * file_ops - file operations for the relay file
 	 */
-	struct dentry *(*create_buf_file)(const char *filename,
-					  struct dentry *parent,
-					  umode_t mode,
-					  struct rchan_buf *buf,
-					  int *is_global);
+	const struct file_operations *file_ops;
 
 	/*
-	 * remove_buf_file - remove file representing a relay channel buffer
-	 * @dentry: the dentry of the file to remove
-	 *
-	 * Called during relay_close(), once for each per-cpu buffer,
-	 * to allow the client to remove a file used to represent a
-	 * channel buffer.
-	 *
-	 * The callback should return 0 if successful, negative if not.
-	 *
-	 * This callback is mandatory.
+	 * is_global - create a single global buffer rather than per-cpu buffers
 	 */
-	int (*remove_buf_file)(struct dentry *dentry);
+	int is_global;
 };
 
 /*
@@ -159,9 +124,6 @@ struct rchan *relay_open(const char *base_filename,
 			 size_t n_subbufs,
 			 const struct rchan_callbacks *cb,
 			 void *private_data);
-extern int relay_late_setup_files(struct rchan *chan,
-				  const char *base_filename,
-				  struct dentry *parent);
 extern void relay_close(struct rchan *chan);
 extern void relay_flush(struct rchan *chan);
 extern void relay_subbufs_consumed(struct rchan *chan,
@@ -284,4 +246,3 @@ int relay_prepare_cpu(unsigned int cpu);
 #endif
 
 #endif /* _LINUX_RELAY_H */
-
diff --git a/kernel/relay.c b/kernel/relay.c
index a8ae436dc77e..49bc5ec83025 100644
--- a/kernel/relay.c
+++ b/kernel/relay.c
@@ -22,6 +22,7 @@
 #include <linux/mm.h>
 #include <linux/cpu.h>
 #include <linux/splice.h>
+#include <linux/debugfs.h>
 
 /* list of open channels, for cpu hotplug */
 static DEFINE_MUTEX(relay_channels_mutex);
@@ -357,12 +358,14 @@ static struct dentry *relay_create_buf_file(struct rchan *chan,
 	snprintf(tmpname, NAME_MAX, "%s%d", chan->base_filename, cpu);
 
 	/* Create file in fs */
-	dentry = chan->cb->create_buf_file(tmpname, chan->parent,
-					   S_IRUSR, buf,
-					   &chan->is_global);
+	dentry = debugfs_create_file(tmpname, S_IRUSR, chan->parent, buf,
+				     chan->cb->file_ops);
+
 	if (IS_ERR(dentry))
 		dentry = NULL;
 
+	chan->is_global = chan->cb->is_global;
+
 	kfree(tmpname);
 
 	return dentry;
@@ -392,9 +395,8 @@ static struct rchan_buf *relay_open_buf(struct rchan *chan, unsigned int cpu)
 		relay_set_buf_dentry(buf, dentry);
 	} else {
 		/* Only retrieve global info, nothing more, nothing less */
-		dentry = chan->cb->create_buf_file(NULL, NULL,
-						   S_IRUSR, buf,
-						   &chan->is_global);
+		dentry = debugfs_create_file(NULL, S_IRUSR, NULL, buf,
+					     chan->cb->file_ops);
 		if (IS_ERR_OR_NULL(dentry))
 			goto free_buf;
 	}
@@ -426,7 +428,7 @@ static void relay_close_buf(struct rchan_buf *buf)
 {
 	buf->finalized = 1;
 	irq_work_sync(&buf->wakeup_work);
-	buf->chan->cb->remove_buf_file(buf->dentry);
+	debugfs_remove(buf->dentry);
 	kref_put(&buf->kref, relay_remove_buf);
 }
 
@@ -466,10 +468,6 @@ int relay_prepare_cpu(unsigned int cpu)
  *	attributes specified.  The created channel buffer files
  *	will be named base_filename0...base_filenameN-1.  File
  *	permissions will be %S_IRUSR.
- *
- *	If opening a buffer (@parent = NULL) that you later wish to register
- *	in a filesystem, call relay_late_setup_files() once the @parent dentry
- *	is available.
  */
 struct rchan *relay_open(const char *base_filename,
 			 struct dentry *parent,
@@ -486,7 +484,7 @@ struct rchan *relay_open(const char *base_filename,
 		return NULL;
 	if (subbuf_size > UINT_MAX / n_subbufs)
 		return NULL;
-	if (!cb || !cb->create_buf_file || !cb->remove_buf_file)
+	if (!cb || !cb->file_ops)
 		return NULL;
 
 	chan = kzalloc(sizeof(struct rchan), GFP_KERNEL);
@@ -541,111 +539,6 @@ struct rchan_percpu_buf_dispatcher {
 	struct dentry *dentry;
 };
 
-/* Called in atomic context. */
-static void __relay_set_buf_dentry(void *info)
-{
-	struct rchan_percpu_buf_dispatcher *p = info;
-
-	relay_set_buf_dentry(p->buf, p->dentry);
-}
-
-/**
- *	relay_late_setup_files - triggers file creation
- *	@chan: channel to operate on
- *	@base_filename: base name of files to create
- *	@parent: dentry of parent directory, %NULL for root directory
- *
- *	Returns 0 if successful, non-zero otherwise.
- *
- *	Use to setup files for a previously buffer-only channel created
- *	by relay_open() with a NULL parent dentry.
- *
- *	For example, this is useful for perfomring early tracing in kernel,
- *	before VFS is up and then exposing the early results once the dentry
- *	is available.
- */
-int relay_late_setup_files(struct rchan *chan,
-			   const char *base_filename,
-			   struct dentry *parent)
-{
-	int err = 0;
-	unsigned int i, curr_cpu;
-	unsigned long flags;
-	struct dentry *dentry;
-	struct rchan_buf *buf;
-	struct rchan_percpu_buf_dispatcher disp;
-
-	if (!chan || !base_filename)
-		return -EINVAL;
-
-	strscpy(chan->base_filename, base_filename, NAME_MAX);
-
-	mutex_lock(&relay_channels_mutex);
-	/* Is chan already set up? */
-	if (unlikely(chan->has_base_filename)) {
-		mutex_unlock(&relay_channels_mutex);
-		return -EEXIST;
-	}
-	chan->has_base_filename = 1;
-	chan->parent = parent;
-
-	if (chan->is_global) {
-		err = -EINVAL;
-		buf = *per_cpu_ptr(chan->buf, 0);
-		if (!WARN_ON_ONCE(!buf)) {
-			dentry = relay_create_buf_file(chan, buf, 0);
-			if (dentry && !WARN_ON_ONCE(!chan->is_global)) {
-				relay_set_buf_dentry(buf, dentry);
-				err = 0;
-			}
-		}
-		mutex_unlock(&relay_channels_mutex);
-		return err;
-	}
-
-	curr_cpu = get_cpu();
-	/*
-	 * The CPU hotplug notifier ran before us and created buffers with
-	 * no files associated. So it's safe to call relay_setup_buf_file()
-	 * on all currently online CPUs.
-	 */
-	for_each_online_cpu(i) {
-		buf = *per_cpu_ptr(chan->buf, i);
-		if (unlikely(!buf)) {
-			WARN_ONCE(1, KERN_ERR "CPU has no buffer!\n");
-			err = -EINVAL;
-			break;
-		}
-
-		dentry = relay_create_buf_file(chan, buf, i);
-		if (unlikely(!dentry)) {
-			err = -EINVAL;
-			break;
-		}
-
-		if (curr_cpu == i) {
-			local_irq_save(flags);
-			relay_set_buf_dentry(buf, dentry);
-			local_irq_restore(flags);
-		} else {
-			disp.buf = buf;
-			disp.dentry = dentry;
-			smp_mb();
-			/* relay_channels_mutex must be held, so wait. */
-			err = smp_call_function_single(i,
-						       __relay_set_buf_dentry,
-						       &disp, 1);
-		}
-		if (unlikely(err))
-			break;
-	}
-	put_cpu();
-	mutex_unlock(&relay_channels_mutex);
-
-	return err;
-}
-EXPORT_SYMBOL_GPL(relay_late_setup_files);
-
 /**
  *	relay_switch_subbuf - switch to a new sub-buffer
  *	@buf: channel buffer
diff --git a/kernel/trace/blktrace.c b/kernel/trace/blktrace.c
index 3679a6d18934..a4dca02bfabc 100644
--- a/kernel/trace/blktrace.c
+++ b/kernel/trace/blktrace.c
@@ -473,27 +473,9 @@ static int blk_subbuf_start_callback(struct rchan_buf *buf, void *subbuf,
 	return 0;
 }
 
-static int blk_remove_buf_file_callback(struct dentry *dentry)
-{
-	debugfs_remove(dentry);
-
-	return 0;
-}
-
-static struct dentry *blk_create_buf_file_callback(const char *filename,
-						   struct dentry *parent,
-						   umode_t mode,
-						   struct rchan_buf *buf,
-						   int *is_global)
-{
-	return debugfs_create_file(filename, mode, parent, buf,
-					&relay_file_operations);
-}
-
 static const struct rchan_callbacks blk_relay_callbacks = {
 	.subbuf_start		= blk_subbuf_start_callback,
-	.create_buf_file	= blk_create_buf_file_callback,
-	.remove_buf_file	= blk_remove_buf_file_callback,
+	.file_ops		= &relay_file_operations,
 };
 
 static void blk_trace_setup_lba(struct blk_trace *bt,
@@ -1902,4 +1884,3 @@ void blk_fill_rwbs(char *rwbs, blk_opf_t opf)
 EXPORT_SYMBOL_GPL(blk_fill_rwbs);
 
 #endif /* CONFIG_EVENT_TRACING */
-

base-commit: a64dcfb451e254085a7daee5fe51bf22959d52d3
