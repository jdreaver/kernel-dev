From bdc4ca114ce02b5c7aa23dee1a7aad41f6cc1da6 Mon Sep 17 00:00:00 2001
From: David Reaver <me@davidreaver.com>
Date: Tue, 28 Jan 2025 13:53:41 -0800
Subject: [PATCH 1/1] debugfs: Use opaque debugfs_node handle to support kernfs
 migration
To: Steven Rostedt <rostedt@goodmis.org>,
    Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Cc: Tejun Heo <tj@kernel.org>,
    Christian Brauner <brauner@kernel.org>,
    linux-fsdevel@vger.kernel.org,
    linux-kernel@vger.kernel.org

Signed-off-by: David Reaver <me@davidreaver.com>
---
 arch/powerpc/kernel/kdebugfs.c            |   2 +-
 arch/s390/kernel/kdebugfs.c               |   2 +-
 arch/sh/kernel/kdebugfs.c                 |   2 +-
 arch/x86/kernel/cpu/debugfs.c             |   2 +-
 arch/x86/kernel/kdebugfs.c                |  12 +-
 arch/x86/kvm/debugfs.c                    |   2 +-
 arch/x86/mm/debug_pagetables.c            |   2 +-
 arch/x86/platform/atom/punit_atom_debug.c |   2 +-
 arch/x86/platform/intel/iosf_mbi.c        |   2 +-
 arch/x86/xen/debugfs.c                    |   5 +-
 arch/x86/xen/p2m.c                        |   4 +-
 arch/x86/xen/xen-ops.h                    |   2 +-
 block/blk-core.c                          |   6 +-
 block/blk-timeout.c                       |   2 +-
 block/blk.h                               |   2 +-
 drivers/acpi/debugfs.c                    |   2 +-
 drivers/acpi/internal.h                   |   2 +-
 drivers/base/component.c                  |   2 +-
 drivers/bus/mhi/host/debugfs.c            |   2 +-
 drivers/bus/moxtet.c                      |   2 +-
 drivers/char/virtio_console.c             |   4 +-
 drivers/dma/dmaengine.c                   |   2 +-
 drivers/dma/dmaengine.h                   |   2 +-
 drivers/gpu/drm/drm_drv.c                 |   2 +-
 drivers/misc/mei/mei_dev.h                |   2 +-
 drivers/phy/phy-core.c                    |   2 +-
 drivers/pinctrl/core.c                    |   4 +-
 drivers/pinctrl/core.h                    |   2 +-
 drivers/pinctrl/pinconf.c                 |   2 +-
 drivers/pinctrl/pinconf.h                 |   4 +-
 drivers/pinctrl/pinmux.c                  |   2 +-
 drivers/pinctrl/pinmux.h                  |   5 +-
 fs/debugfs/file.c                         | 192 +++++++++++----------
 fs/debugfs/inode.c                        | 142 ++++++++++------
 include/linux/backing-dev-defs.h          |   3 +-
 include/linux/blkdev.h                    |   6 +-
 include/linux/debugfs.h                   | 194 ++++++++++++----------
 include/linux/dmaengine.h                 |   2 +-
 include/linux/fault-inject.h              |  10 +-
 include/linux/kvm_host.h                  |   4 +-
 include/linux/mhi.h                       |   2 +-
 include/linux/moxtet.h                    |   2 +-
 include/linux/phy/phy.h                   |   2 +-
 include/net/cfg80211.h                    |   2 +-
 include/sound/core.h                      |   4 +-
 lib/fault-inject.c                        |  12 +-
 mm/backing-dev.c                          |   2 +-
 mm/vmstat.c                               |   2 +-
 net/wireless/core.c                       |   2 +-
 net/wireless/debugfs.c                    |   2 +-
 sound/core/init.c                         |   4 +-
 sound/core/jack.c                         |   2 +-
 sound/core/sound.c                        |   2 +-
 sound/drivers/pcmtest.c                   |   2 +-
 virt/kvm/kvm_main.c                       |  10 +-
 55 files changed, 386 insertions(+), 311 deletions(-)

diff --git a/arch/powerpc/kernel/kdebugfs.c b/arch/powerpc/kernel/kdebugfs.c
index 36d3124d5a8b..58c4c39ddf59 100644
--- a/arch/powerpc/kernel/kdebugfs.c
+++ b/arch/powerpc/kernel/kdebugfs.c
@@ -3,7 +3,7 @@
 #include <linux/export.h>
 #include <linux/init.h>
 
-struct dentry *arch_debugfs_dir;
+struct debugfs_node *arch_debugfs_dir;
 EXPORT_SYMBOL(arch_debugfs_dir);
 
 static int __init arch_kdebugfs_init(void)
diff --git a/arch/s390/kernel/kdebugfs.c b/arch/s390/kernel/kdebugfs.c
index 33130c7daf55..43a72fcec375 100644
--- a/arch/s390/kernel/kdebugfs.c
+++ b/arch/s390/kernel/kdebugfs.c
@@ -3,7 +3,7 @@
 #include <linux/export.h>
 #include <linux/init.h>
 
-struct dentry *arch_debugfs_dir;
+struct debugfs_node *arch_debugfs_dir;
 EXPORT_SYMBOL(arch_debugfs_dir);
 
 static int __init arch_kdebugfs_init(void)
diff --git a/arch/sh/kernel/kdebugfs.c b/arch/sh/kernel/kdebugfs.c
index 8b505e1556a5..79b8b5aa9757 100644
--- a/arch/sh/kernel/kdebugfs.c
+++ b/arch/sh/kernel/kdebugfs.c
@@ -3,7 +3,7 @@
 #include <linux/init.h>
 #include <linux/debugfs.h>
 
-struct dentry *arch_debugfs_dir;
+struct debugfs_node *arch_debugfs_dir;
 EXPORT_SYMBOL(arch_debugfs_dir);
 
 static int __init arch_kdebugfs_init(void)
diff --git a/arch/x86/kernel/cpu/debugfs.c b/arch/x86/kernel/cpu/debugfs.c
index cacfd3f6abef..4d49a973466c 100644
--- a/arch/x86/kernel/cpu/debugfs.c
+++ b/arch/x86/kernel/cpu/debugfs.c
@@ -85,7 +85,7 @@ static const struct file_operations dfs_dom_ops = {
 
 static __init int cpu_init_debugfs(void)
 {
-	struct dentry *dir, *base = debugfs_create_dir("topo", arch_debugfs_dir);
+	struct debugfs_node *dir, *base = debugfs_create_dir("topo", arch_debugfs_dir);
 	unsigned long id;
 	char name[24];
 
diff --git a/arch/x86/kernel/kdebugfs.c b/arch/x86/kernel/kdebugfs.c
index e2e89bebcbc3..66b3670aca36 100644
--- a/arch/x86/kernel/kdebugfs.c
+++ b/arch/x86/kernel/kdebugfs.c
@@ -16,7 +16,7 @@
 
 #include <asm/setup.h>
 
-struct dentry *arch_debugfs_dir;
+struct debugfs_node *arch_debugfs_dir;
 EXPORT_SYMBOL(arch_debugfs_dir);
 
 #ifdef CONFIG_DEBUG_BOOT_PARAMS
@@ -73,10 +73,10 @@ static const struct file_operations fops_setup_data = {
 };
 
 static void __init
-create_setup_data_node(struct dentry *parent, int no,
+create_setup_data_node(struct debugfs_node *parent, int no,
 		       struct setup_data_node *node)
 {
-	struct dentry *d;
+	struct debugfs_node *d;
 	char buf[16];
 
 	sprintf(buf, "%d", no);
@@ -86,13 +86,13 @@ create_setup_data_node(struct dentry *parent, int no,
 	debugfs_create_file("data", S_IRUGO, d, node, &fops_setup_data);
 }
 
-static int __init create_setup_data_nodes(struct dentry *parent)
+static int __init create_setup_data_nodes(struct debugfs_node *parent)
 {
 	struct setup_indirect *indirect;
 	struct setup_data_node *node;
 	struct setup_data *data;
 	u64 pa_data, pa_next;
-	struct dentry *d;
+	struct debugfs_node *d;
 	int error;
 	u32 len;
 	int no = 0;
@@ -164,7 +164,7 @@ static struct debugfs_blob_wrapper boot_params_blob = {
 
 static int __init boot_params_kdebugfs_init(void)
 {
-	struct dentry *dbp;
+	struct debugfs_node *dbp;
 	int error;
 
 	dbp = debugfs_create_dir("boot_params", arch_debugfs_dir);
diff --git a/arch/x86/kvm/debugfs.c b/arch/x86/kvm/debugfs.c
index 999227fc7c66..38473c744e83 100644
--- a/arch/x86/kvm/debugfs.c
+++ b/arch/x86/kvm/debugfs.c
@@ -56,7 +56,7 @@ static int vcpu_get_tsc_scaling_frac_bits(void *data, u64 *val)
 
 DEFINE_SIMPLE_ATTRIBUTE(vcpu_tsc_scaling_frac_fops, vcpu_get_tsc_scaling_frac_bits, NULL, "%llu\n");
 
-void kvm_arch_create_vcpu_debugfs(struct kvm_vcpu *vcpu, struct dentry *debugfs_dentry)
+void kvm_arch_create_vcpu_debugfs(struct kvm_vcpu *vcpu, struct debugfs_node *debugfs_dentry)
 {
 	debugfs_create_file("guest_mode", 0444, debugfs_dentry, vcpu,
 			    &vcpu_guest_mode_fops);
diff --git a/arch/x86/mm/debug_pagetables.c b/arch/x86/mm/debug_pagetables.c
index ae5c213a1cb0..0f797bda55f3 100644
--- a/arch/x86/mm/debug_pagetables.c
+++ b/arch/x86/mm/debug_pagetables.c
@@ -44,7 +44,7 @@ static int ptdump_efi_show(struct seq_file *m, void *v)
 DEFINE_SHOW_ATTRIBUTE(ptdump_efi);
 #endif
 
-static struct dentry *dir;
+static struct debugfs_node *dir;
 
 static int __init pt_dump_debug_init(void)
 {
diff --git a/arch/x86/platform/atom/punit_atom_debug.c b/arch/x86/platform/atom/punit_atom_debug.c
index 44c30ce6360a..6b44b5ee316f 100644
--- a/arch/x86/platform/atom/punit_atom_debug.c
+++ b/arch/x86/platform/atom/punit_atom_debug.c
@@ -105,7 +105,7 @@ static int punit_dev_state_show(struct seq_file *seq_file, void *unused)
 }
 DEFINE_SHOW_ATTRIBUTE(punit_dev_state);
 
-static struct dentry *punit_dbg_file;
+static struct debugfs_node *punit_dbg_file;
 
 static void punit_dbgfs_register(struct punit_device *punit_device)
 {
diff --git a/arch/x86/platform/intel/iosf_mbi.c b/arch/x86/platform/intel/iosf_mbi.c
index c81cea208c2c..1d0468f19fa1 100644
--- a/arch/x86/platform/intel/iosf_mbi.c
+++ b/arch/x86/platform/intel/iosf_mbi.c
@@ -481,7 +481,7 @@ static int mcr_set(void *data, u64 val)
 }
 DEFINE_SIMPLE_ATTRIBUTE(iosf_mcr_fops, mcr_get, mcr_set , "%llx\n");
 
-static struct dentry *iosf_dbg;
+static struct debugfs_node *iosf_dbg;
 
 static void iosf_sideband_debug_init(void)
 {
diff --git a/arch/x86/xen/debugfs.c b/arch/x86/xen/debugfs.c
index b8c9f2a7d9b6..70a190e8acce 100644
--- a/arch/x86/xen/debugfs.c
+++ b/arch/x86/xen/debugfs.c
@@ -5,12 +5,11 @@
 
 #include "xen-ops.h"
 
-static struct dentry *d_xen_debug;
+static struct debugfs_node *d_xen_debug;
 
-struct dentry * __init xen_init_debugfs(void)
+struct debugfs_node * __init xen_init_debugfs(void)
 {
 	if (!d_xen_debug)
 		d_xen_debug = debugfs_create_dir("xen", NULL);
 	return d_xen_debug;
 }
-
diff --git a/arch/x86/xen/p2m.c b/arch/x86/xen/p2m.c
index 56914e21e303..74204f2c94e8 100644
--- a/arch/x86/xen/p2m.c
+++ b/arch/x86/xen/p2m.c
@@ -915,11 +915,11 @@ static int p2m_dump_show(struct seq_file *m, void *v)
 
 DEFINE_SHOW_ATTRIBUTE(p2m_dump);
 
-static struct dentry *d_mmu_debug;
+static struct debugfs_node *d_mmu_debug;
 
 static int __init xen_p2m_debugfs(void)
 {
-	struct dentry *d_xen = xen_init_debugfs();
+	struct debugfs_node *d_xen = xen_init_debugfs();
 
 	d_mmu_debug = debugfs_create_dir("mmu", d_xen);
 
diff --git a/arch/x86/xen/xen-ops.h b/arch/x86/xen/xen-ops.h
index 63c13a2ccf55..393ea778be26 100644
--- a/arch/x86/xen/xen-ops.h
+++ b/arch/x86/xen/xen-ops.h
@@ -185,7 +185,7 @@ static inline void xen_hvm_post_suspend(int suspend_cancelled) {}
 
 void xen_add_extra_mem(unsigned long start_pfn, unsigned long n_pfns);
 
-struct dentry * __init xen_init_debugfs(void);
+struct debugfs_node * __init xen_init_debugfs(void);
 
 enum pt_level {
 	PT_PGD,
diff --git a/block/blk-core.c b/block/blk-core.c
index 32fb28a6372c..6062d51d9f6b 100644
--- a/block/blk-core.c
+++ b/block/blk-core.c
@@ -51,7 +51,7 @@
 #include "blk-throttle.h"
 #include "blk-ioprio.h"
 
-struct dentry *blk_debugfs_root;
+struct debugfs_node *blk_debugfs_root;
 
 EXPORT_TRACEPOINT_SYMBOL_GPL(block_bio_remap);
 EXPORT_TRACEPOINT_SYMBOL_GPL(block_rq_remap);
@@ -504,7 +504,7 @@ bool should_fail_request(struct block_device *part, unsigned int bytes)
 
 static int __init fail_make_request_debugfs(void)
 {
-	struct dentry *dir = fault_create_debugfs_attr("fail_make_request",
+	struct debugfs_node *dir = fault_create_debugfs_attr("fail_make_request",
 						NULL, &fail_make_request);
 
 	return PTR_ERR_OR_ZERO(dir);
@@ -629,7 +629,7 @@ static void __submit_bio(struct bio *bio)
 		blk_mq_submit_bio(bio);
 	} else if (likely(bio_queue_enter(bio) == 0)) {
 		struct gendisk *disk = bio->bi_bdev->bd_disk;
-	
+
 		if ((bio->bi_opf & REQ_POLLED) &&
 		    !(disk->queue->limits.features & BLK_FEAT_POLL)) {
 			bio->bi_status = BLK_STS_NOTSUPP;
diff --git a/block/blk-timeout.c b/block/blk-timeout.c
index 1b8de0417fc1..44871fbabe27 100644
--- a/block/blk-timeout.c
+++ b/block/blk-timeout.c
@@ -28,7 +28,7 @@ EXPORT_SYMBOL_GPL(__blk_should_fake_timeout);
 
 static int __init fail_io_timeout_debugfs(void)
 {
-	struct dentry *dir = fault_create_debugfs_attr("fail_io_timeout",
+	struct debugfs_node *dir = fault_create_debugfs_attr("fail_io_timeout",
 						NULL, &fail_io_timeout);
 
 	return PTR_ERR_OR_ZERO(dir);
diff --git a/block/blk.h b/block/blk.h
index 90fa5f28ccab..7a18703f745e 100644
--- a/block/blk.h
+++ b/block/blk.h
@@ -18,7 +18,7 @@ struct elevator_type;
 /* Max future timer expiry for timeouts */
 #define BLK_MAX_TIMEOUT		(5 * HZ)
 
-extern struct dentry *blk_debugfs_root;
+extern struct debugfs_node *blk_debugfs_root;
 
 struct blk_flush_queue {
 	spinlock_t		mq_flush_lock;
diff --git a/drivers/acpi/debugfs.c b/drivers/acpi/debugfs.c
index 074eb98d213e..669a1876787b 100644
--- a/drivers/acpi/debugfs.c
+++ b/drivers/acpi/debugfs.c
@@ -10,7 +10,7 @@
 
 #include "internal.h"
 
-struct dentry *acpi_debugfs_dir;
+struct debugfs_node *acpi_debugfs_dir;
 EXPORT_SYMBOL_GPL(acpi_debugfs_dir);
 
 void __init acpi_debugfs_init(void)
diff --git a/drivers/acpi/internal.h b/drivers/acpi/internal.h
index 00910ccd7eda..2948a777b77f 100644
--- a/drivers/acpi/internal.h
+++ b/drivers/acpi/internal.h
@@ -64,7 +64,7 @@ int acpi_scan_add_handler_with_hotplug(struct acpi_scan_handler *handler,
 void acpi_scan_hotplug_enabled(struct acpi_hotplug_profile *hotplug, bool val);
 
 #ifdef CONFIG_DEBUG_FS
-extern struct dentry *acpi_debugfs_dir;
+extern struct debugfs_node *acpi_debugfs_dir;
 void acpi_debugfs_init(void);
 #else
 static inline void acpi_debugfs_init(void) { return; }
diff --git a/drivers/base/component.c b/drivers/base/component.c
index 741497324d78..70b8fba945b6 100644
--- a/drivers/base/component.c
+++ b/drivers/base/component.c
@@ -78,7 +78,7 @@ static LIST_HEAD(aggregate_devices);
 
 #ifdef CONFIG_DEBUG_FS
 
-static struct dentry *component_debugfs_dir;
+static struct debugfs_node *component_debugfs_dir;
 
 static int component_devices_show(struct seq_file *s, void *data)
 {
diff --git a/drivers/bus/mhi/host/debugfs.c b/drivers/bus/mhi/host/debugfs.c
index cfec7811dfbb..2b8b2bd18642 100644
--- a/drivers/bus/mhi/host/debugfs.c
+++ b/drivers/bus/mhi/host/debugfs.c
@@ -372,7 +372,7 @@ static const struct file_operations debugfs_timeout_ms_fops = {
 	.read = seq_read,
 };
 
-static struct dentry *mhi_debugfs_root;
+static struct debugfs_node *mhi_debugfs_root;
 
 void mhi_create_debugfs(struct mhi_controller *mhi_cntrl)
 {
diff --git a/drivers/bus/moxtet.c b/drivers/bus/moxtet.c
index 6276551d7968..e2d7fcf1d9e4 100644
--- a/drivers/bus/moxtet.c
+++ b/drivers/bus/moxtet.c
@@ -552,7 +552,7 @@ static const struct file_operations output_fops = {
 
 static int moxtet_register_debugfs(struct moxtet *moxtet)
 {
-	struct dentry *root, *entry;
+	struct debugfs_node *root, *entry;
 
 	root = debugfs_create_dir("moxtet", NULL);
 
diff --git a/drivers/char/virtio_console.c b/drivers/char/virtio_console.c
index 24442485e73e..00c5456ea17c 100644
--- a/drivers/char/virtio_console.c
+++ b/drivers/char/virtio_console.c
@@ -41,7 +41,7 @@
  */
 struct ports_driver_data {
 	/* Used for exporting per-port information to debugfs */
-	struct dentry *debugfs_dir;
+	struct debugfs_node *debugfs_dir;
 
 	/* List of all the devices we're handling */
 	struct list_head portdevs;
@@ -187,7 +187,7 @@ struct port {
 	struct virtqueue *in_vq, *out_vq;
 
 	/* File in the debugfs directory that exposes this port's information */
-	struct dentry *debugfs_file;
+	struct debugfs_node *debugfs_file;
 
 	/*
 	 * Keep count of the bytes sent, received and discarded for
diff --git a/drivers/dma/dmaengine.c b/drivers/dma/dmaengine.c
index c1357d7f3dc6..04115654b4e8 100644
--- a/drivers/dma/dmaengine.c
+++ b/drivers/dma/dmaengine.c
@@ -64,7 +64,7 @@ static long dmaengine_ref_count;
 #ifdef CONFIG_DEBUG_FS
 #include <linux/debugfs.h>
 
-static struct dentry *rootdir;
+static struct debugfs_node *rootdir;
 
 static void dmaengine_debug_register(struct dma_device *dma_dev)
 {
diff --git a/drivers/dma/dmaengine.h b/drivers/dma/dmaengine.h
index 53f16d3f0029..6ee14cd417a2 100644
--- a/drivers/dma/dmaengine.h
+++ b/drivers/dma/dmaengine.h
@@ -185,7 +185,7 @@ struct dma_chan *dma_get_any_slave_channel(struct dma_device *device);
 #ifdef CONFIG_DEBUG_FS
 #include <linux/debugfs.h>
 
-static inline struct dentry *
+static inline struct debugfs_node *
 dmaengine_get_debugfs_root(struct dma_device *dma_dev) {
 	return dma_dev->dbg_dev_root;
 }
diff --git a/drivers/gpu/drm/drm_drv.c b/drivers/gpu/drm/drm_drv.c
index 3cf440eee8a2..91400d84fadb 100644
--- a/drivers/gpu/drm/drm_drv.c
+++ b/drivers/gpu/drm/drm_drv.c
@@ -67,7 +67,7 @@ DEFINE_XARRAY_ALLOC(drm_minors_xa);
  */
 static bool drm_core_init_complete;
 
-static struct dentry *drm_debugfs_root;
+static struct debugfs_node *drm_debugfs_root;
 
 DEFINE_STATIC_SRCU(drm_unplug_srcu);
 
diff --git a/drivers/misc/mei/mei_dev.h b/drivers/misc/mei/mei_dev.h
index 37d7fb15cad7..6a6b6c3e92df 100644
--- a/drivers/misc/mei/mei_dev.h
+++ b/drivers/misc/mei/mei_dev.h
@@ -645,7 +645,7 @@ struct mei_device {
 	const char *kind;
 
 #if IS_ENABLED(CONFIG_DEBUG_FS)
-	struct dentry *dbgfs_dir;
+	struct debugfs_node *dbgfs_dir;
 #endif /* CONFIG_DEBUG_FS */
 
 	struct mei_fw_status saved_fw_status;
diff --git a/drivers/phy/phy-core.c b/drivers/phy/phy-core.c
index 413f76e2d174..45025d123ec9 100644
--- a/drivers/phy/phy-core.c
+++ b/drivers/phy/phy-core.c
@@ -26,7 +26,7 @@ static const struct class phy_class = {
 	.dev_release = phy_release,
 };
 
-static struct dentry *phy_debugfs_root;
+static struct debugfs_node *phy_debugfs_root;
 static DEFINE_MUTEX(phy_provider_mutex);
 static LIST_HEAD(phy_provider_list);
 static LIST_HEAD(phys);
diff --git a/drivers/pinctrl/core.c b/drivers/pinctrl/core.c
index 4bdbf6bb26e2..2283946acf6c 100644
--- a/drivers/pinctrl/core.c
+++ b/drivers/pinctrl/core.c
@@ -1935,11 +1935,11 @@ static int pinctrl_show(struct seq_file *s, void *what)
 }
 DEFINE_SHOW_ATTRIBUTE(pinctrl);
 
-static struct dentry *debugfs_root;
+static struct debugfs_node *debugfs_root;
 
 static void pinctrl_init_device_debugfs(struct pinctrl_dev *pctldev)
 {
-	struct dentry *device_root;
+	struct debugfs_node *device_root;
 	const char *debugfs_name;
 
 	if (pctldev->desc->name &&
diff --git a/drivers/pinctrl/core.h b/drivers/pinctrl/core.h
index d6c24978e708..36fcb2baef0b 100644
--- a/drivers/pinctrl/core.h
+++ b/drivers/pinctrl/core.h
@@ -70,7 +70,7 @@ struct pinctrl_dev {
 	struct pinctrl_state *hog_sleep;
 	struct mutex mutex;
 #ifdef CONFIG_DEBUG_FS
-	struct dentry *device_root;
+	struct debugfs_node *device_root;
 #endif
 };
 
diff --git a/drivers/pinctrl/pinconf.c b/drivers/pinctrl/pinconf.c
index dca963633b5d..c1d0894040a0 100644
--- a/drivers/pinctrl/pinconf.c
+++ b/drivers/pinctrl/pinconf.c
@@ -369,7 +369,7 @@ static int pinconf_groups_show(struct seq_file *s, void *what)
 DEFINE_SHOW_ATTRIBUTE(pinconf_pins);
 DEFINE_SHOW_ATTRIBUTE(pinconf_groups);
 
-void pinconf_init_device_debugfs(struct dentry *devroot,
+void pinconf_init_device_debugfs(struct debugfs_node *devroot,
 			 struct pinctrl_dev *pctldev)
 {
 	debugfs_create_file("pinconf-pins", 0444,
diff --git a/drivers/pinctrl/pinconf.h b/drivers/pinctrl/pinconf.h
index a14c950bc700..a1f279cf2934 100644
--- a/drivers/pinctrl/pinconf.h
+++ b/drivers/pinctrl/pinconf.h
@@ -81,7 +81,7 @@ static inline int pinconf_set_config(struct pinctrl_dev *pctldev, unsigned int p
 void pinconf_show_map(struct seq_file *s, const struct pinctrl_map *map);
 void pinconf_show_setting(struct seq_file *s,
 			  const struct pinctrl_setting *setting);
-void pinconf_init_device_debugfs(struct dentry *devroot,
+void pinconf_init_device_debugfs(struct debugfs_node *devroot,
 				 struct pinctrl_dev *pctldev);
 
 #else
@@ -96,7 +96,7 @@ static inline void pinconf_show_setting(struct seq_file *s,
 {
 }
 
-static inline void pinconf_init_device_debugfs(struct dentry *devroot,
+static inline void pinconf_init_device_debugfs(struct debugfs_node *devroot,
 					       struct pinctrl_dev *pctldev)
 {
 }
diff --git a/drivers/pinctrl/pinmux.c b/drivers/pinctrl/pinmux.c
index 0743190da59e..efc6921b4903 100644
--- a/drivers/pinctrl/pinmux.c
+++ b/drivers/pinctrl/pinmux.c
@@ -771,7 +771,7 @@ static ssize_t pinmux_select_write(struct file *file, const char __user *user_bu
 }
 DEFINE_SHOW_STORE_ATTRIBUTE(pinmux_select);
 
-void pinmux_init_device_debugfs(struct dentry *devroot,
+void pinmux_init_device_debugfs(struct debugfs_node *devroot,
 			 struct pinctrl_dev *pctldev)
 {
 	debugfs_create_file("pinmux-functions", 0444,
diff --git a/drivers/pinctrl/pinmux.h b/drivers/pinctrl/pinmux.h
index 2965ec20b77f..0a1a03341d9b 100644
--- a/drivers/pinctrl/pinmux.h
+++ b/drivers/pinctrl/pinmux.h
@@ -10,6 +10,7 @@
  * Author: Linus Walleij <linus.walleij@linaro.org>
  */
 
+#include <linux/debugfs.h>
 #include <linux/types.h>
 
 struct dentry;
@@ -107,7 +108,7 @@ static inline void pinmux_disable_setting(const struct pinctrl_setting *setting)
 void pinmux_show_map(struct seq_file *s, const struct pinctrl_map *map);
 void pinmux_show_setting(struct seq_file *s,
 			 const struct pinctrl_setting *setting);
-void pinmux_init_device_debugfs(struct dentry *devroot,
+void pinmux_init_device_debugfs(struct debugfs_node *devroot,
 				struct pinctrl_dev *pctldev);
 
 #else
@@ -122,7 +123,7 @@ static inline void pinmux_show_setting(struct seq_file *s,
 {
 }
 
-static inline void pinmux_init_device_debugfs(struct dentry *devroot,
+static inline void pinmux_init_device_debugfs(struct debugfs_node *devroot,
 					      struct pinctrl_dev *pctldev)
 {
 }
diff --git a/fs/debugfs/file.c b/fs/debugfs/file.c
index e33cc77699cd..6f7b74337df9 100644
--- a/fs/debugfs/file.c
+++ b/fs/debugfs/file.c
@@ -170,9 +170,9 @@ static int __debugfs_file_get(struct dentry *dentry, enum dbgfs_get_mode mode)
  * it is not safe to access any of its data. If, on the other hand,
  * it is allowed to access the file data, zero is returned.
  */
-int debugfs_file_get(struct dentry *dentry)
+int debugfs_file_get(struct debugfs_node *node)
 {
-	return __debugfs_file_get(dentry, DBGFS_GET_ALREADY);
+	return __debugfs_file_get((struct dentry *)node, DBGFS_GET_ALREADY);
 }
 EXPORT_SYMBOL_GPL(debugfs_file_get);
 
@@ -185,8 +185,9 @@ EXPORT_SYMBOL_GPL(debugfs_file_get);
  * debugfs_remove_recursive() blocked by a former call to
  * debugfs_file_get() to proceed and return to its caller.
  */
-void debugfs_file_put(struct dentry *dentry)
+void debugfs_file_put(struct debugfs_node *node)
 {
+	struct dentry *dentry = (struct dentry *)node;
 	struct debugfs_fsdata *fsd = READ_ONCE(dentry->d_fsdata);
 
 	if (refcount_dec_and_test(&fsd->active_users))
@@ -298,6 +299,7 @@ static int debugfs_locked_down(struct inode *inode,
 static int open_proxy_open(struct inode *inode, struct file *filp)
 {
 	struct dentry *dentry = F_DENTRY(filp);
+	struct debugfs_node *node = (struct debugfs_node*)dentry;
 	const struct file_operations *real_fops = NULL;
 	int r;
 
@@ -332,7 +334,7 @@ static int open_proxy_open(struct inode *inode, struct file *filp)
 		r = real_fops->open(inode, filp);
 
 out:
-	debugfs_file_put(dentry);
+	debugfs_file_put(node);
 	return r;
 }
 
@@ -347,18 +349,19 @@ const struct file_operations debugfs_open_proxy_file_operations = {
 static ret_type full_proxy_ ## name(proto)				\
 {									\
 	struct dentry *dentry = F_DENTRY(filp);				\
+	struct debugfs_node *node = (struct debugfs_node*)dentry;       \
 	struct debugfs_fsdata *fsd = dentry->d_fsdata;			\
 	const struct file_operations *real_fops;			\
 	ret_type r;							\
 									\
 	if (!(fsd->methods & bit))					\
 		return ret;						\
-	r = debugfs_file_get(dentry);					\
+	r = debugfs_file_get(node);					\
 	if (unlikely(r))						\
 		return r;						\
 	real_fops = debugfs_real_fops(filp);				\
 	r = real_fops->name(args);					\
-	debugfs_file_put(dentry);					\
+	debugfs_file_put(node);					\
 	return r;							\
 }
 
@@ -366,19 +369,20 @@ static ret_type full_proxy_ ## name(proto)				\
 static ret_type full_proxy_ ## name(proto)				\
 {									\
 	struct dentry *dentry = F_DENTRY(filp);				\
+	struct debugfs_node *node = (struct debugfs_node*)dentry;       \
 	struct debugfs_fsdata *fsd = dentry->d_fsdata;			\
 	ret_type r;							\
 									\
 	if (!(fsd->methods & bit))					\
 		return ret;						\
-	r = debugfs_file_get(dentry);					\
+	r = debugfs_file_get(node);					\
 	if (unlikely(r))						\
 		return r;						\
 	if (fsd->real_fops)						\
 		r = fsd->real_fops->name(args);				\
 	else								\
 		r = fsd->short_fops->name(args);			\
-	debugfs_file_put(dentry);					\
+	debugfs_file_put(node);						\
 	return r;							\
 }
 
@@ -404,18 +408,19 @@ static __poll_t full_proxy_poll(struct file *filp,
 				struct poll_table_struct *wait)
 {
 	struct dentry *dentry = F_DENTRY(filp);
+	struct debugfs_node *node = (struct debugfs_node*)dentry;
 	struct debugfs_fsdata *fsd = dentry->d_fsdata;
 	__poll_t r = 0;
 	const struct file_operations *real_fops;
 
 	if (!(fsd->methods & HAS_POLL))
 		return DEFAULT_POLLMASK;
-	if (debugfs_file_get(dentry))
+	if (debugfs_file_get(node))
 		return EPOLLHUP;
 
 	real_fops = debugfs_real_fops(filp);
 	r = real_fops->poll(filp, wait);
-	debugfs_file_put(dentry);
+	debugfs_file_put(node);
 	return r;
 }
 
@@ -440,6 +445,7 @@ static int full_proxy_release(struct inode *inode, struct file *filp)
 static int full_proxy_open_regular(struct inode *inode, struct file *filp)
 {
 	struct dentry *dentry = F_DENTRY(filp);
+	struct debugfs_node *node = (struct debugfs_node*)dentry;
 	const struct file_operations *real_fops;
 	struct debugfs_fsdata *fsd;
 	int r;
@@ -482,7 +488,7 @@ static int full_proxy_open_regular(struct inode *inode, struct file *filp)
 		}
 	}
 out:
-	debugfs_file_put(dentry);
+	debugfs_file_put(node);
 	return r;
 }
 
@@ -499,6 +505,7 @@ const struct file_operations debugfs_full_proxy_file_operations = {
 static int full_proxy_open_short(struct inode *inode, struct file *filp)
 {
 	struct dentry *dentry = F_DENTRY(filp);
+	struct debugfs_node *node = (struct debugfs_node*)dentry;
 	int r;
 
 	r = __debugfs_file_get(dentry, DBGFS_GET_SHORT);
@@ -507,7 +514,7 @@ static int full_proxy_open_short(struct inode *inode, struct file *filp)
 	r = debugfs_locked_down(inode, filp, NULL);
 	if (!r)
 		r = simple_open(inode, filp);
-	debugfs_file_put(dentry);
+	debugfs_file_put(node);
 	return r;
 }
 
@@ -522,13 +529,14 @@ ssize_t debugfs_attr_read(struct file *file, char __user *buf,
 			size_t len, loff_t *ppos)
 {
 	struct dentry *dentry = F_DENTRY(file);
+	struct debugfs_node *node = (struct debugfs_node*)dentry;
 	ssize_t ret;
 
-	ret = debugfs_file_get(dentry);
+	ret = debugfs_file_get(node);
 	if (unlikely(ret))
 		return ret;
 	ret = simple_attr_read(file, buf, len, ppos);
-	debugfs_file_put(dentry);
+	debugfs_file_put(node);
 	return ret;
 }
 EXPORT_SYMBOL_GPL(debugfs_attr_read);
@@ -537,16 +545,17 @@ static ssize_t debugfs_attr_write_xsigned(struct file *file, const char __user *
 			 size_t len, loff_t *ppos, bool is_signed)
 {
 	struct dentry *dentry = F_DENTRY(file);
+	struct debugfs_node *node = (struct debugfs_node*)dentry;
 	ssize_t ret;
 
-	ret = debugfs_file_get(dentry);
+	ret = debugfs_file_get(node);
 	if (unlikely(ret))
 		return ret;
 	if (is_signed)
 		ret = simple_attr_write_signed(file, buf, len, ppos);
 	else
 		ret = simple_attr_write(file, buf, len, ppos);
-	debugfs_file_put(dentry);
+	debugfs_file_put(node);
 	return ret;
 }
 
@@ -564,11 +573,12 @@ ssize_t debugfs_attr_write_signed(struct file *file, const char __user *buf,
 }
 EXPORT_SYMBOL_GPL(debugfs_attr_write_signed);
 
-static struct dentry *debugfs_create_mode_unsafe(const char *name, umode_t mode,
-					struct dentry *parent, void *value,
-					const struct file_operations *fops,
-					const struct file_operations *fops_ro,
-					const struct file_operations *fops_wo)
+static struct debugfs_node
+*debugfs_create_mode_unsafe(const char *name, umode_t mode,
+			    struct debugfs_node *parent, void *value,
+			    const struct file_operations *fops,
+			    const struct file_operations *fops_ro,
+			    const struct file_operations *fops_wo)
 {
 	/* if there are no write bits set, make read only */
 	if (!(mode & S_IWUGO))
@@ -600,8 +610,8 @@ DEFINE_DEBUGFS_ATTRIBUTE(fops_u8_wo, NULL, debugfs_u8_set, "%llu\n");
  * debugfs_create_u8 - create a debugfs file that is used to read and write an unsigned 8-bit value
  * @name: a pointer to a string containing the name of the file to create.
  * @mode: the permission that the file should have
- * @parent: a pointer to the parent dentry for this file.  This should be a
- *          directory dentry if set.  If this parameter is %NULL, then the
+ * @parent: a pointer to the parent debugfs_node for this file.  This should be a
+ *          directory debugfs_node if set.  If this parameter is %NULL, then the
  *          file will be created in the root of the debugfs filesystem.
  * @value: a pointer to the variable that the file should read to and write
  *         from.
@@ -610,7 +620,7 @@ DEFINE_DEBUGFS_ATTRIBUTE(fops_u8_wo, NULL, debugfs_u8_set, "%llu\n");
  * contains the value of the variable @value.  If the @mode variable is so
  * set, it can be read from, and written to.
  */
-void debugfs_create_u8(const char *name, umode_t mode, struct dentry *parent,
+void debugfs_create_u8(const char *name, umode_t mode, struct debugfs_node *parent,
 		       u8 *value)
 {
 	debugfs_create_mode_unsafe(name, mode, parent, value, &fops_u8,
@@ -636,8 +646,8 @@ DEFINE_DEBUGFS_ATTRIBUTE(fops_u16_wo, NULL, debugfs_u16_set, "%llu\n");
  * debugfs_create_u16 - create a debugfs file that is used to read and write an unsigned 16-bit value
  * @name: a pointer to a string containing the name of the file to create.
  * @mode: the permission that the file should have
- * @parent: a pointer to the parent dentry for this file.  This should be a
- *          directory dentry if set.  If this parameter is %NULL, then the
+ * @parent: a pointer to the parent debugfs_node for this file.  This should be a
+ *          directory debugfs_node if set.  If this parameter is %NULL, then the
  *          file will be created in the root of the debugfs filesystem.
  * @value: a pointer to the variable that the file should read to and write
  *         from.
@@ -646,7 +656,7 @@ DEFINE_DEBUGFS_ATTRIBUTE(fops_u16_wo, NULL, debugfs_u16_set, "%llu\n");
  * contains the value of the variable @value.  If the @mode variable is so
  * set, it can be read from, and written to.
  */
-void debugfs_create_u16(const char *name, umode_t mode, struct dentry *parent,
+void debugfs_create_u16(const char *name, umode_t mode, struct debugfs_node *parent,
 			u16 *value)
 {
 	debugfs_create_mode_unsafe(name, mode, parent, value, &fops_u16,
@@ -672,8 +682,8 @@ DEFINE_DEBUGFS_ATTRIBUTE(fops_u32_wo, NULL, debugfs_u32_set, "%llu\n");
  * debugfs_create_u32 - create a debugfs file that is used to read and write an unsigned 32-bit value
  * @name: a pointer to a string containing the name of the file to create.
  * @mode: the permission that the file should have
- * @parent: a pointer to the parent dentry for this file.  This should be a
- *          directory dentry if set.  If this parameter is %NULL, then the
+ * @parent: a pointer to the parent debugfs_node for this file.  This should be a
+ *          directory debugfs_node if set.  If this parameter is %NULL, then the
  *          file will be created in the root of the debugfs filesystem.
  * @value: a pointer to the variable that the file should read to and write
  *         from.
@@ -682,7 +692,7 @@ DEFINE_DEBUGFS_ATTRIBUTE(fops_u32_wo, NULL, debugfs_u32_set, "%llu\n");
  * contains the value of the variable @value.  If the @mode variable is so
  * set, it can be read from, and written to.
  */
-void debugfs_create_u32(const char *name, umode_t mode, struct dentry *parent,
+void debugfs_create_u32(const char *name, umode_t mode, struct debugfs_node *parent,
 			u32 *value)
 {
 	debugfs_create_mode_unsafe(name, mode, parent, value, &fops_u32,
@@ -709,8 +719,8 @@ DEFINE_DEBUGFS_ATTRIBUTE(fops_u64_wo, NULL, debugfs_u64_set, "%llu\n");
  * debugfs_create_u64 - create a debugfs file that is used to read and write an unsigned 64-bit value
  * @name: a pointer to a string containing the name of the file to create.
  * @mode: the permission that the file should have
- * @parent: a pointer to the parent dentry for this file.  This should be a
- *          directory dentry if set.  If this parameter is %NULL, then the
+ * @parent: a pointer to the parent debugfs_node for this file.  This should be a
+ *          directory debugfs_node if set.  If this parameter is %NULL, then the
  *          file will be created in the root of the debugfs filesystem.
  * @value: a pointer to the variable that the file should read to and write
  *         from.
@@ -719,7 +729,7 @@ DEFINE_DEBUGFS_ATTRIBUTE(fops_u64_wo, NULL, debugfs_u64_set, "%llu\n");
  * contains the value of the variable @value.  If the @mode variable is so
  * set, it can be read from, and written to.
  */
-void debugfs_create_u64(const char *name, umode_t mode, struct dentry *parent,
+void debugfs_create_u64(const char *name, umode_t mode, struct debugfs_node *parent,
 			u64 *value)
 {
 	debugfs_create_mode_unsafe(name, mode, parent, value, &fops_u64,
@@ -748,8 +758,8 @@ DEFINE_DEBUGFS_ATTRIBUTE(fops_ulong_wo, NULL, debugfs_ulong_set, "%llu\n");
  * an unsigned long value.
  * @name: a pointer to a string containing the name of the file to create.
  * @mode: the permission that the file should have
- * @parent: a pointer to the parent dentry for this file.  This should be a
- *          directory dentry if set.  If this parameter is %NULL, then the
+ * @parent: a pointer to the parent debugfs_node for this file.  This should be a
+ *          directory debugfs_node if set.  If this parameter is %NULL, then the
  *          file will be created in the root of the debugfs filesystem.
  * @value: a pointer to the variable that the file should read to and write
  *         from.
@@ -758,7 +768,7 @@ DEFINE_DEBUGFS_ATTRIBUTE(fops_ulong_wo, NULL, debugfs_ulong_set, "%llu\n");
  * contains the value of the variable @value.  If the @mode variable is so
  * set, it can be read from, and written to.
  */
-void debugfs_create_ulong(const char *name, umode_t mode, struct dentry *parent,
+void debugfs_create_ulong(const char *name, umode_t mode, struct debugfs_node *parent,
 			  unsigned long *value)
 {
 	debugfs_create_mode_unsafe(name, mode, parent, value, &fops_ulong,
@@ -797,13 +807,13 @@ DEFINE_DEBUGFS_ATTRIBUTE(fops_x64_wo, NULL, debugfs_u64_set, "0x%016llx\n");
  * debugfs_create_x8 - create a debugfs file that is used to read and write an unsigned 8-bit value
  * @name: a pointer to a string containing the name of the file to create.
  * @mode: the permission that the file should have
- * @parent: a pointer to the parent dentry for this file.  This should be a
- *          directory dentry if set.  If this parameter is %NULL, then the
+ * @parent: a pointer to the parent debugfs_node for this file.  This should be a
+ *          directory debugfs_node if set.  If this parameter is %NULL, then the
  *          file will be created in the root of the debugfs filesystem.
  * @value: a pointer to the variable that the file should read to and write
  *         from.
  */
-void debugfs_create_x8(const char *name, umode_t mode, struct dentry *parent,
+void debugfs_create_x8(const char *name, umode_t mode, struct debugfs_node *parent,
 		       u8 *value)
 {
 	debugfs_create_mode_unsafe(name, mode, parent, value, &fops_x8,
@@ -815,13 +825,13 @@ EXPORT_SYMBOL_GPL(debugfs_create_x8);
  * debugfs_create_x16 - create a debugfs file that is used to read and write an unsigned 16-bit value
  * @name: a pointer to a string containing the name of the file to create.
  * @mode: the permission that the file should have
- * @parent: a pointer to the parent dentry for this file.  This should be a
- *          directory dentry if set.  If this parameter is %NULL, then the
+ * @parent: a pointer to the parent debugfs_node for this file.  This should be a
+ *          directory debugfs_node if set.  If this parameter is %NULL, then the
  *          file will be created in the root of the debugfs filesystem.
  * @value: a pointer to the variable that the file should read to and write
  *         from.
  */
-void debugfs_create_x16(const char *name, umode_t mode, struct dentry *parent,
+void debugfs_create_x16(const char *name, umode_t mode, struct debugfs_node *parent,
 			u16 *value)
 {
 	debugfs_create_mode_unsafe(name, mode, parent, value, &fops_x16,
@@ -833,13 +843,13 @@ EXPORT_SYMBOL_GPL(debugfs_create_x16);
  * debugfs_create_x32 - create a debugfs file that is used to read and write an unsigned 32-bit value
  * @name: a pointer to a string containing the name of the file to create.
  * @mode: the permission that the file should have
- * @parent: a pointer to the parent dentry for this file.  This should be a
- *          directory dentry if set.  If this parameter is %NULL, then the
+ * @parent: a pointer to the parent debugfs_node for this file.  This should be a
+ *          directory debugfs_node if set.  If this parameter is %NULL, then the
  *          file will be created in the root of the debugfs filesystem.
  * @value: a pointer to the variable that the file should read to and write
  *         from.
  */
-void debugfs_create_x32(const char *name, umode_t mode, struct dentry *parent,
+void debugfs_create_x32(const char *name, umode_t mode, struct debugfs_node *parent,
 			u32 *value)
 {
 	debugfs_create_mode_unsafe(name, mode, parent, value, &fops_x32,
@@ -851,13 +861,13 @@ EXPORT_SYMBOL_GPL(debugfs_create_x32);
  * debugfs_create_x64 - create a debugfs file that is used to read and write an unsigned 64-bit value
  * @name: a pointer to a string containing the name of the file to create.
  * @mode: the permission that the file should have
- * @parent: a pointer to the parent dentry for this file.  This should be a
- *          directory dentry if set.  If this parameter is %NULL, then the
+ * @parent: a pointer to the parent debugfs_node for this file.  This should be a
+ *          directory debugfs_node if set.  If this parameter is %NULL, then the
  *          file will be created in the root of the debugfs filesystem.
  * @value: a pointer to the variable that the file should read to and write
  *         from.
  */
-void debugfs_create_x64(const char *name, umode_t mode, struct dentry *parent,
+void debugfs_create_x64(const char *name, umode_t mode, struct debugfs_node *parent,
 			u64 *value)
 {
 	debugfs_create_mode_unsafe(name, mode, parent, value, &fops_x64,
@@ -885,14 +895,14 @@ DEFINE_DEBUGFS_ATTRIBUTE(fops_size_t_wo, NULL, debugfs_size_t_set, "%llu\n");
  * debugfs_create_size_t - create a debugfs file that is used to read and write an size_t value
  * @name: a pointer to a string containing the name of the file to create.
  * @mode: the permission that the file should have
- * @parent: a pointer to the parent dentry for this file.  This should be a
- *          directory dentry if set.  If this parameter is %NULL, then the
+ * @parent: a pointer to the parent debugfs_node for this file.  This should be a
+ *          directory debugfs_node if set.  If this parameter is %NULL, then the
  *          file will be created in the root of the debugfs filesystem.
  * @value: a pointer to the variable that the file should read to and write
  *         from.
  */
 void debugfs_create_size_t(const char *name, umode_t mode,
-			   struct dentry *parent, size_t *value)
+			   struct debugfs_node *parent, size_t *value)
 {
 	debugfs_create_mode_unsafe(name, mode, parent, value, &fops_size_t,
 				   &fops_size_t_ro, &fops_size_t_wo);
@@ -921,14 +931,14 @@ DEFINE_DEBUGFS_ATTRIBUTE_SIGNED(fops_atomic_t_wo, NULL, debugfs_atomic_t_set,
  * write an atomic_t value
  * @name: a pointer to a string containing the name of the file to create.
  * @mode: the permission that the file should have
- * @parent: a pointer to the parent dentry for this file.  This should be a
- *          directory dentry if set.  If this parameter is %NULL, then the
+ * @parent: a pointer to the parent debugfs_node for this file.  This should be a
+ *          directory debugfs_node if set.  If this parameter is %NULL, then the
  *          file will be created in the root of the debugfs filesystem.
  * @value: a pointer to the variable that the file should read to and write
  *         from.
  */
 void debugfs_create_atomic_t(const char *name, umode_t mode,
-			     struct dentry *parent, atomic_t *value)
+			     struct debugfs_node *parent, atomic_t *value)
 {
 	debugfs_create_mode_unsafe(name, mode, parent, value, &fops_atomic_t,
 				   &fops_atomic_t_ro, &fops_atomic_t_wo);
@@ -942,12 +952,13 @@ ssize_t debugfs_read_file_bool(struct file *file, char __user *user_buf,
 	bool val;
 	int r;
 	struct dentry *dentry = F_DENTRY(file);
+	struct debugfs_node *node = (struct debugfs_node*)dentry;
 
-	r = debugfs_file_get(dentry);
+	r = debugfs_file_get(node);
 	if (unlikely(r))
 		return r;
 	val = *(bool *)file->private_data;
-	debugfs_file_put(dentry);
+	debugfs_file_put(node);
 
 	if (val)
 		buf[0] = 'Y';
@@ -965,14 +976,15 @@ ssize_t debugfs_write_file_bool(struct file *file, const char __user *user_buf,
 	int r;
 	bool *val = file->private_data;
 	struct dentry *dentry = F_DENTRY(file);
+	struct debugfs_node *node = (struct debugfs_node*)dentry;
 
 	r = kstrtobool_from_user(user_buf, count, &bv);
 	if (!r) {
-		r = debugfs_file_get(dentry);
+		r = debugfs_file_get(node);
 		if (unlikely(r))
 			return r;
 		*val = bv;
-		debugfs_file_put(dentry);
+		debugfs_file_put(node);
 	}
 
 	return count;
@@ -1002,8 +1014,8 @@ static const struct file_operations fops_bool_wo = {
  * debugfs_create_bool - create a debugfs file that is used to read and write a boolean value
  * @name: a pointer to a string containing the name of the file to create.
  * @mode: the permission that the file should have
- * @parent: a pointer to the parent dentry for this file.  This should be a
- *          directory dentry if set.  If this parameter is %NULL, then the
+ * @parent: a pointer to the parent debugfs_node for this file.  This should be a
+ *          directory debugfs_node if set.  If this parameter is %NULL, then the
  *          file will be created in the root of the debugfs filesystem.
  * @value: a pointer to the variable that the file should read to and write
  *         from.
@@ -1012,7 +1024,7 @@ static const struct file_operations fops_bool_wo = {
  * contains the value of the variable @value.  If the @mode variable is so
  * set, it can be read from, and written to.
  */
-void debugfs_create_bool(const char *name, umode_t mode, struct dentry *parent,
+void debugfs_create_bool(const char *name, umode_t mode, struct debugfs_node *parent,
 			 bool *value)
 {
 	debugfs_create_mode_unsafe(name, mode, parent, value, &fops_bool,
@@ -1024,11 +1036,12 @@ ssize_t debugfs_read_file_str(struct file *file, char __user *user_buf,
 			      size_t count, loff_t *ppos)
 {
 	struct dentry *dentry = F_DENTRY(file);
+	struct debugfs_node *node = (struct debugfs_node*)dentry;
 	char *str, *copy = NULL;
 	int copy_len, len;
 	ssize_t ret;
 
-	ret = debugfs_file_get(dentry);
+	ret = debugfs_file_get(node);
 	if (unlikely(ret))
 		return ret;
 
@@ -1036,12 +1049,12 @@ ssize_t debugfs_read_file_str(struct file *file, char __user *user_buf,
 	len = strlen(str) + 1;
 	copy = kmalloc(len, GFP_KERNEL);
 	if (!copy) {
-		debugfs_file_put(dentry);
+		debugfs_file_put(node);
 		return -ENOMEM;
 	}
 
 	copy_len = strscpy(copy, str, len);
-	debugfs_file_put(dentry);
+	debugfs_file_put(node);
 	if (copy_len < 0) {
 		kfree(copy);
 		return copy_len;
@@ -1060,11 +1073,12 @@ static ssize_t debugfs_write_file_str(struct file *file, const char __user *user
 				      size_t count, loff_t *ppos)
 {
 	struct dentry *dentry = F_DENTRY(file);
+	struct debugfs_node *node = (struct debugfs_node*)dentry;
 	char *old, *new = NULL;
 	int pos = *ppos;
 	int r;
 
-	r = debugfs_file_get(dentry);
+	r = debugfs_file_get(node);
 	if (unlikely(r))
 		return r;
 
@@ -1098,12 +1112,12 @@ static ssize_t debugfs_write_file_str(struct file *file, const char __user *user
 	synchronize_rcu();
 	kfree(old);
 
-	debugfs_file_put(dentry);
+	debugfs_file_put(node);
 	return count;
 
 error:
 	kfree(new);
-	debugfs_file_put(dentry);
+	debugfs_file_put(node);
 	return r;
 }
 
@@ -1130,8 +1144,8 @@ static const struct file_operations fops_str_wo = {
  * debugfs_create_str - create a debugfs file that is used to read and write a string value
  * @name: a pointer to a string containing the name of the file to create.
  * @mode: the permission that the file should have
- * @parent: a pointer to the parent dentry for this file.  This should be a
- *          directory dentry if set.  If this parameter is %NULL, then the
+ * @parent: a pointer to the parent debugfs_node for this file.  This should be a
+ *          directory debugfs_node if set.  If this parameter is %NULL, then the
  *          file will be created in the root of the debugfs filesystem.
  * @value: a pointer to the variable that the file should read to and write
  *         from.
@@ -1141,7 +1155,7 @@ static const struct file_operations fops_str_wo = {
  * set, it can be read from, and written to.
  */
 void debugfs_create_str(const char *name, umode_t mode,
-			struct dentry *parent, char **value)
+			struct debugfs_node *parent, char **value)
 {
 	debugfs_create_mode_unsafe(name, mode, parent, value, &fops_str,
 				   &fops_str_ro, &fops_str_wo);
@@ -1152,14 +1166,15 @@ static ssize_t read_file_blob(struct file *file, char __user *user_buf,
 {
 	struct debugfs_blob_wrapper *blob = file->private_data;
 	struct dentry *dentry = F_DENTRY(file);
+	struct debugfs_node *node = (struct debugfs_node*)dentry;
 	ssize_t r;
 
-	r = debugfs_file_get(dentry);
+	r = debugfs_file_get(node);
 	if (unlikely(r))
 		return r;
 	r = simple_read_from_buffer(user_buf, count, ppos, blob->data,
 				blob->size);
-	debugfs_file_put(dentry);
+	debugfs_file_put(node);
 	return r;
 }
 
@@ -1168,15 +1183,16 @@ static ssize_t write_file_blob(struct file *file, const char __user *user_buf,
 {
 	struct debugfs_blob_wrapper *blob = file->private_data;
 	struct dentry *dentry = F_DENTRY(file);
+	struct debugfs_node *node = (struct debugfs_node*)dentry;
 	ssize_t r;
 
-	r = debugfs_file_get(dentry);
+	r = debugfs_file_get(node);
 	if (unlikely(r))
 		return r;
 	r = simple_write_to_buffer(blob->data, blob->size, ppos, user_buf,
 				   count);
 
-	debugfs_file_put(dentry);
+	debugfs_file_put(node);
 	return r;
 }
 
@@ -1192,8 +1208,8 @@ static const struct file_operations fops_blob = {
  * a binary blob
  * @name: a pointer to a string containing the name of the file to create.
  * @mode: the permission that the file should have
- * @parent: a pointer to the parent dentry for this file.  This should be a
- *          directory dentry if set.  If this parameter is %NULL, then the
+ * @parent: a pointer to the parent debugfs_node for this file.  This should be a
+ *          directory debugfs_node if set.  If this parameter is %NULL, then the
  *          file will be created in the root of the debugfs filesystem.
  * @blob: a pointer to a struct debugfs_blob_wrapper which contains a pointer
  *        to the blob data and the size of the data.
@@ -1202,7 +1218,7 @@ static const struct file_operations fops_blob = {
  * @blob->data as a binary blob. If the @mode variable is so set it can be
  * read from and written to.
  *
- * This function will return a pointer to a dentry if it succeeds.  This
+ * This function will return a pointer to a debugfs_node if it succeeds.  This
  * pointer must be passed to the debugfs_remove() function when the file is
  * to be removed (no automatic cleanup happens if your module is unloaded,
  * you are responsible here.)  If an error occurs, ERR_PTR(-ERROR) will be
@@ -1211,8 +1227,8 @@ static const struct file_operations fops_blob = {
  * If debugfs is not enabled in the kernel, the value ERR_PTR(-ENODEV) will
  * be returned.
  */
-struct dentry *debugfs_create_blob(const char *name, umode_t mode,
-				   struct dentry *parent,
+struct debugfs_node *debugfs_create_blob(const char *name, umode_t mode,
+				   struct debugfs_node *parent,
 				   struct debugfs_blob_wrapper *blob)
 {
 	return debugfs_create_file_unsafe(name, mode & 0644, parent, blob, &fops_blob);
@@ -1288,8 +1304,8 @@ static const struct file_operations u32_array_fops = {
  * array.
  * @name: a pointer to a string containing the name of the file to create.
  * @mode: the permission that the file should have.
- * @parent: a pointer to the parent dentry for this file.  This should be a
- *          directory dentry if set.  If this parameter is %NULL, then the
+ * @parent: a pointer to the parent debugfs_node for this file.  This should be a
+ *          directory debugfs_node if set.  If this parameter is %NULL, then the
  *          file will be created in the root of the debugfs filesystem.
  * @array: wrapper struct containing data pointer and size of the array.
  *
@@ -1299,7 +1315,7 @@ static const struct file_operations u32_array_fops = {
  * Once array is created its size can not be changed.
  */
 void debugfs_create_u32_array(const char *name, umode_t mode,
-			      struct dentry *parent,
+			      struct debugfs_node *parent,
 			      struct debugfs_u32_array *array)
 {
 	debugfs_create_file_unsafe(name, mode, parent, array, &u32_array_fops);
@@ -1366,8 +1382,8 @@ DEFINE_SHOW_ATTRIBUTE(debugfs_regset32);
  * debugfs_create_regset32 - create a debugfs file that returns register values
  * @name: a pointer to a string containing the name of the file to create.
  * @mode: the permission that the file should have
- * @parent: a pointer to the parent dentry for this file.  This should be a
- *          directory dentry if set.  If this parameter is %NULL, then the
+ * @parent: a pointer to the parent debugfs_node for this file.  This should be a
+ *          directory debugfs_node if set.  If this parameter is %NULL, then the
  *          file will be created in the root of the debugfs filesystem.
  * @regset: a pointer to a struct debugfs_regset32, which contains a pointer
  *          to an array of register definitions, the array size and the base
@@ -1378,7 +1394,7 @@ DEFINE_SHOW_ATTRIBUTE(debugfs_regset32);
  * is so set it can be read from. Writing is not supported.
  */
 void debugfs_create_regset32(const char *name, umode_t mode,
-			     struct dentry *parent,
+			     struct debugfs_node *parent,
 			     struct debugfs_regset32 *regset)
 {
 	debugfs_create_file(name, mode, parent, regset, &debugfs_regset32_fops);
@@ -1412,13 +1428,13 @@ static const struct file_operations debugfs_devm_entry_ops = {
  *
  * @dev: device related to this debugfs file.
  * @name: name of the debugfs file.
- * @parent: a pointer to the parent dentry for this file.  This should be a
- *	directory dentry if set.  If this parameter is %NULL, then the
+ * @parent: a pointer to the parent debugfs_node for this file.  This should be a
+ *	directory debugfs_node if set.  If this parameter is %NULL, then the
  *	file will be created in the root of the debugfs filesystem.
  * @read_fn: function pointer called to print the seq_file content.
  */
 void debugfs_create_devm_seqfile(struct device *dev, const char *name,
-				 struct dentry *parent,
+				 struct debugfs_node *parent,
 				 int (*read_fn)(struct seq_file *s, void *data))
 {
 	struct debugfs_devm_entry *entry;
diff --git a/fs/debugfs/inode.c b/fs/debugfs/inode.c
index 75715d8877ee..df933010c571 100644
--- a/fs/debugfs/inode.c
+++ b/fs/debugfs/inode.c
@@ -253,8 +253,9 @@ static void debugfs_release_dentry(struct dentry *dentry)
 static struct vfsmount *debugfs_automount(struct path *path)
 {
 	struct inode *inode = path->dentry->d_inode;
+	struct debugfs_node *node = (struct debugfs_node*)path->dentry;
 
-	return DEBUGFS_I(inode)->automount(path->dentry, inode->i_private);
+	return DEBUGFS_I(inode)->automount(node, inode->i_private);
 }
 
 static const struct dentry_operations debugfs_dops = {
@@ -332,27 +333,46 @@ MODULE_ALIAS_FS("debugfs");
  * This function will return a pointer to a dentry if it succeeds.  If the file
  * doesn't exist or an error occurs, %NULL will be returned.  The returned
  * dentry must be passed to dput() when it is no longer needed.
+ * TODO: ^^ Edit to not require `dput`. Make some other debugfs_ function
  *
  * If debugfs is not enabled in the kernel, the value -%ENODEV will be
  * returned.
  */
-struct dentry *debugfs_lookup(const char *name, struct dentry *parent)
+struct debugfs_node *debugfs_lookup(const char *name, struct debugfs_node *parent)
 {
+	struct debugfs_node *node;
 	struct dentry *dentry;
 
 	if (!debugfs_initialized() || IS_ERR_OR_NULL(name) || IS_ERR(parent))
 		return NULL;
 
 	if (!parent)
-		parent = debugfs_mount->mnt_root;
+		parent = (struct debugfs_node *)debugfs_mount->mnt_root;
 
-	dentry = lookup_positive_unlocked(name, parent, strlen(name));
-	if (IS_ERR(dentry))
+	dentry = lookup_positive_unlocked(name, (struct dentry *)parent, strlen(name));
+	node = (struct debugfs_node *)dentry;
+	if (IS_ERR(node))
 		return NULL;
-	return dentry;
+	return node;
 }
 EXPORT_SYMBOL_GPL(debugfs_lookup);
 
+char *debugfs_node_path_raw(struct debugfs_node *node, char *buf, size_t buflen)
+{
+	return dentry_path_raw((struct dentry *)node, buf, buflen);
+}
+
+
+struct debugfs_node *debugfs_node_get(struct debugfs_node *node)
+{
+	return (struct debugfs_node *)dget((struct dentry *)node);
+}
+
+void debugfs_node_put(struct debugfs_node *node)
+{
+	dput((struct dentry *)node);
+}
+
 static struct dentry *start_creating(const char *name, struct dentry *parent)
 {
 	struct dentry *dentry;
@@ -466,25 +486,34 @@ static struct dentry *__debugfs_create_file(const char *name, umode_t mode,
 	return end_creating(dentry);
 }
 
-struct dentry *debugfs_create_file_full(const char *name, umode_t mode,
-					struct dentry *parent, void *data,
+struct debugfs_node *debugfs_create_file_full(const char *name, umode_t mode,
+					struct debugfs_node *parent, void *data,
 					const void *aux,
 					const struct file_operations *fops)
 {
-	return __debugfs_create_file(name, mode, parent, data, aux,
-				&debugfs_full_proxy_file_operations,
-				fops);
+	struct dentry *dentry;
+
+	dentry = __debugfs_create_file(name, mode, (struct dentry *)parent,
+				       data, aux,
+				       &debugfs_full_proxy_file_operations,
+				       fops);
+	return (struct debugfs_node *) dentry;
 }
 EXPORT_SYMBOL_GPL(debugfs_create_file_full);
 
-struct dentry *debugfs_create_file_short(const char *name, umode_t mode,
-					struct dentry *parent, void *data,
+struct debugfs_node *debugfs_create_file_short(const char *name, umode_t mode,
+					struct debugfs_node *parent, void *data,
 					const void *aux,
 					const struct debugfs_short_fops *fops)
 {
-	return __debugfs_create_file(name, mode, parent, data, aux,
-				&debugfs_full_short_proxy_file_operations,
-				fops);
+
+	struct dentry *dentry;
+
+	dentry = __debugfs_create_file(name, mode, (struct dentry *)parent,
+				       data, aux,
+				       &debugfs_full_short_proxy_file_operations,
+				       fops);
+	return (struct debugfs_node *) dentry;
 }
 EXPORT_SYMBOL_GPL(debugfs_create_file_short);
 
@@ -515,14 +544,17 @@ EXPORT_SYMBOL_GPL(debugfs_create_file_short);
  * DEFINE_DEBUGFS_ATTRIBUTE() is protected against file removals and
  * thus, may be used here.
  */
-struct dentry *debugfs_create_file_unsafe(const char *name, umode_t mode,
-				   struct dentry *parent, void *data,
+struct debugfs_node *debugfs_create_file_unsafe(const char *name, umode_t mode,
+				   struct debugfs_node *parent, void *data,
 				   const struct file_operations *fops)
 {
+	struct dentry *dentry;
 
-	return __debugfs_create_file(name, mode, parent, data, NULL,
-				&debugfs_open_proxy_file_operations,
-				fops);
+	dentry = __debugfs_create_file(name, mode, (struct dentry *)parent, data,
+				       NULL, &debugfs_open_proxy_file_operations,
+				       fops);
+
+	return (struct debugfs_node *) dentry;
 }
 EXPORT_SYMBOL_GPL(debugfs_create_file_unsafe);
 
@@ -546,14 +578,14 @@ EXPORT_SYMBOL_GPL(debugfs_create_file_unsafe);
  * recommended to be used instead.)
  */
 void debugfs_create_file_size(const char *name, umode_t mode,
-			      struct dentry *parent, void *data,
+			      struct debugfs_node *parent, void *data,
 			      const struct file_operations *fops,
 			      loff_t file_size)
 {
-	struct dentry *de = debugfs_create_file(name, mode, parent, data, fops);
+	struct debugfs_node *de = debugfs_create_file(name, mode, parent, data, fops);
 
 	if (!IS_ERR(de))
-		d_inode(de)->i_size = file_size;
+		d_inode((struct dentry *)de)->i_size = file_size;
 }
 EXPORT_SYMBOL_GPL(debugfs_create_file_size);
 
@@ -581,13 +613,13 @@ EXPORT_SYMBOL_GPL(debugfs_create_file_size);
  * passed to them could be an error and they don't crash in that case.
  * Drivers should generally work fine even if debugfs fails to init anyway.
  */
-struct dentry *debugfs_create_dir(const char *name, struct dentry *parent)
+struct debugfs_node *debugfs_create_dir(const char *name, struct debugfs_node *parent)
 {
-	struct dentry *dentry = start_creating(name, parent);
+	struct dentry *dentry = start_creating(name, (struct dentry *)parent);
 	struct inode *inode;
 
 	if (IS_ERR(dentry))
-		return dentry;
+		return (struct debugfs_node *)dentry;
 
 	if (!(debugfs_allow & DEBUGFS_ALLOW_API)) {
 		failed_creating(dentry);
@@ -598,7 +630,7 @@ struct dentry *debugfs_create_dir(const char *name, struct dentry *parent)
 	if (unlikely(!inode)) {
 		pr_err("out of free dentries, can not create directory '%s'\n",
 		       name);
-		return failed_creating(dentry);
+		return (struct debugfs_node *)failed_creating(dentry);
 	}
 
 	inode->i_mode = S_IFDIR | S_IRWXU | S_IRUGO | S_IXUGO;
@@ -610,7 +642,7 @@ struct dentry *debugfs_create_dir(const char *name, struct dentry *parent)
 	d_instantiate(dentry, inode);
 	inc_nlink(d_inode(dentry->d_parent));
 	fsnotify_mkdir(d_inode(dentry->d_parent), dentry);
-	return end_creating(dentry);
+	return (struct debugfs_node *)end_creating(dentry);
 }
 EXPORT_SYMBOL_GPL(debugfs_create_dir);
 
@@ -625,16 +657,16 @@ EXPORT_SYMBOL_GPL(debugfs_create_dir);
  *
  * @f should return what ->d_automount() would.
  */
-struct dentry *debugfs_create_automount(const char *name,
-					struct dentry *parent,
-					debugfs_automount_t f,
-					void *data)
+struct debugfs_node *debugfs_create_automount(const char *name,
+					      struct debugfs_node *parent,
+					      debugfs_automount_t f,
+					      void *data)
 {
-	struct dentry *dentry = start_creating(name, parent);
+	struct dentry *dentry = start_creating(name, (struct dentry *)parent);
 	struct inode *inode;
 
 	if (IS_ERR(dentry))
-		return dentry;
+		return (struct debugfs_node *)dentry;
 
 	if (!(debugfs_allow & DEBUGFS_ALLOW_API)) {
 		failed_creating(dentry);
@@ -645,7 +677,7 @@ struct dentry *debugfs_create_automount(const char *name,
 	if (unlikely(!inode)) {
 		pr_err("out of free dentries, can not create automount '%s'\n",
 		       name);
-		return failed_creating(dentry);
+		return (struct debugfs_node *)failed_creating(dentry);
 	}
 
 	make_empty_dir_inode(inode);
@@ -657,7 +689,7 @@ struct dentry *debugfs_create_automount(const char *name,
 	d_instantiate(dentry, inode);
 	inc_nlink(d_inode(dentry->d_parent));
 	fsnotify_mkdir(d_inode(dentry->d_parent), dentry);
-	return end_creating(dentry);
+	return (struct debugfs_node *)end_creating(dentry);
 }
 EXPORT_SYMBOL(debugfs_create_automount);
 
@@ -684,8 +716,9 @@ EXPORT_SYMBOL(debugfs_create_automount);
  * If debugfs is not enabled in the kernel, the value -%ENODEV will be
  * returned.
  */
-struct dentry *debugfs_create_symlink(const char *name, struct dentry *parent,
-				      const char *target)
+struct debugfs_node *debugfs_create_symlink(const char *name,
+					    struct debugfs_node *parent,
+					    const char *target)
 {
 	struct dentry *dentry;
 	struct inode *inode;
@@ -693,10 +726,10 @@ struct dentry *debugfs_create_symlink(const char *name, struct dentry *parent,
 	if (!link)
 		return ERR_PTR(-ENOMEM);
 
-	dentry = start_creating(name, parent);
+	dentry = start_creating(name, (struct dentry *)parent);
 	if (IS_ERR(dentry)) {
 		kfree(link);
-		return dentry;
+		return (struct debugfs_node *)dentry;
 	}
 
 	inode = debugfs_get_inode(dentry->d_sb);
@@ -704,13 +737,13 @@ struct dentry *debugfs_create_symlink(const char *name, struct dentry *parent,
 		pr_err("out of free dentries, can not create symlink '%s'\n",
 		       name);
 		kfree(link);
-		return failed_creating(dentry);
+		return (struct debugfs_node *)failed_creating(dentry);
 	}
 	inode->i_mode = S_IFLNK | S_IRWXUGO;
 	inode->i_op = &debugfs_symlink_inode_operations;
 	inode->i_link = link;
 	d_instantiate(dentry, inode);
-	return end_creating(dentry);
+	return (struct debugfs_node *)end_creating(dentry);
 }
 EXPORT_SYMBOL_GPL(debugfs_create_symlink);
 
@@ -768,7 +801,7 @@ static void __debugfs_file_removed(struct dentry *dentry)
 		while ((c = list_first_entry_or_null(&fsd->cancellations,
 						     typeof(*c), list))) {
 			list_del_init(&c->list);
-			c->cancel(dentry, c->cancel_data);
+			c->cancel((struct debugfs_node *)dentry, c->cancel_data);
 		}
 		mutex_unlock(&fsd->cancellations_mtx);
 
@@ -796,13 +829,13 @@ static void remove_one(struct dentry *victim)
  * removed, no automatic cleanup of files will happen when a module is
  * removed, you are responsible here.
  */
-void debugfs_remove(struct dentry *dentry)
+void debugfs_remove(struct debugfs_node *node)
 {
-	if (IS_ERR_OR_NULL(dentry))
+	if (IS_ERR_OR_NULL(node))
 		return;
 
 	simple_pin_fs(&debug_fs_type, &debugfs_mount, &debugfs_mount_count);
-	simple_recursive_removal(dentry, remove_one);
+	simple_recursive_removal((struct dentry*)node, remove_one);
 	simple_release_fs(&debugfs_mount, &debugfs_mount_count);
 }
 EXPORT_SYMBOL_GPL(debugfs_remove);
@@ -816,16 +849,16 @@ EXPORT_SYMBOL_GPL(debugfs_remove);
  * debugfs_remove(debugfs_lookup(..)) but with the proper reference counting
  * handled for the directory being looked up.
  */
-void debugfs_lookup_and_remove(const char *name, struct dentry *parent)
+void debugfs_lookup_and_remove(const char *name, struct debugfs_node *parent)
 {
-	struct dentry *dentry;
+	struct debugfs_node *node;
 
-	dentry = debugfs_lookup(name, parent);
-	if (!dentry)
+	node = debugfs_lookup(name, parent);
+	if (!node)
 		return;
 
-	debugfs_remove(dentry);
-	dput(dentry);
+	debugfs_remove(node);
+	dput((struct dentry *)node);
 }
 EXPORT_SYMBOL_GPL(debugfs_lookup_and_remove);
 
@@ -842,11 +875,12 @@ EXPORT_SYMBOL_GPL(debugfs_lookup_and_remove);
  * If debugfs is not enabled in the kernel, the value -%ENODEV will be
  * returned.
  */
-int __printf(2, 3) debugfs_change_name(struct dentry *dentry, const char *fmt, ...)
+int __printf(2, 3) debugfs_change_name(struct debugfs_node *node, const char *fmt, ...)
 {
 	int error = 0;
 	const char *new_name;
 	struct name_snapshot old_name;
+	struct dentry *dentry = (struct dentry *)node;
 	struct dentry *parent, *target;
 	struct inode *dir;
 	va_list ap;
diff --git a/include/linux/backing-dev-defs.h b/include/linux/backing-dev-defs.h
index 2ad261082bba..85b1ad4f7072 100644
--- a/include/linux/backing-dev-defs.h
+++ b/include/linux/backing-dev-defs.h
@@ -16,7 +16,6 @@
 
 struct page;
 struct device;
-struct dentry;
 
 /*
  * Bits in bdi_writeback.state
@@ -199,7 +198,7 @@ struct backing_dev_info {
 	struct timer_list laptop_mode_wb_timer;
 
 #ifdef CONFIG_DEBUG_FS
-	struct dentry *debug_dir;
+	struct debugfs_node *debug_dir;
 #endif
 };
 
diff --git a/include/linux/blkdev.h b/include/linux/blkdev.h
index 76f0a4e7c2e5..3e02ba1426b6 100644
--- a/include/linux/blkdev.h
+++ b/include/linux/blkdev.h
@@ -598,9 +598,9 @@ struct request_queue {
 	struct blk_mq_tag_set	*tag_set;
 	struct list_head	tag_set_list;
 
-	struct dentry		*debugfs_dir;
-	struct dentry		*sched_debugfs_dir;
-	struct dentry		*rqos_debugfs_dir;
+	struct debugfs_node	*debugfs_dir;
+	struct debugfs_node	*sched_debugfs_dir;
+	struct debugfs_node	*rqos_debugfs_dir;
 	/*
 	 * Serializes all debugfs metadata operations using the above dentries.
 	 */
diff --git a/include/linux/debugfs.h b/include/linux/debugfs.h
index fa2568b4380d..37ca057c325e 100644
--- a/include/linux/debugfs.h
+++ b/include/linux/debugfs.h
@@ -21,6 +21,11 @@
 struct device;
 struct file_operations;
 
+/* Opaque handle to debugfs nodes to support migration to kernfs. */
+struct debugfs_node {
+	struct dentry dentry;
+};
+
 struct debugfs_blob_wrapper {
 	void *data;
 	unsigned long size;
@@ -43,7 +48,7 @@ struct debugfs_u32_array {
 	u32 n_elements;
 };
 
-extern struct dentry *arch_debugfs_dir;
+extern struct debugfs_node *arch_debugfs_dir;
 
 #define DEFINE_DEBUGFS_ATTRIBUTE_XSIGNED(__fops, __get, __set, __fmt, __is_signed)	\
 static int __fops ## _open(struct inode *inode, struct file *file)	\
@@ -65,7 +70,9 @@ static const struct file_operations __fops = {				\
 #define DEFINE_DEBUGFS_ATTRIBUTE_SIGNED(__fops, __get, __set, __fmt)	\
 	DEFINE_DEBUGFS_ATTRIBUTE_XSIGNED(__fops, __get, __set, __fmt, true)
 
-typedef struct vfsmount *(*debugfs_automount_t)(struct dentry *, void *);
+typedef struct vfsmount *(*debugfs_automount_t)(struct debugfs_node *, void *);
+
+
 
 struct debugfs_short_fops {
 	ssize_t (*read)(struct file *, char __user *, size_t, loff_t *);
@@ -75,14 +82,19 @@ struct debugfs_short_fops {
 
 #if defined(CONFIG_DEBUG_FS)
 
-struct dentry *debugfs_lookup(const char *name, struct dentry *parent);
+struct debugfs_node *debugfs_lookup(const char *name, struct debugfs_node *parent);
 
-struct dentry *debugfs_create_file_full(const char *name, umode_t mode,
-					struct dentry *parent, void *data,
+char *debugfs_node_path_raw(struct debugfs_node *node, char *buf, size_t buflen);
+
+struct debugfs_node *debugfs_node_get(struct debugfs_node *node);
+void debugfs_node_put(struct debugfs_node *node);
+
+struct debugfs_node *debugfs_create_file_full(const char *name, umode_t mode,
+					struct debugfs_node *parent, void *data,
 					const void *aux,
 					const struct file_operations *fops);
-struct dentry *debugfs_create_file_short(const char *name, umode_t mode,
-					 struct dentry *parent, void *data,
+struct debugfs_node *debugfs_create_file_short(const char *name, umode_t mode,
+					 struct debugfs_node *parent, void *data,
 					 const void *aux,
 					 const struct debugfs_short_fops *fops);
 
@@ -90,8 +102,8 @@ struct dentry *debugfs_create_file_short(const char *name, umode_t mode,
  * debugfs_create_file - create a file in the debugfs filesystem
  * @name: a pointer to a string containing the name of the file to create.
  * @mode: the permission that the file should have.
- * @parent: a pointer to the parent dentry for this file.  This should be a
- *          directory dentry if set.  If this parameter is NULL, then the
+ * @parent: a pointer to the parent debugfs_node for this file.  This should be a
+ *          directory debugfs_node if set.  If this parameter is NULL, then the
  *          file will be created in the root of the debugfs filesystem.
  * @data: a pointer to something that the caller will want to get to later
  *        on.  The inode.i_private pointer will point to this value on
@@ -104,7 +116,7 @@ struct dentry *debugfs_create_file_short(const char *name, umode_t mode,
  * to create a directory, the debugfs_create_dir() function is
  * recommended to be used instead.)
  *
- * This function will return a pointer to a dentry if it succeeds.  This
+ * This function will return a pointer to a debugfs_node if it succeeds.  This
  * pointer must be passed to the debugfs_remove() function when the file is
  * to be removed (no automatic cleanup happens if your module is unloaded,
  * you are responsible here.)  If an error occurs, ERR_PTR(-ERROR) will be
@@ -118,7 +130,7 @@ struct dentry *debugfs_create_file_short(const char *name, umode_t mode,
  * so no module reference or release are needed.
  *
  * NOTE: it's expected that most callers should _ignore_ the errors returned
- * by this function. Other debugfs functions handle the fact that the "dentry"
+ * by this function. Other debugfs functions handle the fact that the "debugfs_node"
  * passed to them could be an error and they don't crash in that case.
  * Drivers should generally work fine even if debugfs fails to init anyway.
  */
@@ -138,35 +150,35 @@ struct dentry *debugfs_create_file_short(const char *name, umode_t mode,
 		 struct debugfs_short_fops *: debugfs_create_file_short)	\
 		(name, mode, parent, data, aux, fops)
 
-struct dentry *debugfs_create_file_unsafe(const char *name, umode_t mode,
-				   struct dentry *parent, void *data,
+struct debugfs_node *debugfs_create_file_unsafe(const char *name, umode_t mode,
+				   struct debugfs_node *parent, void *data,
 				   const struct file_operations *fops);
 
 void debugfs_create_file_size(const char *name, umode_t mode,
-			      struct dentry *parent, void *data,
+			      struct debugfs_node *parent, void *data,
 			      const struct file_operations *fops,
 			      loff_t file_size);
 
-struct dentry *debugfs_create_dir(const char *name, struct dentry *parent);
+struct debugfs_node *debugfs_create_dir(const char *name, struct debugfs_node *parent);
 
-struct dentry *debugfs_create_symlink(const char *name, struct dentry *parent,
+struct debugfs_node *debugfs_create_symlink(const char *name, struct debugfs_node *parent,
 				      const char *dest);
 
-struct dentry *debugfs_create_automount(const char *name,
-					struct dentry *parent,
+struct debugfs_node *debugfs_create_automount(const char *name,
+					struct debugfs_node *parent,
 					debugfs_automount_t f,
 					void *data);
 
-void debugfs_remove(struct dentry *dentry);
+void debugfs_remove(struct debugfs_node *debugfs_node);
 #define debugfs_remove_recursive debugfs_remove
 
-void debugfs_lookup_and_remove(const char *name, struct dentry *parent);
+void debugfs_lookup_and_remove(const char *name, struct debugfs_node *parent);
 
 const struct file_operations *debugfs_real_fops(const struct file *filp);
 const void *debugfs_get_aux(const struct file *file);
 
-int debugfs_file_get(struct dentry *dentry);
-void debugfs_file_put(struct dentry *dentry);
+int debugfs_file_get(struct debugfs_node *debugfs_node);
+void debugfs_file_put(struct debugfs_node *debugfs_node);
 
 ssize_t debugfs_attr_read(struct file *file, char __user *buf,
 			size_t len, loff_t *ppos);
@@ -175,52 +187,52 @@ ssize_t debugfs_attr_write(struct file *file, const char __user *buf,
 ssize_t debugfs_attr_write_signed(struct file *file, const char __user *buf,
 			size_t len, loff_t *ppos);
 
-int debugfs_change_name(struct dentry *dentry, const char *fmt, ...) __printf(2, 3);
+int debugfs_change_name(struct debugfs_node *dentry, const char *fmt, ...) __printf(2, 3);
 
-void debugfs_create_u8(const char *name, umode_t mode, struct dentry *parent,
+void debugfs_create_u8(const char *name, umode_t mode, struct debugfs_node *parent,
 		       u8 *value);
-void debugfs_create_u16(const char *name, umode_t mode, struct dentry *parent,
+void debugfs_create_u16(const char *name, umode_t mode, struct debugfs_node *parent,
 			u16 *value);
-void debugfs_create_u32(const char *name, umode_t mode, struct dentry *parent,
+void debugfs_create_u32(const char *name, umode_t mode, struct debugfs_node *parent,
 			u32 *value);
-void debugfs_create_u64(const char *name, umode_t mode, struct dentry *parent,
+void debugfs_create_u64(const char *name, umode_t mode, struct debugfs_node *parent,
 			u64 *value);
-void debugfs_create_ulong(const char *name, umode_t mode, struct dentry *parent,
+void debugfs_create_ulong(const char *name, umode_t mode, struct debugfs_node *parent,
 			  unsigned long *value);
-void debugfs_create_x8(const char *name, umode_t mode, struct dentry *parent,
+void debugfs_create_x8(const char *name, umode_t mode, struct debugfs_node *parent,
 		       u8 *value);
-void debugfs_create_x16(const char *name, umode_t mode, struct dentry *parent,
+void debugfs_create_x16(const char *name, umode_t mode, struct debugfs_node *parent,
 			u16 *value);
-void debugfs_create_x32(const char *name, umode_t mode, struct dentry *parent,
+void debugfs_create_x32(const char *name, umode_t mode, struct debugfs_node *parent,
 			u32 *value);
-void debugfs_create_x64(const char *name, umode_t mode, struct dentry *parent,
+void debugfs_create_x64(const char *name, umode_t mode, struct debugfs_node *parent,
 			u64 *value);
 void debugfs_create_size_t(const char *name, umode_t mode,
-			   struct dentry *parent, size_t *value);
+			   struct debugfs_node *parent, size_t *value);
 void debugfs_create_atomic_t(const char *name, umode_t mode,
-			     struct dentry *parent, atomic_t *value);
-void debugfs_create_bool(const char *name, umode_t mode, struct dentry *parent,
+			     struct debugfs_node *parent, atomic_t *value);
+void debugfs_create_bool(const char *name, umode_t mode, struct debugfs_node *parent,
 			 bool *value);
 void debugfs_create_str(const char *name, umode_t mode,
-			struct dentry *parent, char **value);
+			struct debugfs_node *parent, char **value);
 
-struct dentry *debugfs_create_blob(const char *name, umode_t mode,
-				  struct dentry *parent,
+struct debugfs_node *debugfs_create_blob(const char *name, umode_t mode,
+				  struct debugfs_node *parent,
 				  struct debugfs_blob_wrapper *blob);
 
 void debugfs_create_regset32(const char *name, umode_t mode,
-			     struct dentry *parent,
+			     struct debugfs_node *parent,
 			     struct debugfs_regset32 *regset);
 
 void debugfs_print_regs32(struct seq_file *s, const struct debugfs_reg32 *regs,
 			  int nregs, void __iomem *base, char *prefix);
 
 void debugfs_create_u32_array(const char *name, umode_t mode,
-			      struct dentry *parent,
+			      struct debugfs_node *parent,
 			      struct debugfs_u32_array *array);
 
 void debugfs_create_devm_seqfile(struct device *dev, const char *name,
-				 struct dentry *parent,
+				 struct debugfs_node *parent,
 				 int (*read_fn)(struct seq_file *s, void *data));
 
 bool debugfs_initialized(void);
@@ -242,7 +254,7 @@ ssize_t debugfs_read_file_str(struct file *file, char __user *user_buf,
  */
 struct debugfs_cancellation {
 	struct list_head list;
-	void (*cancel)(struct dentry *, void *);
+	void (*cancel)(struct debugfs_node *, void *);
 	void *cancel_data;
 };
 
@@ -263,29 +275,43 @@ debugfs_leave_cancellation(struct file *file,
  * want to duplicate the design decision mistakes of procfs and devfs again.
  */
 
-static inline struct dentry *debugfs_lookup(const char *name,
-					    struct dentry *parent)
+static inline struct debugfs_node *debugfs_lookup(const char *name,
+					    struct debugfs_node *parent)
+{
+	return ERR_PTR(-ENODEV);
+}
+
+static inline char *debugfs_node_path_raw(struct debugfs_node *node, char *buf,
+					  size_t buflen)
+{
+	return ERR_PTR(-ENODEV);
+}
+
+static inline struct debugfs_node *debugfs_node_get(struct debugfs_node *node)
 {
 	return ERR_PTR(-ENODEV);
 }
 
-static inline struct dentry *debugfs_create_file_aux(const char *name,
-					umode_t mode, struct dentry *parent,
+static inline void debugfs_node_put(struct debugfs_node *node)
+{ }
+
+static inline struct debugfs_node *debugfs_create_file_aux(const char *name,
+					umode_t mode, struct debugfs_node *parent,
 					void *data, void *aux,
 					const void *fops)
 {
 	return ERR_PTR(-ENODEV);
 }
 
-static inline struct dentry *debugfs_create_file(const char *name, umode_t mode,
-					struct dentry *parent, void *data,
+static inline struct debugfs_node *debugfs_create_file(const char *name, umode_t mode,
+					struct debugfs_node *parent, void *data,
 					const void *fops)
 {
 	return ERR_PTR(-ENODEV);
 }
 
-static inline struct dentry *debugfs_create_file_unsafe(const char *name,
-					umode_t mode, struct dentry *parent,
+static inline struct debugfs_node *debugfs_create_file_unsafe(const char *name,
+					umode_t mode, struct debugfs_node *parent,
 					void *data,
 					const struct file_operations *fops)
 {
@@ -293,51 +319,51 @@ static inline struct dentry *debugfs_create_file_unsafe(const char *name,
 }
 
 static inline void debugfs_create_file_size(const char *name, umode_t mode,
-					    struct dentry *parent, void *data,
+					    struct debugfs_node *parent, void *data,
 					    const struct file_operations *fops,
 					    loff_t file_size)
 { }
 
-static inline struct dentry *debugfs_create_dir(const char *name,
-						struct dentry *parent)
+static inline struct debugfs_node *debugfs_create_dir(const char *name,
+						struct debugfs_node *parent)
 {
 	return ERR_PTR(-ENODEV);
 }
 
-static inline struct dentry *debugfs_create_symlink(const char *name,
-						    struct dentry *parent,
+static inline struct debugfs_node *debugfs_create_symlink(const char *name,
+						    struct debugfs_node *parent,
 						    const char *dest)
 {
 	return ERR_PTR(-ENODEV);
 }
 
-static inline struct dentry *debugfs_create_automount(const char *name,
-					struct dentry *parent,
+static inline struct debugfs_node *debugfs_create_automount(const char *name,
+					struct debugfs_node *parent,
 					debugfs_automount_t f,
 					void *data)
 {
 	return ERR_PTR(-ENODEV);
 }
 
-static inline void debugfs_remove(struct dentry *dentry)
+static inline void debugfs_remove(struct debugfs_node *debugfs_node)
 { }
 
-static inline void debugfs_remove_recursive(struct dentry *dentry)
+static inline void debugfs_remove_recursive(struct debugfs_node *debugfs_node)
 { }
 
 static inline void debugfs_lookup_and_remove(const char *name,
-					     struct dentry *parent)
+					     struct debugfs_node *parent)
 { }
 
 const struct file_operations *debugfs_real_fops(const struct file *filp);
 void *debugfs_get_aux(const struct file *file);
 
-static inline int debugfs_file_get(struct dentry *dentry)
+static inline int debugfs_file_get(struct debugfs_node *debugfs_node)
 {
 	return 0;
 }
 
-static inline void debugfs_file_put(struct dentry *dentry)
+static inline void debugfs_file_put(struct debugfs_node *debugfs_node)
 { }
 
 static inline ssize_t debugfs_attr_read(struct file *file, char __user *buf,
@@ -360,66 +386,66 @@ static inline ssize_t debugfs_attr_write_signed(struct file *file,
 	return -ENODEV;
 }
 
-static inline int __printf(2, 3) debugfs_change_name(struct dentry *dentry,
+static inline int __printf(2, 3) debugfs_change_name(struct debugfs_node *dentry,
 					const char *fmt, ...)
 {
 	return -ENODEV;
 }
 
 static inline void debugfs_create_u8(const char *name, umode_t mode,
-				     struct dentry *parent, u8 *value) { }
+				     struct debugfs_node *parent, u8 *value) { }
 
 static inline void debugfs_create_u16(const char *name, umode_t mode,
-				      struct dentry *parent, u16 *value) { }
+				      struct debugfs_node *parent, u16 *value) { }
 
 static inline void debugfs_create_u32(const char *name, umode_t mode,
-				      struct dentry *parent, u32 *value) { }
+				      struct debugfs_node *parent, u32 *value) { }
 
 static inline void debugfs_create_u64(const char *name, umode_t mode,
-				      struct dentry *parent, u64 *value) { }
+				      struct debugfs_node *parent, u64 *value) { }
 
 static inline void debugfs_create_ulong(const char *name, umode_t mode,
-					struct dentry *parent,
+					struct debugfs_node *parent,
 					unsigned long *value) { }
 
 static inline void debugfs_create_x8(const char *name, umode_t mode,
-				     struct dentry *parent, u8 *value) { }
+				     struct debugfs_node *parent, u8 *value) { }
 
 static inline void debugfs_create_x16(const char *name, umode_t mode,
-				      struct dentry *parent, u16 *value) { }
+				      struct debugfs_node *parent, u16 *value) { }
 
 static inline void debugfs_create_x32(const char *name, umode_t mode,
-				      struct dentry *parent, u32 *value) { }
+				      struct debugfs_node *parent, u32 *value) { }
 
 static inline void debugfs_create_x64(const char *name, umode_t mode,
-				      struct dentry *parent, u64 *value) { }
+				      struct debugfs_node *parent, u64 *value) { }
 
 static inline void debugfs_create_size_t(const char *name, umode_t mode,
-					 struct dentry *parent, size_t *value)
+					 struct debugfs_node *parent, size_t *value)
 { }
 
 static inline void debugfs_create_atomic_t(const char *name, umode_t mode,
-					   struct dentry *parent,
+					   struct debugfs_node *parent,
 					   atomic_t *value)
 { }
 
 static inline void debugfs_create_bool(const char *name, umode_t mode,
-				       struct dentry *parent, bool *value) { }
+				       struct debugfs_node *parent, bool *value) { }
 
 static inline void debugfs_create_str(const char *name, umode_t mode,
-				      struct dentry *parent,
+				      struct debugfs_node *parent,
 				      char **value)
 { }
 
-static inline struct dentry *debugfs_create_blob(const char *name, umode_t mode,
-				  struct dentry *parent,
+static inline struct debugfs_node *debugfs_create_blob(const char *name, umode_t mode,
+				  struct debugfs_node *parent,
 				  struct debugfs_blob_wrapper *blob)
 {
 	return ERR_PTR(-ENODEV);
 }
 
 static inline void debugfs_create_regset32(const char *name, umode_t mode,
-					   struct dentry *parent,
+					   struct debugfs_node *parent,
 					   struct debugfs_regset32 *regset)
 {
 }
@@ -435,14 +461,14 @@ static inline bool debugfs_initialized(void)
 }
 
 static inline void debugfs_create_u32_array(const char *name, umode_t mode,
-					    struct dentry *parent,
+					    struct debugfs_node *parent,
 					    struct debugfs_u32_array *array)
 {
 }
 
 static inline void debugfs_create_devm_seqfile(struct device *dev,
 					       const char *name,
-					       struct dentry *parent,
+					       struct debugfs_node *parent,
 					       int (*read_fn)(struct seq_file *s,
 							      void *data))
 {
@@ -481,14 +507,14 @@ static inline ssize_t debugfs_read_file_str(struct file *file,
  * unsigned long value, formatted in hexadecimal
  * @name: a pointer to a string containing the name of the file to create.
  * @mode: the permission that the file should have
- * @parent: a pointer to the parent dentry for this file.  This should be a
- *          directory dentry if set.  If this parameter is %NULL, then the
+ * @parent: a pointer to the parent debugfs_node for this file.  This should be a
+ *          directory debugfs_node if set.  If this parameter is %NULL, then the
  *          file will be created in the root of the debugfs filesystem.
  * @value: a pointer to the variable that the file should read to and write
  *         from.
  */
 static inline void debugfs_create_xul(const char *name, umode_t mode,
-				      struct dentry *parent,
+				      struct debugfs_node *parent,
 				      unsigned long *value)
 {
 	if (sizeof(*value) == sizeof(u32))
diff --git a/include/linux/dmaengine.h b/include/linux/dmaengine.h
index 346251bf1026..c1080847e0a6 100644
--- a/include/linux/dmaengine.h
+++ b/include/linux/dmaengine.h
@@ -960,7 +960,7 @@ struct dma_device {
 	void (*device_release)(struct dma_device *dev);
 	/* debugfs support */
 	void (*dbg_summary_show)(struct seq_file *s, struct dma_device *dev);
-	struct dentry *dbg_dev_root;
+	struct debugfs_node *dbg_dev_root;
 };
 
 static inline int dmaengine_slave_config(struct dma_chan *chan,
diff --git a/include/linux/fault-inject.h b/include/linux/fault-inject.h
index 8c829d28dcf3..0cef157b8b14 100644
--- a/include/linux/fault-inject.h
+++ b/include/linux/fault-inject.h
@@ -33,7 +33,7 @@ struct fault_attr {
 
 	unsigned long count;
 	struct ratelimit_state ratelimit_state;
-	struct dentry *dname;
+	struct debugfs_node *dname;
 };
 
 enum fault_flags {
@@ -79,13 +79,13 @@ static inline bool should_fail(struct fault_attr *attr, ssize_t size)
 
 #ifdef CONFIG_FAULT_INJECTION_DEBUG_FS
 
-struct dentry *fault_create_debugfs_attr(const char *name,
-			struct dentry *parent, struct fault_attr *attr);
+struct debugfs_node *fault_create_debugfs_attr(const char *name,
+			struct debugfs_node *parent, struct fault_attr *attr);
 
 #else /* CONFIG_FAULT_INJECTION_DEBUG_FS */
 
-static inline struct dentry *fault_create_debugfs_attr(const char *name,
-			struct dentry *parent, struct fault_attr *attr)
+static inline struct debugfs_node *fault_create_debugfs_attr(const char *name,
+			struct debugfs_node *parent, struct fault_attr *attr)
 {
 	return ERR_PTR(-ENODEV);
 }
diff --git a/include/linux/kvm_host.h b/include/linux/kvm_host.h
index 3cb9a32a6330..bfa4ffd15bd7 100644
--- a/include/linux/kvm_host.h
+++ b/include/linux/kvm_host.h
@@ -842,7 +842,7 @@ struct kvm {
 #endif
 	struct list_head devices;
 	u64 manual_dirty_log_protect;
-	struct dentry *debugfs_dentry;
+	struct debugfs_node *debugfs_dentry;
 	struct kvm_stat_data **debugfs_stat_data;
 	struct srcu_struct srcu;
 	struct srcu_struct irq_srcu;
@@ -1586,7 +1586,7 @@ int kvm_arch_pm_notifier(struct kvm *kvm, unsigned long state);
 #endif
 
 #ifdef __KVM_HAVE_ARCH_VCPU_DEBUGFS
-void kvm_arch_create_vcpu_debugfs(struct kvm_vcpu *vcpu, struct dentry *debugfs_dentry);
+void kvm_arch_create_vcpu_debugfs(struct kvm_vcpu *vcpu, struct debugfs_node *debugfs_dentry);
 #else
 static inline void kvm_create_vcpu_debugfs(struct kvm_vcpu *vcpu) {}
 #endif
diff --git a/include/linux/mhi.h b/include/linux/mhi.h
index 059dc94d20bb..2d39ef47d153 100644
--- a/include/linux/mhi.h
+++ b/include/linux/mhi.h
@@ -371,7 +371,7 @@ struct mhi_controller {
 	const char *name;
 	struct device *cntrl_dev;
 	struct mhi_device *mhi_dev;
-	struct dentry *debugfs_dentry;
+	struct debugfs_node *debugfs_dentry;
 	void __iomem *regs;
 	void __iomem *bhi;
 	void __iomem *bhie;
diff --git a/include/linux/moxtet.h b/include/linux/moxtet.h
index dfa4800306ee..2e3ae183a098 100644
--- a/include/linux/moxtet.h
+++ b/include/linux/moxtet.h
@@ -52,7 +52,7 @@ struct moxtet {
 		} position[MOXTET_NIRQS];
 	} irq;
 #ifdef CONFIG_DEBUG_FS
-	struct dentry			*debugfs_root;
+	struct debugfs_node		*debugfs_root;
 #endif
 };
 
diff --git a/include/linux/phy/phy.h b/include/linux/phy/phy.h
index 03cd5bae92d3..8fa11766a567 100644
--- a/include/linux/phy/phy.h
+++ b/include/linux/phy/phy.h
@@ -164,7 +164,7 @@ struct phy {
 	int			power_count;
 	struct phy_attrs	attrs;
 	struct regulator	*pwr;
-	struct dentry		*debugfs;
+	struct debugfs_node	*debugfs;
 };
 
 /**
diff --git a/include/net/cfg80211.h b/include/net/cfg80211.h
index 363d7dd2255a..214341216cb9 100644
--- a/include/net/cfg80211.h
+++ b/include/net/cfg80211.h
@@ -5793,7 +5793,7 @@ struct wiphy {
 
 	bool registered;
 
-	struct dentry *debugfsdir;
+	struct debugfs_node *debugfsdir;
 
 	const struct ieee80211_ht_cap *ht_capa_mod_mask;
 	const struct ieee80211_vht_cap *vht_capa_mod_mask;
diff --git a/include/sound/core.h b/include/sound/core.h
index 1f3f5dccd736..6e2b3a682bfb 100644
--- a/include/sound/core.h
+++ b/include/sound/core.h
@@ -131,7 +131,7 @@ struct snd_card {
 	size_t total_pcm_alloc_bytes;	/* total amount of allocated buffers */
 	struct mutex memory_mutex;	/* protection for the above */
 #ifdef CONFIG_SND_DEBUG
-	struct dentry *debugfs_root;    /* debugfs root for card */
+	struct debugfs_node *debugfs_root;    /* debugfs root for card */
 #endif
 
 #ifdef CONFIG_PM
@@ -234,7 +234,7 @@ extern int snd_major;
 extern int snd_ecards_limit;
 extern const struct class sound_class;
 #ifdef CONFIG_SND_DEBUG
-extern struct dentry *sound_debugfs_root;
+extern struct debugfs_node *sound_debugfs_root;
 #endif
 
 void snd_request_card(int card);
diff --git a/lib/fault-inject.c b/lib/fault-inject.c
index 999053fa133e..9fcb91f62b42 100644
--- a/lib/fault-inject.c
+++ b/lib/fault-inject.c
@@ -202,7 +202,7 @@ static int debugfs_ul_get(void *data, u64 *val)
 DEFINE_SIMPLE_ATTRIBUTE(fops_ul, debugfs_ul_get, debugfs_ul_set, "%llu\n");
 
 static void debugfs_create_ul(const char *name, umode_t mode,
-			      struct dentry *parent, unsigned long *value)
+			      struct debugfs_node *parent, unsigned long *value)
 {
 	debugfs_create_file(name, mode, parent, value, &fops_ul);
 }
@@ -221,7 +221,7 @@ DEFINE_SIMPLE_ATTRIBUTE(fops_stacktrace_depth, debugfs_ul_get,
 			debugfs_stacktrace_depth_set, "%llu\n");
 
 static void debugfs_create_stacktrace_depth(const char *name, umode_t mode,
-					    struct dentry *parent,
+					    struct debugfs_node *parent,
 					    unsigned long *value)
 {
 	debugfs_create_file(name, mode, parent, value, &fops_stacktrace_depth);
@@ -229,11 +229,11 @@ static void debugfs_create_stacktrace_depth(const char *name, umode_t mode,
 
 #endif /* CONFIG_FAULT_INJECTION_STACKTRACE_FILTER */
 
-struct dentry *fault_create_debugfs_attr(const char *name,
-			struct dentry *parent, struct fault_attr *attr)
+struct debugfs_node *fault_create_debugfs_attr(const char *name,
+			struct debugfs_node *parent, struct fault_attr *attr)
 {
 	umode_t mode = S_IFREG | S_IRUSR | S_IWUSR;
-	struct dentry *dir;
+	struct debugfs_node *dir;
 
 	dir = debugfs_create_dir(name, parent);
 	if (IS_ERR(dir))
@@ -261,7 +261,7 @@ struct dentry *fault_create_debugfs_attr(const char *name,
 	debugfs_create_xul("reject-end", mode, dir, &attr->reject_end);
 #endif /* CONFIG_FAULT_INJECTION_STACKTRACE_FILTER */
 
-	attr->dname = dget(dir);
+	attr->dname = debugfs_node_get(dir);
 	return dir;
 }
 EXPORT_SYMBOL_GPL(fault_create_debugfs_attr);
diff --git a/mm/backing-dev.c b/mm/backing-dev.c
index e61bbb1bd622..b1c6b34c5842 100644
--- a/mm/backing-dev.c
+++ b/mm/backing-dev.c
@@ -52,7 +52,7 @@ struct wb_stats {
 	unsigned long wb_thresh;
 };
 
-static struct dentry *bdi_debug_root;
+static struct debugfs_node *bdi_debug_root;
 
 static void bdi_debug_init(void)
 {
diff --git a/mm/vmstat.c b/mm/vmstat.c
index 16bfe1c694dd..92f595421fbf 100644
--- a/mm/vmstat.c
+++ b/mm/vmstat.c
@@ -2348,7 +2348,7 @@ DEFINE_SEQ_ATTRIBUTE(extfrag);
 
 static int __init extfrag_debug_init(void)
 {
-	struct dentry *extfrag_debug_root;
+	struct debugfs_node *extfrag_debug_root;
 
 	extfrag_debug_root = debugfs_create_dir("extfrag", NULL);
 
diff --git a/net/wireless/core.c b/net/wireless/core.c
index 12b780de8779..fd8b1b2f575f 100644
--- a/net/wireless/core.c
+++ b/net/wireless/core.c
@@ -44,7 +44,7 @@ LIST_HEAD(cfg80211_rdev_list);
 int cfg80211_rdev_list_generation;
 
 /* for debugfs */
-static struct dentry *ieee80211_debugfs_dir;
+static struct debugfs_node *ieee80211_debugfs_dir;
 
 /* for the cleanup, scan and event works */
 struct workqueue_struct *cfg80211_wq;
diff --git a/net/wireless/debugfs.c b/net/wireless/debugfs.c
index 40e49074e2ee..f7344f2fcd93 100644
--- a/net/wireless/debugfs.c
+++ b/net/wireless/debugfs.c
@@ -102,7 +102,7 @@ static const struct file_operations ht40allow_map_ops = {
 
 void cfg80211_debugfs_rdev_add(struct cfg80211_registered_device *rdev)
 {
-	struct dentry *phyd = rdev->wiphy.debugfsdir;
+	struct debugfs_node *phyd = rdev->wiphy.debugfsdir;
 
 	DEBUGFS_ADD(rts_threshold);
 	DEBUGFS_ADD(fragmentation_threshold);
diff --git a/sound/core/init.c b/sound/core/init.c
index 114fb87de990..b0bab58079f3 100644
--- a/sound/core/init.c
+++ b/sound/core/init.c
@@ -714,7 +714,7 @@ static void snd_card_set_id_no_lock(struct snd_card *card, const char *src,
 	int len, loops;
 	bool is_default = false;
 	char *id;
-	
+
 	copy_valid_id_string(card, src, nid);
 	id = card->id;
 
@@ -1025,7 +1025,7 @@ int __init snd_card_info_init(void)
  *
  *  Return: Zero otherwise a negative error code.
  */
-  
+
 int snd_component_add(struct snd_card *card, const char *component)
 {
 	char *ptr;
diff --git a/sound/core/jack.c b/sound/core/jack.c
index e4bcecdf89b7..330898d855b5 100644
--- a/sound/core/jack.c
+++ b/sound/core/jack.c
@@ -22,7 +22,7 @@ struct snd_jack_kctl {
 	struct snd_jack *jack;  /* pointer to struct snd_jack */
 	bool sw_inject_enable;  /* allow to inject plug event via debugfs */
 #ifdef CONFIG_SND_JACK_INJECTION_DEBUG
-	struct dentry *jack_debugfs_root; /* jack_kctl debugfs root */
+	struct debugfs_node *jack_debugfs_root; /* jack_kctl debugfs root */
 #endif
 };
 
diff --git a/sound/core/sound.c b/sound/core/sound.c
index 6531a67f13b3..53f51f90c56e 100644
--- a/sound/core/sound.c
+++ b/sound/core/sound.c
@@ -41,7 +41,7 @@ int snd_ecards_limit;
 EXPORT_SYMBOL(snd_ecards_limit);
 
 #ifdef CONFIG_SND_DEBUG
-struct dentry *sound_debugfs_root;
+struct debugfs_node *sound_debugfs_root;
 EXPORT_SYMBOL_GPL(sound_debugfs_root);
 #endif
 
diff --git a/sound/drivers/pcmtest.c b/sound/drivers/pcmtest.c
index 72378f354fd0..804bba1007b5 100644
--- a/sound/drivers/pcmtest.c
+++ b/sound/drivers/pcmtest.c
@@ -69,7 +69,7 @@ static short fill_mode = FILL_MODE_PAT;
 
 static u8 playback_capture_test;
 static u8 ioctl_reset_test;
-static struct dentry *driver_debug_dir;
+static struct debugfs_node *driver_debug_dir;
 
 module_param(index, int, 0444);
 MODULE_PARM_DESC(index, "Index value for pcmtest soundcard");
diff --git a/virt/kvm/kvm_main.c b/virt/kvm/kvm_main.c
index faf10671eed2..9444da3829ad 100644
--- a/virt/kvm/kvm_main.c
+++ b/virt/kvm/kvm_main.c
@@ -115,7 +115,7 @@ static struct kmem_cache *kvm_vcpu_cache;
 static __read_mostly struct preempt_ops kvm_preempt_ops;
 static DEFINE_PER_CPU(struct kvm_vcpu *, kvm_running_vcpu);
 
-static struct dentry *kvm_debugfs_dir;
+static struct debugfs_node *kvm_debugfs_dir;
 
 static const struct file_operations stat_fops_per_vm;
 
@@ -1001,7 +1001,7 @@ static void kvm_destroy_vm_debugfs(struct kvm *kvm)
 static int kvm_create_vm_debugfs(struct kvm *kvm, const char *fdname)
 {
 	static DEFINE_MUTEX(kvm_debugfs_lock);
-	struct dentry *dent;
+	struct debugfs_node *dent;
 	char dir_name[ITOA_MAX_LEN * 2];
 	struct kvm_stat_data *stat_data;
 	const struct _kvm_stats_desc *pdesc;
@@ -1017,7 +1017,7 @@ static int kvm_create_vm_debugfs(struct kvm *kvm, const char *fdname)
 	dent = debugfs_lookup(dir_name, kvm_debugfs_dir);
 	if (dent) {
 		pr_warn_ratelimited("KVM: debugfs: duplicate directory %s\n", dir_name);
-		dput(dent);
+		debugfs_node_put(dent);
 		mutex_unlock(&kvm_debugfs_lock);
 		return 0;
 	}
@@ -4044,7 +4044,7 @@ DEFINE_SIMPLE_ATTRIBUTE(vcpu_get_pid_fops, vcpu_get_pid, NULL, "%llu\n");
 
 static void kvm_create_vcpu_debugfs(struct kvm_vcpu *vcpu)
 {
-	struct dentry *debugfs_dentry;
+	struct debugfs_node *debugfs_dentry;
 	char dir_name[ITOA_MAX_LEN * 2];
 
 	if (!debugfs_initialized())
@@ -6216,7 +6216,7 @@ static void kvm_uevent_notify_change(unsigned int type, struct kvm *kvm)
 		char *tmp, *p = kmalloc(PATH_MAX, GFP_KERNEL);
 
 		if (p) {
-			tmp = dentry_path_raw(kvm->debugfs_dentry, p, PATH_MAX);
+			tmp = debugfs_node_path_raw(kvm->debugfs_dentry, p, PATH_MAX);
 			if (!IS_ERR(tmp))
 				add_uevent_var(env, "STATS_PATH=%s", tmp);
 			kfree(p);
